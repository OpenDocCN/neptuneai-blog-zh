<html>
<head>
<title>Version Control Guide For Machine Learning Researchers </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>机器学习研究者的版本控制指南</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/version-control-guide-for-machine-learning-researchers#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/version-control-guide-for-machine-learning-researchers#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p>版本控制用于跟踪和管理项目中的变更，包括关键参数、文档、应用程序等等。当多人在同一代码上工作时，版本控制系统(VCS)就派上了用场。没有VCS，软件项目将会一片混乱。</p>



<p>版本控制也称为<strong>源代码控制、</strong>或<strong>版本控制</strong>。为什么？</p>







<h2 id="what">什么是版本控制？</h2>



<p>版本控制是跟踪对代码库所做更改的一种方式。在ML中，版本控制系统支持开发人员和数据科学家之间的顺畅协作，并允许您在出现问题时将代码库恢复到任何以前的版本。</p>



<p>VCS帮助团队在没有太多复杂性的情况下在同一个项目上协作。开发人员和数据科学家可以根据需要查看、管理和合并变更。新的团队成员可以更容易地适应当前的环境。</p>



<p>在机器学习模型上工作，跟踪用于创建模型的训练数据集、超参数、算法选择、架构和管道总是好的。</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img decoding="async" src="../Images/29e0c9fa99ad76787baa1ec86cf9ec8c.png" alt="Version control tracking" class="wp-image-48017" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221218082900im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Version-control-tracking.png?ssl=1"/><figcaption><em>Source: Author</em></figcaption></figure></div>



<h2 id="types">版本控制系统的类型</h2>



<p>我们将讨论集中式和分布式系统，并详细比较它们。你也可以有一个本地版本控制系统，所有的提交都保存在本地机器上，但是它很容易出错，所以我们不会深入讨论。</p>



<h3>1.集中式版本控制</h3>



<p>在集中式版本控制中，您有一个单一的存储库，其中每个人同时提交和更新代码。当有人更新代码时，团队中的每个人都会知道，并且必须在他们的工作区中更新代码。所做的每一个改变都被传送到一个中央服务器(存储库)。您的更改会直接影响将在生产中使用的主代码。没有批准或合并系统，只是简单的<strong>提交和更新</strong>。</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img decoding="async" src="../Images/e27490de670ff9a7ee5391cc1e70ff5f.png" alt="Centralized version control" class="wp-image-48018" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221218082900im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Centralized-version-control.png?ssl=1"/><figcaption><em>Source: Author</em></figcaption></figure></div>



<ul><li>集中式系统易于理解和管理。</li><li>你可以接触到大师级的代码，不需要得到最高当局的批准。</li><li>它可以无缝地处理二进制文件。</li></ul>



<p>使用最多的中央VCS系统是SVN的T1和T2的T3。</p>



<h3>2.分布式版本控制</h3>



<p>在分布式版本控制中，每个开发人员都有自己的存储库和程序副本。当您更新代码时，只有您可以访问它，直到您将它推送到中央存储库或主代码。简单地说，您提交并推动变更，其他团队成员拉动并更新它们。您不必一直依赖中央存储库，您可以将整个代码克隆到您的本地机器上并离线工作。分布式版本控制也有一个中央存储库，但它是权威的。</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img decoding="async" src="../Images/c22971a1925be396d23ec628e15cad58.png" alt="Distributed version control" class="wp-image-48019" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221218082900im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Distributed-version-control.png?ssl=1"/><figcaption><em>Source: Author</em></figcaption></figure></div>



<ul><li>更好的绩效和治理，</li><li>分支和合并比集中式版本控制更容易，</li><li>你可以离线工作。</li></ul>



<p>最流行的分布式版本控制系统是<a href="https://web.archive.org/web/20221218082900/https://git-scm.com/" target="_blank" rel="noreferrer noopener nofollow"> Git </a>和<a href="https://web.archive.org/web/20221218082900/https://www.mercurial-scm.org/" target="_blank" rel="noreferrer noopener nofollow"> Mercurial </a>。</p>



<h3>集中式和分布式版本控制的差异</h3>



<p id="separator-block_61af59fc17afe" class="block-separator block-separator--10"> </p>



<div id="medium-table-block_61af5a1317aff" class="block-medium-table c-table__outer-wrapper ">

    <table class="c-table">
                    <thead class="c-table__head">
            <tr>
                                    <td class="c-item">
                        <p class="c-item__inner">集中式和分布式</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">分布式版本控制</p>
                    </td>
                            </tr>
            </thead>
        
        <tbody class="c-table__body">

                    
                <tr class="c-row">

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>初学者容易上手</p> </div></td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>对初学者来说复杂的</p> </div></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>在本地机器上离线工作</p> </div></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>这既困难又耗时，并且需要直接与服务器通信。</p>T3】</div></td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>更快，因为你不必为每一个命令都与存储库通信。</p>T3】</div></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">在CVCS，你不需要把整个历史或者源代码保存到你的本地机器上，所以你节省了大量的空间。T3】</td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>如果项目包含大文件，DVCS会占用你本地机器更多的时间和空间。</p>T3】</div></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">如果服务器瘫痪，就没有办法找回代码。T3】</td>

                    
                        <td class="c-ceil">如果服务器宕机，你有足够的机器来获取代码，包括你的本地机器。T3】</td>

                    
                </tr>

                    
        </tbody>
    </table>

</div>



<p id="separator-block_61af5ad517b11" class="block-separator block-separator--20">为什么要使用版本控制</p>



<h2 id="why">VCS允许您合并、更改和查看以前对程序所做的所有更改。这是监控程序构建以及开发和生产中的事情的好方法。对于ML和AI相关的工作，对非二进制文件使用VCS很重要，这样数据科学家和ML开发人员就可以在一个中心工作，而不会影响其他人的工作。版本控制是机器学习和人工智能领域治理的重要组成部分。</h2>



<p>合作</p>



<h3>VCS让开发人员可以在不同时间、不同地点轻松共享、编辑、查看和合并代码。没有VCS，事情会变得非常复杂，代码会很快出错。VCS成为一个公共枢纽或中心，船上的每个人都可以在这里监控项目的进展。</h3>



<p>存储版本</p>







<h3>假设您对程序进行了必要的修改，现在您已经将它合并到生产代码中了。是时候正确地存储那些更改了，<strong>用<strong>正确的版本名</strong>保存文件</strong>(例如- profile-redesign-v102)。如果你添加了又长又复杂的版本名，你将来会迷路的。最好保持简单，采用带有一些语义信息的字母数字格式，以便在需要时可以很容易地跟踪。更新文档在软件世界中非常重要。没有<strong>适当的文档</strong>或自述文件，开发人员就无法跟踪进度。VCS记录了从第一天开始所做的所有更改，你可以请求任何你想要的版本，并且可以与当前版本进行比较。</h3>



<p>审查和备份</p>



<h3>每次你推送或者合并代码时，你都必须添加<strong>简短的信息</strong>关于做了什么改变。这将有助于每个在程序上工作的人知道这个特定的文件已经被改变了。版本控制系统是<strong>备份你的文件和代码的最好方式</strong>。你可以随时获得完整的<strong>更新代码</strong>，不会有任何问题。</h3>



<p>更快的改进</p>



<h3>当推出一个新版本的机器学习模型时，你开始知道它有一些问题或在特定点上失败了。拥有代码的所有<strong>记录</strong>将帮助您恢复先前的代码，并给你足够的时间来处理问题，同时产品代码保持无bug。</h3>



<p>复杂性</p>



<h3>使用标准VCS时，您只需跟踪代码文件、文档和文件依赖关系。对于机器学习来说，这是一件不同而复杂的事情，你必须跟踪你的数据集、模型和不同的参数。你必须留意哪些数据用于训练，哪些用于测试。大多数时候，ML项目中使用多种语言和框架工具，因此跟踪依赖关系成为一项关键任务。开发人员需要时间将模型投入生产，直到他们对性能有信心。VCS帮助开发者在合适的时间推出版本。</h3>



<p>管理</p>



<h3>版本控制是机器学习和人工智能治理的重要组成部分。它帮助公司理解工作流，授予访问权限，执行策略，跟踪和控制所有机器学习工作及其结果。如果管理得当，组织可以收集任何可能影响模型性能的信息。</h3>



<p>数据</p>



<h3>随着时间的推移，数据管道会发生变化。您必须不断训练您的模型，这就是版本控制的范围。您必须跟踪与您的ML工作流相关的所有元数据和结果。元数据将帮助您了解数据集中特定值的性质。以正确的格式将所有数据放入模型非常重要，因此元数据必须有正确的版本。</h3>



<p>使用VCS，您可以将数据值连接到特定版本的相应元数据。这有助于开发人员找到数据集和值中的差距。</p>



<p>模型</p>



<h3>所有的ML项目领导者都想提高他们的ML模型的准确性。如果事实证明之前的版本更准确，VCS会让你快速回到那个版本。</h3>



<p>连续累计</p>



<h3>持续集成(CI)是一种将功能分支实现到主代码中的方法，可以自动构建和测试。该流程帮助开发人员定位问题并快速找到解决方案。<strong>快速失败，快速改进— </strong>这就是CI集成帮助您做到的，它提高了您工作流程的质量。</h3>



<p><em>参见—</em><a href="https://web.archive.org/web/20221218082900/https://neptune.ai/blog/best-7-data-version-control-tools-that-improve-your-workflow-with-machine-learning-projects">利用机器学习项目改善工作流程的最佳7种数据版本控制工具</a></p>







<p>如何做版本控制</p>



<h2 id="how">饭桶</h2>



<h3>最受欢迎的VCS。世界上大多数开发者都使用Git。它跟踪对代码文件所做的所有更改，以便您有一个记录。如果当前代码出现问题，您可以很容易地返回到特定的版本。Git有一个易于管理的协作系统。</h3>



<p>Git的优势:</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img decoding="async" src="../Images/2dbe14b4c4cde36c53aa983425598ab2.png" alt="Version control - collaboration" class="wp-image-48021" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221218082900im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Version-control-collaboration.png?ssl=1"/><figcaption><em>Source: Author</em></figcaption></figure></div>



<p><strong>性能—</strong>这是一个易于维护且可靠的版本控制系统。您可以查看和比较在特定时间内对代码所做的更改，并合并它们。</p>



<ul><li><strong>灵活性</strong>–Git支持多种开发方法和工作流，旨在处理小型和大型项目。它支持分支和标记操作，以存储对项目所做的每个更改。</li><li><strong>广泛接受</strong>–Git因其可用性和性能标准而被普遍接受。</li><li>沙箱</li></ul>



<h3>沙盒是一个团队可以构建、测试和部署程序的环境。在沙盒环境中，代码被分成更小的组或单元。Jupyter Notebook是ML沙盒的最佳工具。有时沙盒环境是测试IT解决方案的最佳方式。沙盒在项目<strong>集成、用户演示和测试以及质量保证方面帮助你。</strong>它为机器学习生命周期的每个阶段都提供了功能，而不仅仅是测试阶段。</h3>



<p>沙盒环境的优势:</p>



<p><strong>易于使用的工作流程—</strong>无缝开发、测试和部署版本。您可以只编辑几行代码并测试它们，而无需推送整个文件/项目。</p>



<ul><li><strong>协作</strong>—分享并让每个人了解项目的最新进展至关重要。你可以用很少的权限获得关于程序的反馈和更新。你可以在著名的技术上工作，而不会有任何复杂的架构。</li><li><strong>经济高效</strong>–沙盒环境是一种按需付费的服务，因此维护您的工作流程变得很容易，并为您的公司节省了大量资金。</li><li>数据版本控制</li></ul>



<h3>数据版本控制(DVC)是一个用于机器学习和数据科学项目的开源工具，这是给你的人工智能项目版本化的最佳方式。它类似于Git，但是有<strong>选项来跟踪步骤、依赖项、数据文件和更多的</strong>。它帮助您存储大型数据集、模型和文件。</h3>



<p>DVC的好处:</p>







<p><strong>独立于语言—</strong>ML流程可以无缝转换为任何语言的可复制管道。</p>



<ul><li><strong>易于安装</strong>–DVC是一款开源工具，您可以通过简单的命令轻松安装:</li><li><strong>数据共享</strong>——你可以在任何云平台上共享你的ML数据文件，比如亚马逊网络服务或者谷歌云平台。</li></ul>



<pre class="hljs">pip install dvc</pre>



<ul><li><strong>数据合规性</strong>–根据Git拉取请求监控数据修改工作。检查项目完善且不可更改的记录，以了解数据集或模型何时获得批准，以及批准的原因。</li><li>使用Neptune进行版本控制</li></ul>



<h3 id="example">Neptune是为研究和生产团队开发的MLOps的元数据存储。它为您提供了一个记录、存储、显示、组织、比较和查询机器学习生命周期中生成的所有元数据的中心。研究人员和工程师使用海王星进行<a href="/web/20221218082900/https://neptune.ai/experiment-tracking" target="_blank" rel="noreferrer noopener">实验跟踪</a>和模型注册，以控制他们的实验和模型开发。</h3>



<p>让我们从初始化Neptune开始:</p>







<p><strong>文件数据版本:</strong></p>



<pre class="hljs"><span class="hljs-keyword">import</span> neptune.new <span class="hljs-keyword">as</span> neptune
run = neptune.init(<span class="hljs-string">'USER_NAME/PROJECT_NAME'</span>,
                   api_token=’ANONYMOUS’)</pre>



<p><strong>文件夹数据版本:</strong></p>



<pre class="hljs"><span class="hljs-keyword">from</span> neptunecontrib.versioning.data <span class="hljs-keyword">import</span> log_data_version
FILEPATH = <span class="hljs-string">'/path/to/data/my_data.csv'</span>
<span class="hljs-keyword">with</span> neptune.create_experiment():
    log_data_version(FILEPATH)</pre>



<p><strong> S3桶数据版本:<br/> </strong>(可以记录版本和具体密钥，类似于文件版本控制)</p>



<pre class="hljs"><span class="hljs-keyword">from</span> neptunecontrib.versioning.data <span class="hljs-keyword">import</span> log_data_version
DIRPATH = <span class="hljs-string">'/path/to/data/folder'</span>
<span class="hljs-keyword">with</span> neptune.create_experiment():
log_data_version(DIRPATH)</pre>



<p><strong>前缀:<br/> </strong>(您可以跟踪多个数据源，只需确保在登录前使用前缀)</p>



<pre class="hljs">BUCKET = <span class="hljs-string">'my-bucket'</span>
PATH = <span class="hljs-string">'training_dataset.csv'</span>
<span class="hljs-keyword">with</span> neptune.create_experiment():
    log_s3_data_version(BUCKET, PATH)</pre>



<p><strong>用子文件夹记录镜像目录快照:<br/> </strong>(用log_image_dir_snapshots可以记录镜像目录的可视快照；查看<a href="https://web.archive.org/web/20221218082900/https://ui.neptune.ai/jakub-czakon/examples/e/EX-96/logs" target="_blank" rel="noreferrer noopener">该实验</a>了解详细信息)</p>



<pre class="hljs"><span class="hljs-keyword">from</span> neptunecontrib.versioning.data <span class="hljs-keyword">import</span> log_data_version
FILEPATH_TABLE_1 = <span class="hljs-string">'/path/to/data/my_table_1.csv'</span>
FILEPATH_TABLE_2 = <span class="hljs-string">'/path/to/data/my_table_2.csv'</span>
<span class="hljs-keyword">with</span> neptune.create_experiment():
log_data_version(FILEPATH_TABLE_1, prefix=<span class="hljs-string">'table_1_'</span>)
log_data_version(FILEPATH_TABLE_2, prefix=<span class="hljs-string">'table_2_'</span>)</pre>



<p>版本控制最佳实践</p>



<pre class="hljs"><span class="hljs-keyword">from</span> neptunecontrib.versioning.data <span class="hljs-keyword">import</span> log_image_dir_snapshots
PATH = <span class="hljs-string">'/path/to/data/my_image_dir'</span>
<span class="hljs-keyword">with</span> neptune.create_experiment():
log_image_dir_snapshots(PATH)</pre>



<h2 id="best-practices">使用良好的提交消息</h2>



<h3>一个好的提交消息将帮助其他开发人员和团队成员理解你更新了什么。添加一个简短的信息描述会使事情更容易回顾。</h3>



<p>让每一次承诺变得重要</p>



<h3>确保你的承诺是有目的的，而不仅仅是你工作的备份。添加新功能或修复问题。尽量不要在一次提交中进行多次更改，因为这将很难审查。</h3>



<p>在这个过程中，您可能会发现一些bug，也想修复它们。如果您想一次提交一个文件，下面是针对不同VCS的命令:</p>



<p>Git: <code>git commit filename1 filename2</code>提交两个命名文件。</p>



<ul><li>SVN: <code>svn commit filename filename2</code>提交两个文件。它将所有更新的文件提交到目录中。</li><li>如果您想要保存一个支持多个变更(例如多个特性)的文件，那么您必须在逻辑块中引入它们，并在进行过程中进行提交。每个VCS都支持此操作:</li></ul>



<p>Git:将<em>文件名</em>存储到一个安全的临时位置，然后运行git checkout文件名将<em>文件名</em>恢复到其未更改的状态。</p>



<ul><li>svn:将<em>文件名</em>移动到一个临时位置，然后运行SVN更新文件名<em>T3，将<em>文件名</em>恢复到不变的状态。</em></li><li>不要破坏构建或强制提交</li></ul>



<h3>尝试通过执行完全提交来避免中断构建。您可以为您的提交和新API准备测试用例。这有助于其他团队成员在不破坏构建的情况下使用这些文件。假设你正在开发某个API，它在你的机器上运行得很好，但是在另一台机器上可能会崩溃。另外，如果VCS没有推送你的更新或者显示错误信息，最好<strong>不要</strong> <strong>强行提交任何东西</strong>。这可能会打破整个工作流程，把事情搞得一团糟。</h3>



<p>审查和分支</p>



<h3>每当您提交代码并将其推送到中央存储库时，请确保您做了很好的审查。这将帮助您理解提交，并找到提交中的问题或差距。</h3>



<p>在许多情况下，分支有助于改进工作流。它有一些缺点，但是如果您使用良好的分支实践，您可以使管理代码、发布、里程碑、问题、新特性等等变得容易。</p>



<p>进行可跟踪的提交</p>



<h3>出于安全和监控的目的，您需要存储关于提交的信息，比如审阅者评论、关于提交的信息、作者详细信息等等。这将确保如果需要，任何提交都可以被撤销。分析问题后，可以重新应用或更新更改。</h3>



<p>结论</p>



<h2 id="h-conclusion">版本控制系统是监控和跟踪所有代码文件、数据集、依赖项、文档和项目的其他关键资产的变更的最佳方式。</h2>



<p>有了VCS，每个团队成员都在同一个页面上，协作更顺畅，工作流更好，错误更少，开发速度逐渐加快。</p>



<p>额外研究和推荐阅读</p>



<h3>Additional research and recommended reading</h3>




        </div>
        
    </div>    
</body>
</html>