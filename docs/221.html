<html>
<head>
<title>Optuna Guide: How to Monitor Hyper-Parameter Optimization Runs </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Optuna指南:如何监控超参数优化运行</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/optuna-guide-how-to-monitor-hyper-parameter-optimization-runs#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/optuna-guide-how-to-monitor-hyper-parameter-optimization-runs#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p><a href="/web/20221206040852/https://neptune.ai/blog/how-to-track-hyperparameters" target="_blank" rel="noreferrer noopener">超参数搜索</a>几乎是每个机器学习和深度学习项目的一部分。当您选择一个候选模型时，您要确保它以最好的方式概括您的测试数据。</p>



<p>如果是线性回归这样的简单模型，手动选择最佳超参数很容易。对于像神经网络这样的复杂模型，手工调整是很困难的。</p>



<p>例如，如果我们训练一个只有线性层的神经网络，下面是一组潜在的超参数:</p>



<ul><li>层数</li><li>每层单位</li><li>正则化强度</li><li>激活功能</li><li>学习率</li><li>优化器参数(2-3个变量)</li><li>丢失保持概率</li></ul>



<p>即使这8个变量中的每一个都有2个候选值，你最终会得到2^8 = 256个实验。对于更大的网络和更多的候选值，这个数字变得难以承受。</p>



<p>在本文中，我们将探索如何使用流行的框架<a href="https://web.archive.org/web/20221206040852/https://optuna.readthedocs.io/en/stable/" target="_blank" rel="noreferrer noopener nofollow"> Optuna </a>为复杂模型设置超参数。</p>







<h2 id="h-how-to-approach-hyper-parameter-selection">如何进行超参数选择</h2>



<p>我们需要考虑寻找最佳超参数值的有效策略。</p>



<p><strong>一种简单的超参数搜索方法是网格搜索</strong>，如上例所示:我们为每个超参数手动设置候选值，并对每个超参数值组合进行模型训练和评估。</p>



<p class="has-text-align-left"><em>对于具有m1，m2，…，mk个候选值的k个超参数，</em> <br/> <strong> <em>实验次数= m1*m2* … *mk </em> </strong></p>



<p>这种方法的主要缺点是:</p>



<ul><li>资源密集型——执行大量实验将需要大量计算资源。</li><li>非最优–即使该策略穷尽了所有可能的组合，候选值也是由我们设定的。最佳值可能完全不在此候选池中。</li><li>耗时——在深度学习中，一个实验需要几个小时才能完成，这种策略效率不高。</li></ul>



<p>另一种传统方法是随机搜索。在这里，您在一个定义的值范围内随机选择一个变量。这种方法比网格搜索更具探索性，限制更少，而且与网格搜索相比，您还可以测试更大范围的候选值。</p>





<p>这些方法都不能满足我们收敛到最佳超参数值集的需要。我们需要更有效的算法，以更少的试验来估计最佳超参数。</p>



<p><strong>一些算法使用贝叶斯优化来实现这一点</strong>。这个想法是对搜索过程进行概率建模。该模型使用通过使用某些超参数组合集获得的度量值来选择下一个组合，使得度量的改进最大化。</p>



<p>在Python中有许多框架可以用来实现这些算法——HyperOpt、Scikit-Optimize、Optuna等等。</p>



<p>我们将重点讨论Optuna——可以说是所有选项中最简单的一个。</p>



<h2 id="h-best-features-of-optuna">Optuna的最佳功能</h2>



<h3>由运行定义范例</h3>



<p>据Optuna的作者称，Optuna的三个特征使其脱颖而出(来源:<a href="https://web.archive.org/web/20221206040852/https://arxiv.org/abs/1907.10902" target="_blank" rel="noreferrer noopener nofollow">论文</a>)</p>



<ol><li><em>通过运行定义程序，允许用户动态构建搜索空间。</em></li><li><em>高效的采样算法和剪枝算法，允许一些用户定制。</em></li><li><em>易于设置的多功能架构，可部署用于各种类型的任务</em>。</li></ol>



<p>Optuna很容易安装。考虑论文中描述的情况:</p>



<pre class="hljs"><span class="hljs-keyword">import</span> optuna
<span class="hljs-keyword">import</span> ...

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">objective</span> <span class="hljs-params">(trial)</span>:</span>
    n layers = trial. suggest int (’n layers ’, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)

    layers = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range( n layers ):
    layers.append(trial. suggest int (’n units l {} ’.
    format(i), <span class="hljs-number">1</span>, <span class="hljs-number">128</span>))

    clf = MLPClassifier (tuple(layers))

    mnist = fetch mldata (’MNIST original’)
    x train , x test , y train , y test = train test split (
    mnist.data , mnist.target)

    clf.fit( x train , y train )

    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> − clf.score( x test , y test )

study = optuna. create study ()
study.optimize(objective , n trials =<span class="hljs-number">100</span>)</pre>



<p class="has-text-align-center"><a href="https://web.archive.org/web/20221206040852/https://arxiv.org/abs/1907.10902" target="_blank" rel="noreferrer noopener nofollow"> <em>来源</em> </a></p>



<p>目的是通过优化隐层和每层中单元的数量来搜索最佳的神经网络结构。我们定义一个函数，在本例中是<strong> <em>目标</em> </strong>，它接受一个名为<strong> <em>的对象进行试验</em> </strong>。</p>



<p>这个<strong> <em>试验</em> </strong>对象用于在目标函数内部构建一个模型。在这种情况下，我们使用trial的<strong> suggest_int </strong>方法选择层数和每层中的单元数。此方法选择1到4之间的一个值。有许多类型的<strong> suggest_ </strong>方法可用，涵盖不同的场景。<strong> <em>试验</em> </strong>对象负责建议提供最佳结果的超参数值。</p>



<p>目标函数返回需要最小化或最大化的单个数字——准确度、损失、f1分数。然后，创建一个研究对象，并传递两个参数——目标函数和希望研究持续的实验次数。就是这样。</p>



<p>请注意，我们根本没有预定义模型架构。它是完全动态构建的。在另一个称为<strong> <em>远视</em> </strong>的框架中考虑同样的任务:</p>



<pre class="hljs"><span class="hljs-keyword">import</span> hyperopt
<span class="hljs-keyword">import</span> ...

space = {
    ’n_units_l1 ’: hp.randint(’n_units_l1 ’, <span class="hljs-number">128</span>) ,
    ’l2’: hp.choice(’l2’, [{
        ’has_l2 ’: <span class="hljs-keyword">True</span> ,
        ’n_units_l2 ’: hp.randint(’n_units_l2 ’, <span class="hljs-number">128</span>) ,
        ’l3’: hp.choice(’l3’, [{
            ’has_l3 ’: <span class="hljs-keyword">True</span> ,
            ’n_units_l3 ’: hp.randint(’n_units_l3 ’, <span class="hljs-number">128</span>) ,
            ’l4’: hp.choice(’l4’, [{
                ’has_l4 ’: <span class="hljs-keyword">True</span> ,
                ’n_units_l4 ’: hp.randint(’n_units_l4 ’, <span class="hljs-number">128</span>) ,
            }, {’has_l4 ’: <span class="hljs-keyword">False</span> }]) ,
        }, {’has_l3 ’: <span class="hljs-keyword">False</span> }]) ,
    }, {’has_l2 ’: <span class="hljs-keyword">False</span> }]) ,
}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">objective</span> <span class="hljs-params">(space)</span>:</span>
    layers = [space[’n_units_l1 ’] + <span class="hljs-number">1</span>]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>):
        space = space[’l{} ’.format(i)]
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> space[’has_l {} ’.format(i)]:
            <span class="hljs-keyword">break</span>
        layers.append(space[’n_units_l {} ’.format(i)] +
<span class="hljs-number">1</span>)

    clf = MLPClassifier (tuple(layers))

    mnist = fetch mldata (’MNIST original’)
    x_train , x_ test , y_train , y_test = train test split (mnist.data , mnist.target)

    clf.fit(x_train , y_train)

    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> − clf.score(x_test , y_test )

hyperopt.fmin(fn=objective , space=space , max_evals =<span class="hljs-number">100</span> ,
algo=hyperopt .tpe.suggest)
</pre>



<p class="has-text-align-center"><a href="https://web.archive.org/web/20221206040852/https://arxiv.org/abs/1907.10902" target="_blank" rel="noreferrer noopener nofollow"> <em>来源</em> </a></p>



<p>一开始，你看到一个叫做<strong> <em>空间</em> </strong>的大嵌套字典。用英语来说应该是这样的:</p>



<p><em>决定是否包含第一层。如果是，建议隐藏单元的数量。决定是否包含第二层。如果是，建议隐藏单元的数量。决定第三个… </em></p>



<p>不是很有活力。这不像Optuna的运行定义特性，我们在运行中定义模型。Hyoperopt更明确和运行。</p>



<h3>高效采样</h3>



<h4><strong>树Parzen估计器(TPE) </strong></h4>



<p>默认情况下，Optuna使用一种称为Tree-Parzen estimator的技术，根据实验历史选择下一步要尝试的超参数集。考虑一个简单的例子，其中历史包括100次试验，列表如下:</p>



<p id="separator-block_61ae152a2d949" class="block-separator block-separator--20"> </p>







<p id="separator-block_60255b4fe6551" class="block-separator block-separator--20"> </p>



<p>我们将该表的行分成2部分，一部分损失&lt; 0.03(好结果表)，其余部分(不太好结果表)。在我们用X轴作为参数值，Y轴作为损耗来绘制这两个分布的函数之后，我们得到这样的图(为了便于解释而过度简化):</p>





<p>上面的图是使用好的结果(带有损失&lt; 0.03). We call it <em> g(x) </em>构建的，其中x是参数值。下图显示了不太好的结果。我们称之为<em> l(x)。</em></p>





<p>对于一个新的实验，这个超参数的一个新值是使用:</p>





<h4><strong>协方差矩阵自适应进化策略(CMA-ES) </strong></h4>



<p>Optuna还提供了另一种采样策略，CMA-ES。它通过更新超参数的均值和方差来动态构建搜索空间。</p>



<p>对于<em> k </em>超参数，在<em> N </em>次实验之后，我们使用最好的，比如说，25%的实验(这里的最好是根据感兴趣的度量——精确度，f1来决定的)。我们计算了这些超参数联合分布的均值和协方差矩阵。</p>



<p>这里的一个巧妙之处是，在估计协方差矩阵时，使用上一代(一组试验)的平均值，而不是使用以前的试验为这一代估计的平均值。像这样:</p>





<p class="has-text-align-center"><em>计算下一代(g+1)的均值。来源:<a href="https://web.archive.org/web/20221206040852/https://blog.otoro.net/2017/10/29/visual-evolution-strategies/" target="_blank" rel="noreferrer noopener nofollow">Otoro.net</a>T3】</em></p>





<p>正如您在上面的等式中看到的，下一代(<em> g+1 </em>)的方差和协方差值是使用当前一代<em> g </em>的平均值来估计的。</p>



<p>一旦我们有了这个更新的分布，我们就可以通过从这个超参数值的分布中取样来进行实验。查看<a href="https://web.archive.org/web/20221206040852/https://blog.otoro.net/2017/10/29/visual-evolution-strategies/" target="_blank" rel="noreferrer noopener nofollow">这篇</a>文章了解更多详情。</p>



<h3>修剪</h3>



<p>Optuna通过修剪节省您的时间。简单地说，如果一个实验基于损失或验证度量的中间值看起来没有希望，那么这个实验就被中止。</p>



<p>Optuna使用之前实验的信息来做出决定。它问在这个时期中间损失的值是多少，在同一阶段以前的实验的损失是多少。</p>



<p>例如，中位数普鲁纳将特定步骤的当前实验与同一步骤的先前实验进行比较。如果表现好于之前实验的中间值，试验将继续，如果不是，试验将中止。</p>



<h2 id="h-using-optuna-in-your-code-case-study">在代码中使用Optuna(案例研究)</h2>



<h3>代码</h3>



<p>让我们深入研究代码。我们将使用来自<strong> sklearn.datasets </strong>的数字数据集。它有8*8大小的图像存储为一维数组。有10个标签。</p>



<h4><strong>导入相关包</strong></h4>



<p>打开一个jupyter笔记本，导入这些包和函数。确保在python环境中安装这些包。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> sklearn
<span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> optuna
<span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier
<span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression
<span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter
<span class="hljs-keyword">import</span> time</pre>



<h4><strong>加载数据</strong></h4>



<p>如上所述，我们加载数字数据集。Sklearn会自动给你下载。我们将数据分成训练集和验证集。</p>



<pre class="hljs">data = datasets.load_digits()

X = data.data
y = data.target

X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, shuffle=<span class="hljs-keyword">True</span>)

print(<span class="hljs-string">"Train data shape: "</span>, X_train.shape)
print(<span class="hljs-string">"Validation data shape: "</span>, X_val.shape)</pre>



<p>输出:</p>



<pre class="hljs">Train data shape:  (<span class="hljs-number">1437</span>, <span class="hljs-number">64</span>)
Validation data shape:  (<span class="hljs-number">360</span>, <span class="hljs-number">64</span>)</pre>



<p>检查标签:</p>



<pre class="hljs">Counter(y_train)

</pre>



<p>输出:</p>



<pre class="hljs">Counter({<span class="hljs-number">6</span>: <span class="hljs-number">142</span>,
         <span class="hljs-number">4</span>: <span class="hljs-number">147</span>,
         <span class="hljs-number">7</span>: <span class="hljs-number">143</span>,
         <span class="hljs-number">8</span>: <span class="hljs-number">141</span>,
         <span class="hljs-number">1</span>: <span class="hljs-number">151</span>,
         <span class="hljs-number">3</span>: <span class="hljs-number">147</span>,
         <span class="hljs-number">9</span>: <span class="hljs-number">145</span>,
         <span class="hljs-number">2</span>: <span class="hljs-number">142</span>,
         <span class="hljs-number">0</span>: <span class="hljs-number">134</span>,
         <span class="hljs-number">5</span>: <span class="hljs-number">145</span>})</pre>



<p>我们选择准确性作为感兴趣的衡量标准，因为不存在等级不平衡:</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">model_performance</span><span class="hljs-params">(model, X=X_val, y=y_val)</span>:</span>
    <span class="hljs-string">"""
    Get accuracy score on validation/test data from a trained model
    """</span>
    y_pred = model.predict(X)
    <span class="hljs-keyword">return</span> round(accuracy_score(y_pred, y),<span class="hljs-number">3</span>)</pre>



<p><strong> model_performance </strong>只是我们前面使用的一个辅助函数。</p>



<p>在进行任何超参数搜索之前，让我们考虑一个简单的决策树，看看它在未调优时的性能。</p>



<pre class="hljs">
model = DecisionTreeClassifier()
model.fit(X_train, y_train)

print(<span class="hljs-string">"Validation accuracy: "</span>, model_performance(model))</pre>



<p>输出:</p>



<pre class="hljs">Validation accuracy:  <span class="hljs-number">0.861</span>
</pre>



<p>我们将记住这个分数，以了解我们通过使用Optuna获得了多少改进。</p>



<h4><strong>创建超参数优化过程</strong></h4>



<p>我们最终开始创建我们的目标函数并研究:</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_model</span><span class="hljs-params">(trial)</span>:</span>
    model_type = trial.suggest_categorical(<span class="hljs-string">'model_type'</span>, [<span class="hljs-string">'logistic-regression'</span>, <span class="hljs-string">'decision-tree'</span>, <span class="hljs-string">'svm'</span>])

    <span class="hljs-keyword">if</span> model_type == <span class="hljs-string">'svm'</span>:
        kernel = trial.suggest_categorical(<span class="hljs-string">'kernel'</span>, [<span class="hljs-string">'linear'</span>, <span class="hljs-string">'poly'</span>, <span class="hljs-string">'rbf'</span>, <span class="hljs-string">'sigmoid'</span>])
        regularization = trial.suggest_uniform(<span class="hljs-string">'svm-regularization'</span>, <span class="hljs-number">0.01</span>, <span class="hljs-number">10</span>)
        degree = trial.suggest_discrete_uniform(<span class="hljs-string">'degree'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>)
        model = SVC(kernel=kernel, C=regularization, degree=degree)

    <span class="hljs-keyword">if</span> model_type == <span class="hljs-string">'logistic-regression'</span>:
        penalty = trial.suggest_categorical(<span class="hljs-string">'penalty'</span>, [<span class="hljs-string">'l2'</span>, <span class="hljs-string">'l1'</span>])
        <span class="hljs-keyword">if</span> penalty == <span class="hljs-string">'l1'</span>:
            solver = <span class="hljs-string">'saga'</span>
        <span class="hljs-keyword">else</span>:
            solver = <span class="hljs-string">'lbfgs'</span>
        regularization = trial.suggest_uniform(<span class="hljs-string">'logistic-regularization'</span>, <span class="hljs-number">0.01</span>, <span class="hljs-number">10</span>)
        model = LogisticRegression(penalty=penalty, C=regularization, solver=solver)

    <span class="hljs-keyword">if</span> model_type == <span class="hljs-string">'decision-tree'</span>:
        max_depth = trial.suggest_int(<span class="hljs-string">'max_depth'</span>, <span class="hljs-number">5</span>, X_train.shape[<span class="hljs-number">1</span>])
        min_samples_split = trial.suggest_int(<span class="hljs-string">'min_samples_split'</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>)
        min_samples_leaf = trial.suggest_int(<span class="hljs-string">'min_samples_leaf'</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>)
        model = DecisionTreeClassifier(
            max_depth=max_depth, min_samples_split=min_samples_split, min_samples_leaf=min_samples_leaf
          )

    <span class="hljs-keyword">if</span> trial.should_prune():
            <span class="hljs-keyword">raise</span> optuna.TrialPruned()

    <span class="hljs-keyword">return</span> model
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">objective</span><span class="hljs-params">(trial)</span>:</span>
    model = create_model(trial)
    model.fit(X_train, y_train)
    <span class="hljs-keyword">return</span> model_performance(model)</pre>



<p><strong> create_model </strong>是一个助手函数，它接受一个试验对象并返回一个模型<strong>。</strong>我们在搜索领域使用了三种不同的模型——逻辑回归、决策树和SVM。试用对象使用<strong>建议分类</strong>方法从这三个中选择一个。根据模型的类型，进一步选择超参数。</p>



<p>在<strong>目标</strong>函数中，我们使用<strong> create_model </strong>来生成一个模型，并将其拟合到我们的训练数据上。我们返回模型精度:</p>



<pre class="hljs">study = optuna.create_study(direction=<span class="hljs-string">'maximize'</span>, study_name=<span class="hljs-string">"starter-experiment"</span>, storage=<span class="hljs-string">'sqlite:///starter.db'</span>)</pre>



<p>此时，我很快在neptune.ai上创建了一个名为<strong> blog-optuna </strong>的项目，继续使用代码，您可以在笔记本上创建一个关于neptune的实验。我的实验名称是<strong> optuna guide </strong>。请注意，使用neptune运行optuna研究并不是必需的。如果您希望稍后尝试neptune，只需注释前面代码中提到的代码行。</p>



<p>在<a href="/web/20221206040852/https://neptune.ai/" target="_blank" rel="noreferrer noopener"> neptune.ai </a>上注册即可获得neptune API令牌(只需一分钟)。</p>



<ul><li>导入neptune并创建跑步记录</li></ul>



<pre class="hljs"><span class="hljs-keyword">import</span> neptune.new <span class="hljs-keyword">as</span> neptune

run = neptune.init(
              project=”&lt;YOUR_PROJECT_NAME&gt;”
	  api_token = <span class="hljs-string">"&lt;YOUR_API TOKEN&gt;"</span>
)
</pre>



<ul><li>导入并初始化NeptuneCallback</li></ul>



<pre class="hljs"><span class="hljs-keyword">import</span> neptune.new.integrations.optuna <span class="hljs-keyword">as</span> optuna_utils

neptune_callback = optuna_utils.NeptuneCallback(run)
</pre>



<p>使用<a href="https://web.archive.org/web/20221206040852/https://docs.neptune.ai/integrations-and-supported-tools/hyperparameter-optimization/optuna" target="_blank" rel="noreferrer noopener"> Neptune-Optuna集成</a>，Neptune将自动记录所有有价值的信息，并为我们创建可视化效果。</p>







<pre class="hljs">study = optuna.create_study(direction=<span class="hljs-string">'maximize'</span>, study_name=<span class="hljs-string">"starter-experiment"</span>, storage=<span class="hljs-string">'sqlite:///starter.db'</span>)
</pre>



<p>因为我们想要最大化目标函数的返回值，方向参数被设置为最大化。我们可以使用study_name参数为我们的研究命名。</p>



<p>如果我们希望将实验存储在sql-lite数据库中，我们可以将存储参数值设置为类似于“sqlite:/// <path to="" your="" .db="" file="">”的值。</path></p>



<p>最后，我们可以将neptune_callback传递给study.optimize() callbacks参数，并开始超参数优化过程。我已经设置了300次试验。</p>



<pre class="hljs">study.optimize(objective, n_trials=<span class="hljs-number">300</span>, callbacks=[neptune_callback])
</pre>



<p>输出:</p>



<pre class="hljs">[I <span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">16</span>:<span class="hljs-number">06</span>:<span class="hljs-number">18</span>,<span class="hljs-number">599</span>] A new study created <span class="hljs-keyword">in</span> RDB <span class="hljs-keyword">with</span> name: starter-experiment
[I <span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">16</span>:<span class="hljs-number">06</span>:<span class="hljs-number">18</span>,<span class="hljs-number">699</span>] Trial <span class="hljs-number">0</span> finished <span class="hljs-keyword">with</span> value: <span class="hljs-number">0.828</span> <span class="hljs-keyword">and</span> parameters: {<span class="hljs-string">'model_type'</span>: <span class="hljs-string">'decision-tree'</span>, <span class="hljs-string">'max_depth'</span>: <span class="hljs-number">12</span>, <span class="hljs-string">'min_samples_split'</span>: <span class="hljs-number">16</span>, <span class="hljs-string">'min_samples_leaf'</span>: <span class="hljs-number">19</span>}. Best <span class="hljs-keyword">is</span> trial <span class="hljs-number">0</span> <span class="hljs-keyword">with</span> value: <span class="hljs-number">0.828</span>.
[I <span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">16</span>:<span class="hljs-number">06</span>:<span class="hljs-number">20</span>,<span class="hljs-number">161</span>] Trial <span class="hljs-number">1</span> finished <span class="hljs-keyword">with</span> value: <span class="hljs-number">0.983</span> <span class="hljs-keyword">and</span> parameters: {<span class="hljs-string">'model_type'</span>: <span class="hljs-string">'svm'</span>, <span class="hljs-string">'kernel'</span>: <span class="hljs-string">'rbf'</span>, <span class="hljs-string">'svm-regularization'</span>: <span class="hljs-number">6.744450268290869</span>, <span class="hljs-string">'degree'</span>: <span class="hljs-number">5.0</span>}. Best <span class="hljs-keyword">is</span> trial <span class="hljs-number">1</span> <span class="hljs-keyword">with</span> value: <span class="hljs-number">0.983</span>.
[I <span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">16</span>:<span class="hljs-number">06</span>:<span class="hljs-number">20</span>,<span class="hljs-number">333</span>] Trial <span class="hljs-number">2</span> finished <span class="hljs-keyword">with</span> value: <span class="hljs-number">0.964</span> <span class="hljs-keyword">and</span> parameters: {<span class="hljs-string">'model_type'</span>: <span class="hljs-string">'logistic-regression'</span>, <span class="hljs-string">'penalty'</span>: <span class="hljs-string">'l2'</span>, <span class="hljs-string">'logistic-regularization'</span>: <span class="hljs-number">7.0357613534815595</span>}. Best <span class="hljs-keyword">is</span> trial <span class="hljs-number">1</span> <span class="hljs-keyword">with</span> value: <span class="hljs-number">0.983</span>.
[I <span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-12</span> <span class="hljs-number">16</span>:<span class="hljs-number">06</span>:<span class="hljs-number">20</span>,<span class="hljs-number">437</span>] Trial <span class="hljs-number">3</span> finished <span class="hljs-keyword">with</span> value: <span class="hljs-number">0.983</span> <span class="hljs-keyword">and</span> parameters: {<span class="hljs-string">'model_type'</span>: <span class="hljs-string">'svm'</span>, <span class="hljs-string">'kernel'</span>: <span class="hljs-string">'poly'</span>, <span class="hljs-string">'svm-regularization'</span>: <span class="hljs-number">9.24945497106145</span>, <span class="hljs-string">'degree'</span>: <span class="hljs-number">3.0</span>}. Best <span class="hljs-keyword">is</span> trial <span class="hljs-number">1</span> <span class="hljs-keyword">with</span> value: <span class="hljs-number">0.983</span>.
.
.
.
</pre>



<p>最后，为了获得最佳模型:</p>



<pre class="hljs">best_model = create_model(study.best_trial)
best_model.fit(X_train, y_train)
print(<span class="hljs-string">"Performance: "</span>, model_performance(best_model))</pre>



<p>输出:</p>



<pre class="hljs">Performance:  <span class="hljs-number">0.989</span></pre>



<h2 id="h-visualizing-the-process-using-neptune">用海王星来观察这个过程</h2>



<p>我们用一行代码集成了Neptune和Optuna。让我们看看我们生成了什么。要获得这些图，请在neptune.ai上进行实验，并在<em>工件</em>选项卡下下载图表。如果你没有在你的代码中使用neptune，请随意浏览我的项目<a href="https://web.archive.org/web/20221206040852/https://ui.neptune.ai/dhruvil/blog-optuna/e/BLOG-15/logs" target="_blank" rel="noreferrer noopener">这里</a>。</p>






<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" src="../Images/95e6127acc5ecce3521617aa2f66070a.png" alt="Optimization history plot" class="wp-image-34843" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206040852im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Optimization-history-plot.png?ssl=1"/><figcaption><em>Link to the charts – <a href="https://web.archive.org/web/20221206040852/https://ui.neptune.ai/dhruvil/blog-optuna/e/BLOG-15/artifacts?path=charts%2F" target="_blank" rel="noreferrer noopener">here</a></em></figcaption></figure></div>


<p class="has-text-align-center"/>



<p>上面的图显示了我们的目标度量在300次试验中的进展。我们看到在最初的120次试验中达到了最佳值。</p>



<p>在下面的切片图中，我们可以看到各个参数的哪些值有助于实现最佳性能:</p>


<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" src="../Images/3021e5b4b031c77cf705bdc2989b7454.png" alt="Optuna guide slice plot" class="wp-image-34845" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206040852im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Optuna-guide-slice-plot.png?ssl=1"/><figcaption><em>Link to the charts – <a href="https://web.archive.org/web/20221206040852/https://ui.neptune.ai/dhruvil/blog-optuna/e/BLOG-15/artifacts?path=charts%2F" target="_blank" rel="noreferrer noopener">here</a></em></figcaption></figure></div>


<p>还有一些——等高线图和平行坐标。这些可视化使得搜索过程不再是一个黑箱。</p>



<p>即使您必须运行新的研究，了解这些图表也有助于您确定哪些超参数对感兴趣的指标不重要，以及为了更好、更快地收敛，应该考虑哪些值的范围。</p>



<h2 id="h-advanced-options">高级选项</h2>



<p>为了使您的项目工作更简单，您可以使用Optuna提供的这些高级配置:</p>



<ul><li><strong>使用RDB后端恢复研究</strong>–如果您创建了一个具有某个名称和某个数据库后端的研究，您可以在任何时间点恢复它。例子(<a href="https://web.archive.org/web/20221206040852/https://optuna.readthedocs.io/en/stable/tutorial/003_rdb.html#rdb" target="_blank" rel="noreferrer noopener nofollow">链接</a>):</li></ul>



<pre class="hljs"><span class="hljs-keyword">import</span> optuna
study_name = <span class="hljs-string">'example-study'</span>  
study = optuna.create_study(study_name=study_name, storage=<span class="hljs-string">'sqlite:///example.db'</span>)</pre>



<p>要加载该研究:</p>



<pre class="hljs">study = optuna.create_study(study_name=<span class="hljs-string">'example-study'</span>, storage=<span class="hljs-string">'sqlite:///example.db'</span>, load_if_exists=<span class="hljs-keyword">True</span>)
study.optimize(objective, n_trials=<span class="hljs-number">3</span>)
</pre>



<ul><li><strong>分布式优化【T1—<strong/>对于大规模实验，分布式优化可以让你的收敛时间减少几个数量级。最重要的是，使用它非常简单。当您使用终端运行脚本时(如下所示):</strong></li></ul>



<pre class="hljs">$ python foo.py
</pre>



<p>只需打开另一个终端，并在这个新窗口中运行脚本。这两个流程共享试验历史记录。创建病历报告时，确保您使用的是sqlite存储器。(<a href="https://web.archive.org/web/20221206040852/https://optuna.readthedocs.io/en/v1.1.0/tutorial/distributed.html" target="_blank" rel="noreferrer noopener nofollow">参考</a></p>



<ul><li>使用CLI的Optuna-使用Optuna中的CLI选项，您可以避免大量的boiler-plate代码。考虑这个例子(<a href="https://web.archive.org/web/20221206040852/https://optuna.readthedocs.io/en/stable/tutorial/005_cli.html" target="_blank" rel="noreferrer noopener nofollow">链接</a>):</li></ul>



<p>您的python脚本应该定义一个目标函数。</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">objective</span><span class="hljs-params">(trial)</span>:</span>
    x = trial.suggest_uniform(<span class="hljs-string">'x'</span>, <span class="hljs-number">-10</span>, <span class="hljs-number">10</span>)
    <span class="hljs-keyword">return</span> (x - <span class="hljs-number">2</span>) ** <span class="hljs-number">2</span>
</pre>



<p>在您的CLI中:</p>



<pre class="hljs">$ STUDY_NAME=`optuna create-study --storage sqlite:///example.db`
$ optuna study optimize foo.py objective --n-trials=<span class="hljs-number">100</span> --storage sqlite:///example.db --study-name $STUDY_NAME
</pre>



<p>就是这样。</p>



<ul><li><strong>多目标研究–</strong>在我们的示例中，目标函数返回一个数字，我们选择将其最小化或最大化。然而，我们也可以返回多个值。我们只需要为它们中的每一个指定方向。考虑下面的例子(<a href="https://web.archive.org/web/20221206040852/https://optuna.readthedocs.io/en/stable/reference/multi_objective/generated/optuna.multi_objective.study.create_study.html#optuna.multi_objective.study.create_study">链接</a>):</li></ul>



<pre class="hljs"><span class="hljs-keyword">import</span> optuna
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">objective</span><span class="hljs-params">(trial)</span>:</span>
    x = trial.suggest_float(<span class="hljs-string">"x"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
    y = trial.suggest_float(<span class="hljs-string">"y"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>)

    v0 = <span class="hljs-number">4</span> * x ** <span class="hljs-number">2</span> + <span class="hljs-number">4</span> * y ** <span class="hljs-number">2</span>
    v1 = (x - <span class="hljs-number">5</span>) ** <span class="hljs-number">2</span> + (y - <span class="hljs-number">5</span>) ** <span class="hljs-number">2</span>
    <span class="hljs-keyword">return</span> v0, v1
study = optuna.multi_objective.create_study([<span class="hljs-string">"minimize"</span>, <span class="hljs-string">"minimize"</span>])
study.optimize(objective, n_trials=<span class="hljs-number">3</span>)

</pre>



<p>如您所见，我们返回两个值，而不是optuna.create_study，而是使用optuna . multi _ objective . create _ study。此外，方向是一个字符串列表，而不仅仅是一个字符串。</p>



<h2 id="h-conclusion-and-final-remarks">结论和结束语</h2>



<p>数据科学项目有许多活动的部分。它们会很快变得很乱。</p>



<p>您可以通过使用干净的方法选择最佳的模型超参数来减少这种混乱。</p>



<p>对于大多数类型的ML/DL建模，Optuna是最简单的框架之一。将它与Neptune集成，您可以跟踪所有的扫描和可视化，并轻松地将您的结果传达给您的团队。</p>



<p>试试看你是否喜欢它，我知道我肯定会使用Optuna一段时间。</p>
        </div>
        
    </div>    
</body>
</html>