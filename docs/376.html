<html>
<head>
<title>Transfer Learning Guide: A Practical Tutorial With Examples for Images and Text in Keras </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>迁移学习指南:带有Keras中图像和文本示例的实用教程</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/transfer-learning-guide-examples-for-images-and-text-in-keras#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/transfer-learning-guide-examples-for-images-and-text-in-keras#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p>在大型数据集上训练一个神经网络可能需要数周时间。幸运的是，由于预训练模型的模型权重，这个时间可以缩短——换句话说，应用<strong>迁移学习</strong>。</p>



<p><a href="https://web.archive.org/web/20230131180149/https://machinelearningmastery.com/transfer-learning-for-deep-learning/" target="_blank" rel="noreferrer noopener nofollow">迁移学习</a>是一种在图像分类任务和自然语言处理任务中起作用的技术。在本文中，您将深入了解:</p>



<ul>
<li>什么是迁移学习，</li>



<li>如何实现迁移学习(在Keras中)，</li>



<li>图像分类的迁移学习，</li>



<li>自然语言处理中的迁移学习</li>
</ul>



<p>那么，让我们开始学习吧！(无意双关…好吧，可能有一点)</p>



<h2 id="transfer-learning-overview">什么是迁移学习？</h2>



<p><a href="https://web.archive.org/web/20230131180149/https://towardsdatascience.com/transfer-learning-from-pre-trained-models-f2393f124751" target="_blank" rel="noreferrer noopener nofollow">迁移学习是利用预训练模型的特征表示</a>，因此您不必从头开始训练新模型。</p>



<p>预训练模型通常在大规模数据集上训练，这些数据集是计算机视觉前沿的标准基准。从模型中获得的权重可以在其他计算机视觉任务中重复使用。</p>



<p>这些模型可以直接用于对新任务进行预测，或者集成到训练新模型的过程中。将预先训练的模型包括在新模型中导致更少的训练时间和更低的泛化误差。</p>



<p>当你有一个小的训练数据集时，迁移学习特别有用。在这种情况下，例如，您可以使用预训练模型的权重来初始化新模型的权重。后面你会看到，迁移学习也可以应用到自然语言处理问题上。</p>


<div class="wp-block-image">
<figure class="aligncenter size-large is-resized"><img decoding="async" src="../Images/22d41e2948cd002d032fa05700cb46ba.png" alt="Transfer learning idea" class="wp-image-40779" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230131180149im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Transfer-learning-idea.jpg?resize=768%2C432&amp;ssl=1"/><figcaption class="wp-element-caption"><em>The idea of transfer learning</em></figcaption></figure></div>


<p>预训练模型的优势在于它们足够通用，可用于其他真实世界的应用程序。例如:</p>



<ul>
<li><strong>在ImageNet上训练的模型</strong>可以用于现实世界的图像分类问题。这是因为数据集包含1000多个类。假设你是一名昆虫研究者。你可以使用这些模型，并对它们进行微调来对昆虫进行分类。</li>



<li>对文本进行分类需要了解一些向量空间中的单词表示。你可以自己训练矢量表示。这里的挑战是，您可能没有足够的数据来训练嵌入。此外，培训需要很长时间。在这种情况下，您可以使用像GloVe这样的预训练单词嵌入来加快您的开发过程。</li>
</ul>



<p>稍后您将探索这些用例。</p>



<h3>迁移学习和微调有什么区别？</h3>



<p><strong>微调</strong>是迁移学习的可选步骤。<a href="https://web.archive.org/web/20230131180149/https://www.researchgate.net/post/What-is-the-difference-between-Transfer-Learning-vs-Fine-Tuning-vs-Learning-from-scratch" target="_blank" rel="noreferrer noopener nofollow">微调通常会提高模型的性能</a>。然而，由于您必须重新训练整个模型，您可能会过度适应。</p>





<p>过度拟合是可以避免的。只需使用<strong>低学习率</strong>重新训练模型或其一部分。这一点很重要，因为它可以防止对渐变进行重大更新。这些更新会导致性能下降。当模型停止改进时，使用回调来停止训练过程也是有帮助的。</p>



<h3>为什么要用迁移学习？</h3>



<p>假设您有100张猫和100只狗的图像，并且想要建立一个模型来对这些图像进行分类。如何使用这个小数据集训练一个模型？您可以从头开始训练您的模型，但它很可能会过度拟合。进入迁移学习。一般来说，你想使用迁移学习有两大原因:</p>



<ul>
<li><strong>高精度的训练模型需要大量的数据</strong>。例如，ImageNet数据集包含超过100万张图像。在现实世界中，你不太可能有这么大的数据集。</li>



<li>假设你有那种数据集，你可能仍然<strong>没有在如此大的数据集上训练模型</strong>所需的资源。因此，如果你没有在大型数据集上训练模型所需的计算资源，迁移学习就很有意义。</li>



<li>即使你有可以支配的计算资源，你仍然需要等待几天或几周来训练这样一个模型。因此，使用预先训练好的模型会节省你的宝贵时间。</li>
</ul>



<h3>迁移学习什么时候不起作用？</h3>



<p>当底层学习的高级特征不足以区分问题中的类别时，迁移学习将不起作用。例如，预先训练的模型可能非常擅长识别门，但不擅长识别门是关闭的还是打开的。在这种情况下，可以使用(预训练网络的)低级特征，而不是高级特征。在这种情况下，您必须重新训练模型的更多层或使用早期层中的特征。</p>



<p>当数据集不相似时，要素传递效果不佳。这篇<a href="https://web.archive.org/web/20230131180149/https://arxiv.org/pdf/1411.1792.pdf" target="_blank" rel="noreferrer noopener nofollow">论文</a>更详细地调查了数据集的相似性。也就是说，如论文中所示，用预先训练的权重初始化网络比使用随机权重会产生更好的性能。</p>



<p>您可能会发现自己处于这样一种情况，即考虑从预先训练的模型中删除一些层。在这种情况下，迁移学习不太可能奏效。这是因为删除层会减少可训练参数的数量，从而导致过度拟合。此外，在不过度拟合的情况下确定要移除的正确层数是一个麻烦且耗时的过程。</p>







<h2 id="transfer-learning-implement">如何实施迁移学习？</h2>



<p>现在，让我们花点时间来看看如何实现迁移学习。</p>



<h3>6步迁移学习</h3>



<p>你可以通过这六个步骤来实现迁移学习。</p>







<p><a href="https://web.archive.org/web/20230131180149/https://www.researchgate.net/profile/Maxime-Leclerc-2/publication/327023348/figure/fig1/AS:684562329919491@1540223786093/Transfer-learning-for-ship-classification-and-tracking-in-five-steps.png"/></p>



<h4>获取预训练模型</h4>



<p>第一步是获得您希望用于解决问题的<a href="https://web.archive.org/web/20230131180149/https://keras.io/api/applications/" target="_blank" rel="noreferrer noopener nofollow">预训练模型</a>。预训练模型的各种来源在单独的部分中介绍。</p>



<h4>创建基础模型</h4>



<p>通常，第一步是使用ResNet或Xception之类的架构实例化<strong>基本模式</strong> l。您也可以选择下载<strong>预训练的重量</strong>。如果您不下载权重，您将不得不使用架构从头开始训练您的模型。回想一下，基本模型在最终输出层中通常会有比您需要的更多的单元。因此，在创建基础模型时，必须移除最终输出层。稍后，您将添加与您的问题兼容的最终输出图层。</p>





<h4>冻结层，使它们在训练过程中不会改变</h4>



<p>冻结预训练模型的层是至关重要的。这是因为您不希望这些层中的<strong>权重被重新初始化</strong>。如果是，那么你将会失去所有已经发生的学习。这将与从头开始训练模型没有什么不同。</p>



<pre class="hljs">base_model.trainable = <span class="hljs-keyword">False</span></pre>





<h4>添加新的可训练层</h4>



<p>下一步是<strong>添加新的可训练层</strong>，这将把旧的特征变成新数据集上的预测。这很重要，因为预训练模型是在没有最终输出层的情况下加载的。</p>





<h4>在数据集上训练新图层</h4>



<p>请记住，预训练模型的最终输出很可能与您想要的模型输出不同。例如，在ImageNet数据集上训练的预训练模型将输出1000个类。然而，您的模型可能只有两个类。在这种情况下，您必须使用新的输出图层来训练模型。</p>



<p>因此，您可以随意添加一些新的密集层，但最重要的是，最终的密集层的<strong>单位与您的模型</strong>预期的输出数量相对应。</p>



<h4>通过微调改进模型</h4>



<p>完成上一步后，您将拥有一个可以对数据集进行预测的模型。可选的，你可以通过微调来提高它的<strong>性能。微调是通过解冻基础模型或其一部分，并以非常低的学习速率在整个数据集上再次训练整个模型来完成的。低学习率将提高模型在新数据集上的性能，同时防止过度拟合。</strong></p>



<p>学习率必须很低，因为模型很大，而数据集很小。这是一个过度适应的处方，因此学习率低。完成这些更改后，请重新编译模型，以便它们能够生效。这是因为每当您调用编译函数时，模型的行为就被冻结了。这意味着每当您想要改变模型的行为时，您都必须再次调用编译函数。下一步将是再次训练模型，同时通过回调来监控它，以确保它不会过度拟合。</p>





<p>很简单，是吧？</p>



<h3>去哪里找预先训练好的模特？</h3>



<p>现在让我们讨论一下在哪里可以找到在应用程序中使用的预训练模型。</p>



<h4>Keras预训练模型</h4>



<p>Keras提供了20多种预先训练好的模型。它们是通过<a href="https://web.archive.org/web/20230131180149/https://keras.io/api/applications/" target="_blank" rel="noreferrer noopener nofollow"> <strong> Keras应用</strong> </a> <strong>送达的。</strong>每个模特旁边都有预先训练好的重量。下载模型时，重量会自动下载。它们将存储在` ~/中。keras/models/`所有的keras应用程序都用于图像任务。例如，下面是如何初始化在ImageNet上训练的MobileNet架构。</p>



<pre class="hljs">model = tf.keras.applications.MobileNet(
    input_shape=<span class="hljs-keyword">None</span>,
    alpha=<span class="hljs-number">1.0</span>,
    depth_multiplier=<span class="hljs-number">1</span>,
    dropout=<span class="hljs-number">0.001</span>,
    include_top=<span class="hljs-keyword">True</span>,
    weights=<span class="hljs-string">"imagenet"</span>,
    input_tensor=<span class="hljs-keyword">None</span>,
    pooling=<span class="hljs-keyword">None</span>,
    classes=<span class="hljs-number">1000</span>,
    classifier_activation=<span class="hljs-string">"softmax"</span>,
)</pre>



<h4>使用TensorFlow Hub进行迁移学习</h4>



<p>值得一提的是，Keras应用程序并不是迁移学习任务的唯一选择。也可以使用来自<a href="https://web.archive.org/web/20230131180149/https://www.tensorflow.org/hub" target="_blank" rel="noreferrer noopener nofollow"> <strong> TensorFlow Hub </strong> </a>的模型。</p>



<pre class="hljs">model = tf.keras.Sequential([
 hub.KerasLayer(<span class="hljs-string">"https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/feature_vector/4"</span>,
                   trainable=<span class="hljs-keyword">False</span>),
    tf.keras.layers.Dense(num_classes, activation=<span class="hljs-string">'softmax'</span>)
])</pre>



<section id="blog-intext-cta-block_6c752cab320181fbdb73d39f786ad698" class="block-blog-intext-cta  c-box c-box--default c-box--dark c-box--no-hover c-box--standard ">

            
    
            <p>了解如何使用<a href="https://web.archive.org/web/20230131180149/https://docs.neptune.ai/integrations-and-supported-tools/model-training/tensorflow-keras" target="_blank" rel="noopener"> Neptune与TensorFlow/Keras的集成来跟踪Keras模型训练</a></p>
    
    </section>



<h4>预训练单词嵌入</h4>



<p><strong>单词嵌入</strong>通常用于文本分类问题。因为你可以训练你的单词嵌入，使用一个预先训练好的会快得多。这里有几个单词嵌入，您可以考虑用于自然语言处理问题:</p>











<h4>拥抱脸</h4>



<p><a href="https://web.archive.org/web/20230131180149/https://github.com/huggingface" target="_blank" rel="noreferrer noopener nofollow"> <strong>抱脸</strong> </a>提供了数千个预先训练好的模型，用于在文本上执行任务。一些受支持的功能包括:</p>



<ul>
<li>问题回答</li>



<li>摘要</li>



<li>翻译和</li>



<li>文本生成，仅举几例</li>
</ul>



<p>拥抱脸支持100多种语言。</p>



<p>这里有一个例子，你可以用拥抱脸来区分否定句和肯定句。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline</pre>



<pre class="hljs">classifier = pipeline(<span class="hljs-string">'sentiment-analysis'</span>)
classifier(<span class="hljs-string">'We are very happy to include pipeline into the transformers repository.'</span>)
[{<span class="hljs-string">'label'</span>: <span class="hljs-string">'POSITIVE'</span>, <span class="hljs-string">'score'</span>: <span class="hljs-number">0.9978193640708923</span>}]</pre>



<h3>如何使用预先训练好的模型</h3>



<p>有三种方法可以使用预训练模型:</p>



<ul>
<li><strong>预测</strong>，</li>



<li><strong>特征提取</strong>，</li>



<li><strong>微调</strong>。</li>
</ul>



<h4>预言；预测；预告</h4>



<p>在这里，你下载模型，并立即使用它来分类新的图像。下面是一个用于分类ImageNet类的ResNet50 的例子。</p>



<p><a href="https://web.archive.org/web/20230131180149/https://en.wikipedia.org/wiki/ImageNet" target="_blank" rel="noreferrer noopener nofollow"> ImageNet </a>是一个广泛的图像集合，用于训练模型，包括ResNet50。该数据集中有超过100万幅图像和1000个类。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> tensorflow.keras.applications.resnet50 <span class="hljs-keyword">import</span> ResNet50
<span class="hljs-keyword">from</span> tensorflow.keras.preprocessing <span class="hljs-keyword">import</span> image
<span class="hljs-keyword">from</span> tensorflow.keras.applications.resnet50 <span class="hljs-keyword">import</span> preprocess_input, decode_predictions
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
model = ResNet50(weights=<span class="hljs-string">'imagenet'</span>)
img_path = <span class="hljs-string">'elephant.jpg'</span>
img = image.load_img(img_path, target_size=(<span class="hljs-number">224</span>, <span class="hljs-number">224</span>))
x = image.img_to_array(img)
x = np.expand_dims(x, axis=<span class="hljs-number">0</span>)
x = preprocess_input(x)
preds = model.predict(x)


print(<span class="hljs-string">'Predicted:'</span>, decode_predictions(preds, top=<span class="hljs-number">3</span>)[<span class="hljs-number">0</span>])
</pre>



<h4>特征抽出</h4>



<p>在这种情况下，最后一层之前的层的输出将作为新模型的输入。目标是使用预先训练的模型或其一部分来预处理图像并获得本质特征。</p>



<p>然后，您将这些特征传递给一个新的分类器——无需重新训练基础模型。预先训练的卷积神经网络已经具有对于手头的任务很重要的特征。</p>





<p>但是，预训练模型的最终部分不会转移，因为它特定于其数据集。因此，您必须构建模型的最后一部分来适应数据集。</p>



<p>在自然语言处理领域，预训练的单词嵌入可以用于<strong>特征提取。</strong>单词嵌入有助于将单词放置在向量空间中的正确位置。它们为模型提供相关信息，因为它们可以将单词放在句子的上下文中。单词嵌入的主要目的是语义理解和单词之间的关系。结果，这些单词嵌入对于自然语言问题是任务不可知的。</p>



<h4>微调</h4>



<p>当你的新分类器准备好时，你可以使用<strong>微调来提高它的精确度</strong>。为了做到这一点，你<strong>解冻分类器</strong>，或者它的一部分，并且用低学习率的新数据重新训练它。如果要使基础模型(从预训练模型中获得)的要素制图表达与您的特定任务更加相关，微调至关重要。</p>



<p>您还可以使用预训练模型中的权重来初始化新模型中的权重。这里的最佳选择取决于你的问题，在你得到正确的答案之前，你可能需要做一些实验。</p>



<p>尽管如此，还是有一个标准的工作流程可以用来应用迁移学习。</p>



<p>我们去看看。</p>



<h2 id="transfer-learning-images">带Keras的图像迁移学习示例</h2>



<p>有了这样的背景，让我们看看如何使用预先训练好的模型来解决图像和文本问题。尽管训练一个模型涉及许多步骤，但重点将放在迁移学习特有的六个步骤上。</p>







<h3>图像数据的迁移学习</h3>



<p>在这幅图中，让我们看看如何使用预训练模型来构建和<strong>微调</strong>图像分类器。让我们假设你是一个宠物爱好者，你想创建一个机器学习模型来对你喜欢的宠物进行分类；猫和狗。不幸的是，你没有足够的数据来做这件事。幸运的是，你熟悉<a href="https://web.archive.org/web/20230131180149/https://www.kaggle.com/c/dogs-vs-cats" target="_blank" rel="noreferrer noopener nofollow"> Kaggle </a>，可以得到一个小数据集。准备就绪后，您现在可以选择一个预先训练好的模型来使用。一旦你选择了你的<a href="https://web.archive.org/web/20230131180149/https://keras.io/api/applications/" target="_blank" rel="noreferrer noopener nofollow">预训练模型</a>，你就可以开始用Keras训练模型了。为了说明，让我们使用在ImageNet数据集上训练的<a href="https://web.archive.org/web/20230131180149/https://keras.io/api/applications/xception/" target="_blank" rel="noreferrer noopener nofollow">异常</a> <a href="https://web.archive.org/web/20230131180149/https://arxiv.org/abs/1610.02357" target="_blank" rel="noreferrer noopener nofollow">架构</a>。</p>



<p>如果您正在编写代码，请一步一步地遵循本节，正确地应用迁移学习。</p>



<h4>获取数据集</h4>



<p>我推荐使用Google Colab，因为你可以获得免费的GPU计算。</p>



<p id="block-c66c3236-70a6-4f05-8c88-6f6d7ca54193">首先，将数据集下载到Colab的虚拟机中。</p>



<pre class="hljs">!wget --no-check-certificate
    https://namespace.co.ke/ml/dataset.zip
    -O /content/catsdogs.zip</pre>



<p>之后，解压缩数据集，并设置训练和验证集的路径。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> zipfile
<span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">'catsdogs.zip'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> zip_ref:
    zip_ref.extractall(<span class="hljs-string">'/content/cats_dogs'</span>)
base_dir = <span class="hljs-string">'/content/cats_dogs/dataset'</span>
train_dir = os.path.join(base_dir, <span class="hljs-string">'training_set'</span>)
validation_dir = os.path.join(base_dir, <span class="hljs-string">'test_set'</span>)</pre>



<h4>从目录中加载数据集</h4>



<p>现在让我们从它们的位置加载图像。可以使用“image_dataset_from_directory”函数，因为它可以推断类标签。</p>



<p>该函数将从目录中创建一个`<a href="https://web.archive.org/web/20230131180149/https://www.tensorflow.org/api_docs/python/tf/data/Dataset" target="_blank" rel="noreferrer noopener nofollow"> tf.data.Dataset </a>`。请注意，要实现这一点，目录结构应该如下所示:</p>



<figure class="wp-block-image"><img decoding="async" src="../Images/2b3061433df7ac8c72791318cd8ba34c.png" alt="" data-original-src="https://web.archive.org/web/20230131180149im_/https://lh6.googleusercontent.com/HtOCgap59oE8SUGoipMH-6xeRrYFbw4XlNW6RLVCZxvYBaHmtPUJyqrYjUrDcSGt5pX1DLaX5f4IqbvABGvQqvo3BihGJTpmXcWQ9MjNJxGLhoiFcnba--gkZQBbykAJjr_yizaP"/></figure>



<p>导入所需的模块并加载培训和验证集。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">from</span> tensorflow <span class="hljs-keyword">import</span> keras
<span class="hljs-keyword">from</span> tensorflow.keras.preprocessing <span class="hljs-keyword">import</span> image_dataset_from_directory
training_set = image_dataset_from_directory(train_dir,
                                             shuffle=<span class="hljs-keyword">True</span>,
                                             batch_size=<span class="hljs-number">32</span>,
                                             image_size=(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>))
val_dataset = image_dataset_from_directory(validation_dir,
                                                  shuffle=<span class="hljs-keyword">True</span>,
                                                  batch_size=<span class="hljs-number">32</span>,
                                                  image_size=(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>))
</pre>



<h4>数据预处理</h4>



<p>虽然数据预处理不是迁移学习中的一个特定步骤，但它是训练机器学习模型的一个重要步骤。因此，让我们对图像进行一些放大。将增强应用于训练集时，可以防止过度拟合，因为增强会将图像的不同方面暴露给模型。</p>



<p>当没有大量数据用于训练时，您尤其希望扩充数据。您可以使用各种转换来扩充它，例如:</p>



<ul>
<li>随机旋转，</li>



<li>水平翻转，</li>



<li>缩放，</li>



<li>剪毛。</li>
</ul>



<p id="block-abfbe774-4b1a-48db-9831-5d38745b301f">您可以在加载数据时应用这些转换。或者，正如你在下面看到的，你可以通过引入独特的层来增加。</p>



<pre class="hljs">data_augmentation = keras.Sequential(
    [       keras.layers.experimental.preprocessing.RandomFlip(<span class="hljs-string">"horizontal"</span>),<br/>   keras.layers.experimental.preprocessing.RandomRotation(<span class="hljs-number">0.1</span>),
    ]
)</pre>



<p>这些层将仅在培训过程中应用。</p>



<p>通过将图层应用到同一张图像，您可以看到上述变换的结果。代码如下:</p>



<pre class="hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> training_set.take(<span class="hljs-number">1</span>):
    plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">12</span>))
    first_image = images[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">12</span>):
        ax = plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, i + <span class="hljs-number">1</span>)
        augmented_image = data_augmentation(
            tf.expand_dims(first_image, <span class="hljs-number">0</span>)
        )
        plt.imshow(augmented_image[<span class="hljs-number">0</span>].numpy().astype(<span class="hljs-string">"int32"</span>))
        plt.axis(<span class="hljs-string">"off"</span>)</pre>



<p>下面是结果的样子(因为图像被打乱了，你可能会得到不同的结果):</p>





<h4>从预训练的异常模型创建基础模型</h4>



<p>让我们用ImageNet 上训练的重量来加载<strong>模型。完成后，就定义了所需的输入形状。</strong></p>



<p><strong> `include_top=False` </strong>表示您对模型的最后一层不感兴趣。因为模型是自下而上可视化的，所以这一层被称为顶层。<strong>排除顶层对于特征提取很重要</strong>。</p>



<pre class="hljs">base_model = keras.applications.Xception(
    weights=<span class="hljs-string">'imagenet'</span>,
    input_shape=(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>, <span class="hljs-number">3</span>),
    include_top=<span class="hljs-keyword">False</span>)  </pre>



<p>接下来，<strong>冻结基础模型层</strong>，这样它们在训练过程中就不会更新。</p>



<p>由于许多预训练模型都有一个“TF . keras . layers . batch normalization”层，因此冻结这些层非常重要。否则，将更新层均值和方差，这将破坏模型已经学习的内容。让我们冻结这种情况下的所有层。</p>



<pre class="hljs">base_model.trainable = <span class="hljs-keyword">False</span></pre>



<h4>创建最终的密集层</h4>



<p>加载模型时，您使用了“include_top=False ”,这意味着不包括预训练模型的最终密集层。现在是时候<strong>为这个模型</strong>定义一个最终输出层了。</p>



<p>让我们从标准化输入图像的大小开始。</p>



<pre class="hljs">inputs = keras.Input(shape=(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>, <span class="hljs-number">3</span>))</pre>



<p>之后，应用数据扩充。</p>



<pre class="hljs">x = data_augmentation(inputs) </pre>



<p>此模型需要范围在(-1，1)而不是(0，1)的数据。所以，你必须处理数据。</p>



<p>幸运的是，大多数预先训练好的模型都提供了这样的功能。</p>



<pre class="hljs">x = tf.keras.applications.xception.preprocess_input(x)</pre>



<p>现在，让我们将模型定义如下:</p>



<ul>
<li>确保<strong>基础模型在推理模式</strong>下运行，以便在微调阶段(设置“training=False ”)不会更新批量标准化层；</li>



<li><strong>使用“GlobalAveragePooling2D ”,将基础模型的特征转换为矢量</strong>;</li>



<li>应用辍学正规化；</li>



<li><strong>添加一个最终的密集层</strong> r(当你使用` include_top=False时，最终的输出层不包括在内，所以你必须自己定义)。</li>
</ul>



<pre class="hljs">x = base_model(x, training=<span class="hljs-keyword">False</span>)
x = keras.layers.GlobalAveragePooling2D()(x)
x = keras.layers.Dropout(<span class="hljs-number">0.2</span>)(x)
outputs = keras.layers.Dense(<span class="hljs-number">1</span>)(x)
model = keras.Model(inputs, outputs)</pre>



<h4>训练模型</h4>



<p>现在可以<strong>训练顶层</strong>了。请注意，由于您使用的是预训练模型，验证准确性从一个已经很高的值开始。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/a3d41a35065d8f0aef68caf1e257a30a.png" alt="Transfer learning epoch" class="wp-image-40807" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230131180149im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Transfer-learning-epoch.png?ssl=1"/></figure>



<pre class="hljs">model.compile(optimizer=<span class="hljs-string">'adam'</span>, loss=tf.keras.losses.BinaryCrossentropy(from_logits=<span class="hljs-keyword">True</span>),metrics=keras.metrics.BinaryAccuracy())
model.fit(training_set, epochs=<span class="hljs-number">20</span>, validation_data=val_dataset)</pre>



<h3>微调模型</h3>



<p>可以通过<strong>解冻基础模型</strong>并以非常低的学习速率重新训练它来改进模型。</p>



<p>您需要监控这一步，因为错误的实现会导致过度拟合。首先，解冻基本模型。</p>



<pre class="hljs">base_model.trainable = <span class="hljs-keyword">True</span></pre>



<p>更新可训练属性后，必须再次编译模型<strong>以实现更改。</strong></p>



<p/>



<pre class="hljs">model.compile(optimizer=keras.optimizers.Adam(<span class="hljs-number">1e-5</span>),
              loss=keras.losses.BinaryCrossentropy(from_logits=<span class="hljs-keyword">True</span>),
              metrics=keras.metrics.BinaryAccuracy())</pre>



<p>为了防止过度拟合，让我们通过回调来监控培训损失。当模型连续五个纪元没有改善时，Keras将停止训练。让我们也用TensorBoard来监控损耗和精度。</p>







<pre class="hljs"><span class="hljs-keyword">from</span> tensorflow.keras.callbacks <span class="hljs-keyword">import</span> EarlyStopping, TensorBoard
rm -rf logs
%load_ext tensorboard
log_folder = <span class="hljs-string">'logs'</span>
callbacks = [
            EarlyStopping(patience = <span class="hljs-number">5</span>),
            TensorBoard(log_dir=log_folder)
            ]</pre>



<p>好了，到了<strong>重新训练模型</strong>的时候了。当它完成时，你会注意到与以前的模型相比有了一点改进。</p>



<pre class="hljs">model.fit(training_set, epochs=<span class="hljs-number">15</span>,validation_data=val_dataset,callbacks=callbacks)</pre>



<p>此时，您已经有了猫狗分类数据集的工作模型。</p>



<p>如果您使用实验平台跟踪它，那么您现在可以保存模型并将其发送到您的模型注册中心。</p>



<h2 id="transfer-learning-nlp">自然语言处理中迁移学习的例子</h2>



<p>在自然语言处理领域，你可以使用<strong>预先训练的单词嵌入来解决文本分类问题</strong>。我们举个例子。</p>



<h3>预训练单词嵌入</h3>



<p>嵌入的一个<strong>字是一个表示文档的密集向量。在向量中，意思相似的单词看起来靠得更近。你可以使用Keras中的嵌入层来学习单词embedding。训练单词嵌入需要很多时间，尤其是在大型数据集上，所以让我们使用已经训练好的单词嵌入。</strong></p>



<p>几个流行的预训练单词嵌入是<a href="https://web.archive.org/web/20230131180149/https://en.wikipedia.org/wiki/Word2vec" target="_blank" rel="noreferrer noopener nofollow"> <strong> Word2vec </strong> </a>和<a href="https://web.archive.org/web/20230131180149/https://nlp.stanford.edu/projects/glove/" target="_blank" rel="noreferrer noopener nofollow"> <strong> GloVe </strong> </a>。</p>





<p>让我们看一个在迁移学习中使用手套单词嵌入的完整例子。</p>



<h3>加载数据集</h3>



<p>本图将使用一个情感分析数据集。在加载它之前，让我们导入这个任务需要的所有模块。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">from</span> tensorflow.keras.preprocessing.text <span class="hljs-keyword">import</span> Tokenizer
<span class="hljs-keyword">from</span> tensorflow.keras.preprocessing.sequence <span class="hljs-keyword">import</span> pad_sequences
<span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Embedding, LSTM, Dense, Bidirectional
<span class="hljs-keyword">from</span> tensorflow.keras.models <span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd</pre>



<p>接下来，下载数据集并使用Pandas加载它。</p>



<pre class="hljs">!wget --no-check-certificate
    https://drive.google.com/uc?id=<span class="hljs-number">13</span>ySLC_ue6Umt9RJYSeM2t-V0kCv<span class="hljs-number">-4</span>C-P -O /tmp/sentiment.csv
    -O /tmp/sentiment.csv
df = pd.read_csv(<span class="hljs-string">'/tmp/sentiment.csv'</span>)</pre>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/b18b5405aca99f3f80228c2f775bd872.png" alt="Text sentiment" class="wp-image-40812" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230131180149im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Text-sentiment.png?ssl=1"/></figure>



<p>目标是<strong>预测上面的情绪</strong>栏。由于这是文本数据，所以必须将其转换为数字形式，因为这是深度学习模型所期望的。</p>



<p>选择特征，然后目标将数据分成训练集和测试集。</p>



<pre class="hljs">X = df[<span class="hljs-string">'text'</span>]
y = df[<span class="hljs-string">'sentiment'</span>]
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split
X_train, X_test , y_train, y_test = train_test_split(X, y , test_size = <span class="hljs-number">0.20</span>)</pre>



<h3>数据预处理</h3>



<p>因为这是文本数据，所以必须对其进行处理，以便为模型做好准备。这不是特定于文本分类中的迁移学习，而是一般的机器学习模型。</p>



<h4>修饰词语</h4>



<p>要将句子转换成数字表示，请使用“Tokenizer”。Tokenizer删除标点符号和特殊字符，并将句子转换为小写。</p>



<p>只需创建一个“tokenizer”实例，并使其适合训练集。你必须定义你想要的词汇量。还定义了一个词外标记来表示测试集中词汇表中找不到的词。</p>



<pre class="hljs">vocab_size = <span class="hljs-number">10000</span>
oov_token = <span class="hljs-string">"&lt;OOV&gt;"</span>
tokenizer = Tokenizer(num_words = vocab_size, oov_token=oov_token)
tokenizer.fit_on_texts(X_train)</pre>



<p>您可以使用单词索引来查看单词是如何映射到数字的。</p>



<pre class="hljs">word_index = tokenizer.word_index</pre>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/c16373bd36ecfb839ddd55d7b8f9b8b5.png" alt="Word index" class="wp-image-40815" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230131180149im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Word-index.png?ssl=1"/></figure>



<p>让我们把单词转换成序列，这样一个完整的数字序列就可以代表每个句子。这是通过使用来自记号赋予器的“texts_to_sequences”完成的。</p>



<pre class="hljs">X_train_sequences = tokenizer.texts_to_sequences(X_train)</pre>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/77be1bffb0983a051005efd343f6b0e8.png" alt="train sequences" class="wp-image-40817" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230131180149im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/train-sequences.png?ssl=1"/></figure>



<p>由于句子的长度不同，序列也将有不同的长度。但是，对于机器学习模型，序列需要具有相等的长度。这可以通过截断较长的句子并用零填充较短的句子来实现。</p>



<p>使用“post”进行填充会在序列末尾添加零。截断类型的“post”将在末尾截断长度超过100的句子。</p>



<pre class="hljs">padding_type=<span class="hljs-string">'post'</span>
truncation_type=<span class="hljs-string">'post'</span>
max_length = <span class="hljs-number">100</span></pre>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/1c2d95ac126477b538814497d88c91e3.png" alt="train padded" class="wp-image-40819" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230131180149im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/train-padded.png?ssl=1"/></figure>



<h3>使用手套嵌入</h3>



<p>现在，这是<strong>特定于自然语言处理</strong>中的迁移学习。首先，让我们下载预先训练好的单词嵌入。</p>



<pre class="hljs">!wget --no-check-certificate
    http://nlp.stanford.edu/data/glove<span class="hljs-number">.6</span>B.zip
    -O /tmp/glove<span class="hljs-number">.6</span>B.zip</pre>



<p>接下来，将它们提取到一个临时文件夹中。</p>



<pre class="hljs"><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">'/tmp/glove.6B.zip'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> zip_ref:
    zip_ref.extractall(<span class="hljs-string">'/tmp/glove'</span>)</pre>



<p>现在，使用这些<a href="https://web.archive.org/web/20230131180149/https://keras.io/examples/nlp/pretrained_word_embeddings/" target="_blank" rel="noreferrer noopener nofollow">单词嵌入</a>到<strong>创建你自己的嵌入层</strong>。加载手套嵌入，并将它们添加到字典中。</p>



<pre class="hljs">embeddings_index = {}
f = open(<span class="hljs-string">'/tmp/glove/glove.6B.100d.txt'</span>)
<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:
    values = line.split()
    word = values[<span class="hljs-number">0</span>]
    coefs = np.asarray(values[<span class="hljs-number">1</span>:], dtype=<span class="hljs-string">'float32'</span>)
    embeddings_index[word] = coefs
f.close()

print(<span class="hljs-string">'Found %s word vectors.'</span> % len(embeddings_index))</pre>



<p>使用此字典为训练集中的每个单词创建嵌入矩阵。为此，使用‘embedding _ index’获得每个单词的嵌入向量。</p>



<pre class="hljs">embedding_matrix = np.zeros((len(word_index) + <span class="hljs-number">1</span>, max_length))
<span class="hljs-keyword">for</span> word, i <span class="hljs-keyword">in</span> word_index.items():
    embedding_vector = embeddings_index.get(word)
    <span class="hljs-keyword">if</span> embedding_vector <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
        
        embedding_matrix[i] = embedding_vector</pre>



<p>如果找不到某个单词，零将表示它。例如，这是单词bakery的嵌入向量。</p>



<pre class="hljs">embeddings_index.get(<span class="hljs-string">"bakery"</span>)</pre>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/48f043c161979ce3522f4a57a1370d93.png" alt="embeddings index" class="wp-image-40823" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230131180149im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/embeddings-index.png?ssl=1"/></figure>



<h3>创建嵌入层</h3>



<p>此时，您可以创建嵌入层。以下是一些需要注意的事项:</p>



<ul>
<li>将“可训练”设置为假是至关重要的，因为你要确保这一层不会被重新训练；</li>



<li><strong>权重被设置为你刚刚创建的嵌入矩阵</strong>；</li>



<li>` len(word_index) + 1 '是加上1的词汇表的大小，因为0被保留用于填充；</li>



<li>“输入长度”是输入序列的长度。</li>
</ul>



<pre class="hljs">embedding_layer = Embedding(len(word_index) + <span class="hljs-number">1</span>,
                            max_length,
                            weights=[embedding_matrix],
                            input_length=max_length,
                            trainable=<span class="hljs-keyword">False</span>)</pre>



<h3>创建模型</h3>



<p>现在，您可以使用这个嵌入层来创建模型。双向LSTMs用于确保信息来回传递。</p>



<pre class="hljs">model = Sequential([
    embedding_layer,
    Bidirectional(LSTM(<span class="hljs-number">150</span>, return_sequences=<span class="hljs-keyword">True</span>)),
    Bidirectional(LSTM(<span class="hljs-number">150</span>)),
    Dense(<span class="hljs-number">6</span>, activation=<span class="hljs-string">'relu'</span>),
   Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">'sigmoid'</span>)
])</pre>



<h3>训练模型</h3>



<p>您现在可以编译和训练模型了。</p>



<pre class="hljs">model.compile(loss=<span class="hljs-string">'binary_crossentropy'</span>,optimizer=<span class="hljs-string">'adam'</span>,metrics=[<span class="hljs-string">'accuracy'</span>])</pre>



<p>当模型训练停止改进时，可以使用早期停止回调来停止训练过程。您可以使用TensorBoard回调来监控模型损失和准确性。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> tensorflow.keras.callbacks <span class="hljs-keyword">import</span> EarlyStopping, TensorBoard</pre>



<pre class="hljs">%load_ext tensorboard
rm -rf logs
log_folder = <span class="hljs-string">'logs'</span>
callbacks = [
            EarlyStopping(patience = <span class="hljs-number">10</span>),
            TensorBoard(log_dir=log_folder)
            ]
num_epochs = <span class="hljs-number">600</span>
history = model.fit(X_train_padded, y_train, epochs=num_epochs, validation_data=(X_test_padded, y_test),callbacks=callbacks)</pre>



<p>使用“评估”功能可以评估模型的性能。</p>



<pre class="hljs">loss, accuracy = model.evaluate(X_test_padded,y_test)
print(<span class="hljs-string">'Test accuracy :'</span>, accuracy)</pre>



<p>不错！您已经使用预先训练的单词嵌入训练并测试了一个自然语言处理模型。</p>



<h2 id="transfer-learning-conclusion">就这些了，伙计们！</h2>



<p>在本文中，您探索了迁移学习，并举例说明了如何使用它来更快地开发模型。你在图像分类和自然语言处理任务中使用了预先训练好的模型。我希望你喜欢它，谢谢你的阅读！</p>



<p>PS。:下面是<a href="https://web.archive.org/web/20230131180149/https://colab.research.google.com/drive/1M9U0rEmSnKkZE9DuD7Ei8gK3-NGZvIdv?usp=sharing" target="_blank" rel="noreferrer noopener nofollow">图像分类Colab </a>和<a href="https://web.archive.org/web/20230131180149/https://colab.research.google.com/drive/1ypzcfS3_tcRxitdi_xHI1VURSE-SErc6?usp=sharing" target="_blank" rel="noreferrer noopener nofollow">自然语言处理Google Colab </a>供大家参考。</p>



<p>如果你想了解更多关于迁移学习的内容，请随意查看其他资源:</p>




        </div>
        
    </div>    
</body>
</html>