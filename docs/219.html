<html>
<head>
<title>Monte Carlo Simulation:  A Hands-On Guide </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>蒙特卡洛模拟:实践指南</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/monte-carlo-simulation#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/monte-carlo-simulation#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p>蒙特卡洛模拟是一系列实验，帮助我们理解当随机变量的干预存在时，不同结果的概率。这是一种可以用来理解<a href="/web/20221203101636/https://neptune.ai/blog/select-model-for-time-series-prediction-task" target="_blank" rel="noreferrer noopener">预测和预测模型</a>中风险和不确定性的影响的技术。</p>



<p>虽然蒙特卡罗方法可以在许多方面进行研究和应用，但我们将重点关注:</p>



<ul><li>蒙特卡罗模拟/方法实际上是什么，以及一些例子和一些实验。</li><li>用蒙特卡罗和推断统计的方法模拟<em>轮盘</em>游戏。</li><li>了解它在赌博之外的应用领域。</li></ul>



<h2 id="why-should-you-learn-about-monte-carlo-simulation">为什么要学习蒙特卡洛模拟？</h2>



<p>蒙特卡罗模拟利用了一种叫做<a href="https://web.archive.org/web/20221203101636/https://machinelearningmastery.com/monte-carlo-sampling-for-probability/" target="_blank" rel="noreferrer noopener nofollow">蒙特卡罗抽样技术</a>的东西，它随机抽样一个概率分布。在本文后面，我们将看到一个基于这种技术的模拟。</p>



<p>蒙特卡洛模拟在商业和金融等领域有着广泛的潜在应用。电信公司用它们来评估不同场景下的网络性能，帮助他们优化网络。分析师用它们来评估一个实体违约的风险，并分析期权等衍生品。保险公司和油井钻探者也使用它们。蒙特卡罗模拟在商业和金融之外有无数的应用，例如气象学、天文学和粒子物理学。[2]</p>



<p>在机器学习中，蒙特卡罗方法为重采样技术提供了基础，如用于估计数量的<em> bootstrap方法</em>，如有限数据集上模型的准确性。</p>



<blockquote class="wp-block-quote"><p>bootstrap方法是一种重采样技术，用于通过替换对数据集进行采样来估计总体的统计数据。</p></blockquote>



<h2 id="some-history-of-monte-carlo-simulation">蒙特卡罗模拟的一些历史</h2>



<p>波兰裔美国数学家Stanislaw Ulam首先被认为研究了蒙特卡罗模拟。在玩单人纸牌游戏时，他想知道赢这场游戏的概率有多大。所以，他花了很多时间去尝试，但是失败了。这是可以理解的，因为纸牌游戏有大量的组合来进行计算，也是手工计算。</p>



<p>为了解决这个问题，他想走实验路线，计算赢的手数/玩的手数。但他已经玩了很多手牌，但都没有赢过，所以他要花好几年才能玩够牌，才能得到一个好的估值。所以他想到了在电脑上模拟游戏，而不是玩所有的手牌。</p>



<p>那时候，接触电脑并不容易，因为周围没有很多机器。因此，尽管他很有影响力，他还是联系了当时很受欢迎的数学家约翰·冯·诺依曼，使用他的ENIAC机器，他们能够模拟单人纸牌游戏。由此，蒙特卡洛模拟诞生了！</p>



<h2 id="what-is-monte-carlo-simulation">蒙特卡洛模拟是什么？</h2>



<p>蒙特卡洛模拟是一种利用<strong>推断统计</strong>原理估算未知量数值的方法。推断统计对应于对样本/随机变量应用统计算法，从样本中抽取，该样本往往表现出与总体(从中抽取)相同的属性。</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img decoding="async" src="../Images/23dbfe4a2047500e055c202a6a20c1b1.png" alt="Monte Carlo Simulation" class="wp-image-35005" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221203101636im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Monte-Carlo-Simulation.jpeg?ssl=1"/><figcaption><em>Source: original image</em></figcaption></figure></div>



<p class="has-text-align-center"/>



<p>在单人纸牌游戏的情况下，人口是所有可能玩的单人纸牌游戏的总体，样本是我们玩的游戏(&gt; 1)。现在，推断统计告诉我们，我们可以根据对样本的统计对总体进行推断。</p>



<p><em>注:推断统计量的陈述只有在样本被随机抽样<strong/>时才成立。</em></p>



<p>推理统计学的一个主要部分是决策。但是要做决定，你必须知道可能发生的结果的组合，以及会有什么样的变化。</p>



<p>让我们举个例子来更好地理解这一点。假设给你一枚硬币，你必须估计如果你把硬币抛一定次数，你会得到多少正面。你有多大把握说所有的空翻都会让你回头？还是第(t+1)次会出现人头？让我们权衡一些可能性，让它变得有趣:</p>



<ul><li>抛了两次硬币。两个都是正面，如果你要预测第三次投掷的结果，你会称重吗？</li><li>如果有100次尝试，都是正面朝上，你会觉得第101次翻转是正面朝上更舒服吗？</li><li>现在，如果100次试验中，有52次是正面朝上呢？你的最佳猜测是52/100吗？</li></ul>



<p>对于t=2次，你不太有信心预测第三个1头，对于t=100，你更有信心预测第101次翻转是头，而所有的都是头，而不是52次翻转是头。</p>



<p>这个的答案是<strong>方差</strong>。对我们估计的信心取决于两件事:</p>



<ul><li>样本的大小(100比2)</li><li>样本的方差(所有头对52头)</li></ul>



<p>随着方差的增大，我们需要更大的样本来获得相同程度的置信度。当几乎一半是正面，一半是反面时，方差很高，但当结果总是<em>正面，</em>方差几乎为0。</p>



<p>现在让我们看看一些基于蒙特卡罗方法的实验。</p>



<h2 id="monte-carlo-simulation-experiments">蒙特卡罗模拟实验</h2>



<p>统计学家和赌徒中最流行的游戏之一是<a href="https://web.archive.org/web/20221203101636/https://en.wikipedia.org/wiki/Roulette"><strong><em/></strong></a>！当然，由于各种不同的原因，我们将通过运行轮盘赌游戏来观看蒙特卡洛模拟。</p>



<p>为了好玩，我们会把它分成三个互相影响的实验:</p>



<ul><li>公平轮盘赌:你的赌注回报的期望值应该是0%。</li><li>欧洲轮盘赌:你的赌注回报的期望值应该是~-2.7%</li><li>美国轮盘赌:你下注回报的期望值应该是~-5.5%。</li></ul>



<h3 id="fair-roulette">公平轮盘赌</h3>



<p>让我们定义一个简单的python类来模拟这个游戏:</p>



<pre class="hljs"><span class="hljs-keyword">import</span> random
random.seed(<span class="hljs-number">0</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairRoulette</span><span class="hljs-params">()</span>:</span>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
       self.pockets = []
       <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">37</span>):
           self.pockets.append(i)
       self.ball = <span class="hljs-keyword">None</span>
       self.pocketOdds = len(self.pockets) - <span class="hljs-number">1</span>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spin</span><span class="hljs-params">(self)</span>:</span>
       self.ball = random.choice(self.pockets)
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">betPocket</span><span class="hljs-params">(self, pocket, amt)</span>:</span>
       <span class="hljs-keyword">if</span> str(pocket) == str(self.ball):
           <span class="hljs-keyword">return</span> amt*self.pocketOdds
       <span class="hljs-keyword">else</span>: <span class="hljs-keyword">return</span> -amt
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
       <span class="hljs-keyword">return</span> <span class="hljs-string">'Fair Roulette'</span>
</pre>



<ul><li>共有36个口袋，编号从1到36</li><li>最初，球是零。轮子旋转，球随机落在其中一个口袋里</li><li>如果球落地的口袋号码与你先前下注的号码相符，你就赢了这场游戏。因此，如果您在开始时下注$1，并且赢了这手牌，那么您最后会得到$36。很神奇，不是吗？</li></ul>



<p>现在是一个把所有指令和规则放在一起的函数:</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">playRoulette</span><span class="hljs-params">(game, numSpins, pocket, bet, toPrint)</span>:</span>
   totalPocket = <span class="hljs-number">0</span>
   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(numSpins):
       game.spin()
       totalPocket += game.betPocket(pocket, bet)
   <span class="hljs-keyword">if</span> toPrint:
       print(f<span class="hljs-string">'{numSpins} spins of {game}'</span>)
       print(f<span class="hljs-string">'Expected return betting {pocket} = {str(100*totalPocket/numSpins)}% n'</span>)
   <span class="hljs-keyword">return</span> (totalPocket/numSpins)
</pre>



<p>代码基本上是不言自明的。<em> totalPocket </em>是一个变量，保存您赢/输的钱的总和。<em> numSpins </em>是你下注或旋转轮盘的次数。</p>



<p>现在让我们运行100次和100万次旋转。</p>



<pre class="hljs">game = FairRoulette()
<span class="hljs-keyword">for</span> numSpins <span class="hljs-keyword">in</span> (<span class="hljs-number">100</span>, <span class="hljs-number">1000000</span>):
   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):
       playRoulette(game, numSpins, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">True</span>)
</pre>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/04a8fad74d1e71cb913d30aee15c3281.png" alt="Fair rulette results " class="wp-image-35006" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221203101636im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Fair-rulette-results.png?ssl=1"/></figure>



<p>你可以在上图中看到</p>



<ul><li>对于100次旋转，你得到了44%的正回报，然后是负28%，再次是正44%，方差高得多，但当你看到更大的图片时，事情变得有趣了。</li><li>对于一百万次旋转，回报总是在平均值0附近徘徊，这就是我们开始时的情况。方差很低。</li></ul>



<p>人们一定想知道为什么要为一百万次旋转而烦恼？赌徒可能不会，但赌场肯定会。对于一个赌徒来说，更难预测他那天会赢或输多少，因为他在那天可以玩100场游戏。但是，一个赌场必须在数千名赌徒参与数千万手牌的情况下运营数年。</p>



<p>所以这个实验进行的就是所谓的<strong>大数定律</strong>。根据大数定律:</p>



<p>从大量试验中获得的结果的平均值应该接近预期值，并且随着进行更多的试验，将趋向于变得更接近预期值。</p>



<p>这意味着，如果我们旋转轮盘赌轮盘无限次，预期回报将为零。所以当旋转一百万次比一百次时，我们得到的结果更接近于零。</p>



<p>让我们现在运行欧洲和美国轮盘赌。你看，赌场是不公平的。毕竟，他们必须坚持“房子总是赢家！”。在欧洲轮盘赌的情况下，他们在轮盘上加上一个绿色的“0 ”,而在美国轮盘赌中，他们偷偷加上另一个绿色的“00 ”,使得赌徒更难获胜。</p>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img decoding="async" loading="lazy" src="../Images/1e5a9239bbac73f6d4dd722dde4f399d.png" alt="European American rulette" class="wp-image-35008" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221203101636im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/European-American-rulette-1.jpg?resize=750%2C422&amp;ssl=1"/><figcaption><em>American roulette vs European roulette | <a href="https://web.archive.org/web/20221203101636/https://casinochecking.com/blog/american-and-european-roulette-wheel/" target="_blank" rel="noreferrer noopener nofollow">Source</a></em></figcaption></figure></div>



<p>让我们模拟两者，并将其与公平轮盘模拟进行比较。</p>



<pre class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EuRoulette</span><span class="hljs-params">(FairRoulette)</span>:</span>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
       FairRoulette.__init__(self)
       self.pockets.append(<span class="hljs-string">'0'</span>)
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
       <span class="hljs-keyword">return</span> <span class="hljs-string">'European Roulette'</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmRoulette</span><span class="hljs-params">(EuRoulette)</span>:</span>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
       EuRoulette.__init__(self)
       self.pockets.append(<span class="hljs-string">'00'</span>)
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
       <span class="hljs-keyword">return</span> <span class="hljs-string">'American Roulette'</span>
</pre>



<p>我们只是继承了FairRoulette类，因为我们添加了额外的口袋，功能和属性保持不变。现在运行试验并保存回报的函数:</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findPocketReturn</span><span class="hljs-params">(game, numTrials, trialSize, toPrint)</span>:</span>
   pocketReturns = []
   <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> range(numTrials):
       trialVals = playRoulette(game, trialSize, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, toPrint)
       pocketReturns.append(trialVals)
   <span class="hljs-keyword">return</span> pocketReturns
</pre>



<p>为了进行比较，我们转动三个转盘，看每个转盘20次试验的平均回报。</p>



<pre class="hljs">numTrials = <span class="hljs-number">20</span>
resultDict = {}
games = (FairRoulette, EuRoulette, AmRoulette)
<span class="hljs-keyword">for</span> G <span class="hljs-keyword">in</span> games:
   resultDict[G().__str__()] = []
<span class="hljs-keyword">for</span> numSpins <span class="hljs-keyword">in</span> (<span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">1000000</span>):
   print(f<span class="hljs-string">'nSimulate, {numTrials} trials of {numSpins} spins each'</span>)
   <span class="hljs-keyword">for</span> G <span class="hljs-keyword">in</span> games:
       pocketReturns = findPocketReturn(G(), numTrials,
                                        numSpins, <span class="hljs-keyword">False</span>)
       expReturn = <span class="hljs-number">100</span>*sum(pocketReturns)/len(pocketReturns)
       print(f<span class="hljs-string">'Exp. return for {G()} = {str(round(expReturn, 4))}%'</span>)
</pre>



<p>运行上面的摘录会得到这样的结果:</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/f39d0562513ddef3a1dc6ec66519f4c8.png" alt="Fair rulette results " class="wp-image-35007" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221203101636im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Fair-rulette-results-2-1.png?ssl=1"/></figure>



<p>你可以在这里看到，当我们接近无穷大时，每场比赛的回报越来越接近他们的期望值。因此，如果你做多，你很可能在欧洲损失3%,在美国损失5%。告诉过你，赌场是稳赚不赔的生意。</p>



<p>注意:无论何时你随机抽样，你都不能保证得到完美的准确性。总是有可能得到奇怪的样本，这也是我们平均进行20次试验的原因之一。</p>



<h2 id="you-ve-reached-the-end">你已经到达终点了！</h2>



<p>您现在了解了什么是蒙特卡罗模拟以及如何进行模拟。我们只举了轮盘赌的例子，但是你可以在其他的机会游戏上做实验。访问笔记本<a href="https://web.archive.org/web/20221203101636/https://ui.neptune.ai/theaayushbajaj/Monte-Carlo-Simulation/n/dc2921fe-02b3-4bbb-89db-f6f9bf85e0d5/a2dd4d99-431f-494a-b133-883ca654a744" target="_blank" rel="noreferrer noopener">这里</a>在这个博客中找到完整的代码和我们为你做的一个额外的实验！</p>



<p>以下是您可能想关注的一些其他研究资源:</p>



<ul><li>如果你想探索蒙特卡罗模拟如何应用于技术系统，那么这本书是一个很好的起点。</li><li>关于随机思维的进一步阅读，你可以在这里看到讲座<a href="https://web.archive.org/web/20221203101636/https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-0002-introduction-to-computational-thinking-and-data-science-fall-2016/lecture-videos/" target="_blank" rel="noreferrer noopener nofollow">。</a></li><li>如果你想深入分析，你可以在这里查看一些与蒙特卡罗模拟和方法<a href="https://web.archive.org/web/20221203101636/https://arxiv-sanity-lite.com/?q=monte+carlo+simulation&amp;rank=time&amp;tags=&amp;pid=&amp;time_filter=&amp;svm_c=0.01&amp;skip_have=no" target="_blank" rel="noreferrer noopener nofollow">相关的最新研究。</a></li></ul>



<h3 id="references">参考</h3>



<ol><li><a href="https://web.archive.org/web/20221203101636/https://www.youtube.com/watch?v=OgO1gpXSUzU&amp;t=1939s" target="_blank" rel="noreferrer noopener nofollow">蒙特卡洛模拟</a></li><li><a href="https://web.archive.org/web/20221203101636/https://www.investopedia.com/terms/m/montecarlosimulation.asp" target="_blank" rel="noreferrer noopener nofollow">https://www . investopedia . com/terms/m/montecallosimulation . ASP</a></li><li><a href="https://web.archive.org/web/20221203101636/https://en.wikipedia.org/wiki/Monte_Carlo_method" target="_blank" rel="noreferrer noopener nofollow">https://en.wikipedia.org/wiki/Monte_Carlo_method</a></li></ol>
        </div>
        
    </div>    
</body>
</html>