<html>
<head>
<title>MLOps Is an Extension of DevOps. Not a Fork — My Thoughts on THE MLOPS Paper as an MLOps Startup CEO </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>MLOps是DevOps的扩展。不是叉子——作为MLOps初创公司CEO，我对MLOPS论文的看法</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/mlops-is-extension-of-devops#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/mlops-is-extension-of-devops#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p id="7864">到现在为止，每个人都应该已经看到了MLOps文件。</p>



<p id="2043"><a href="https://web.archive.org/web/20230307061328/https://arxiv.org/pdf/2205.02302.pdf" target="_blank" rel="noreferrer noopener nofollow">“机器学习操作(MLOps):概述、定义和架构”</a></p>



<p id="8067">由dominik kreuzberger，niklas kühl，sebastian hirschl主持</p>



<p id="7818">很棒的东西。如果你还没有读过，一定要读。</p>



<p id="5d21">作者对以下内容进行了全面概述:</p>



<ul>
<li>什么是MLOps，</li>



<li>MLOps生态系统的原理和组成部分，</li>



<li>参与执行MLOps的人员/角色，</li>



<li>许多团队都有的MLOps架构和工作流。</li>
</ul>



<p id="5ca7">他们解决了规范MLOps运动中的丑陋问题:所有这些MLOps堆栈组件实际上是如何相互关联并一起工作的？</p>



<p id="9f5c">在这篇文章中，我分享了我们作为MLOps工具公司的现实以及我个人对MLOps的看法。我今天将在这里谈论的许多事情我已经看到了。有些是我3-4年的赌注。</p>



<p id="f49f">你要知道我从哪里来:</p>



<ul>
<li>我有丰富的软件开发背景(15年以上的软件工作经验)。经历了德沃普斯革命。从软件来到ML。</li>



<li>创建了两家成功的软件服务公司。</li>



<li>创建了<a href="/web/20230307061328/https://neptune.ai/" target="_blank" rel="noreferrer noopener"> neptune.ai </a>，一个用于<a href="/web/20230307061328/https://neptune.ai/blog/ml-metadata-store" target="_blank" rel="noreferrer noopener"> ML元数据存储</a>的模块化MLOps组件，又名“实验跟踪器+模型注册表”。</li>



<li>我领导产品，观察这个市场角落的用户、客户和其他供应商在做什么。</li>



<li>我们的大多数客户都在以合理的规模进行ML/MLOps，而不是大型高科技FAANG公司的超大规模。</li>
</ul>



<p id="4ff6">如果你想要一个<strong> TLDR，</strong>这里就是:</p>



<ul>
<li>MLOps是DevOps的扩展。不是分叉:<br/>–MLOps团队应该由开发运维工程师、后端软件工程师、数据科学家+普通软件人员组成。我看不出ML和MLOps的工程师在这里会起什么特殊作用。<br/>—我们应该围绕CI/CD建立特定于ML的反馈循环(审核、批准)。</li>



<li>我们需要自动持续监控和定期人工检查。</li>



<li>将只有一种类型的ML元数据存储(模型优先)，而不是三种。</li>



<li>工作流编排组件实际上是两件事，工作流执行工具和管道创作框架。</li>



<li>我们不需要模型注册中心。如果有的话，它应该是一个工件库的插件。</li>



<li>模型监控工具将与DevOps监控堆栈合并。可能比你想象的要快。</li>
</ul>



<p id="e550">好吧，我来解释一下。</p>



<h2 id="h-mlops-is-an-extension-of-devops-not-a-fork">MLOps是DevOps的扩展。不是叉子。</h2>



<p id="7ff7">首先，谈论MLOps和MLOps堆栈组件很好，但归根结底，我们都只是在这里交付软件。</p>



<p id="8751">一种特殊类型的软件，里面有ML，但仍然是软件。</p>



<p id="eab3">我们应该考虑如何连接到现有的和成熟的DevOps实践、堆栈和团队。但是我们在MLOps中做的很多事情都是构建DevOps中已经存在的东西，并在它们上面打上MLOps的印记。</p>


<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" src="../Images/296c0a55b0a254d1486d7ef3094dece6.png" alt="MLOps Extension of DevOps " class="wp-image-15806" srcset="https://web.archive.org/web/20230307061328im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2023/01/MLOps-Extension-of-DevOps-1.jpeg?w=700&amp;ssl=1 700w, https://web.archive.org/web/20230307061328im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2023/01/MLOps-Extension-of-DevOps-1.jpeg?resize=200%2C104&amp;ssl=1 200w, https://web.archive.org/web/20230307061328im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2023/01/MLOps-Extension-of-DevOps-1.jpeg?resize=220%2C115&amp;ssl=1 220w, https://web.archive.org/web/20230307061328im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2023/01/MLOps-Extension-of-DevOps-1.jpeg?resize=120%2C63&amp;ssl=1 120w, https://web.archive.org/web/20230307061328im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2023/01/MLOps-Extension-of-DevOps-1.jpeg?resize=160%2C83&amp;ssl=1 160w, https://web.archive.org/web/20230307061328im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2023/01/MLOps-Extension-of-DevOps-1.jpeg?resize=300%2C156&amp;ssl=1 300w, https://web.archive.org/web/20230307061328im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2023/01/MLOps-Extension-of-DevOps-1.jpeg?resize=480%2C250&amp;ssl=1 480w" sizes="(max-width: 700px) 100vw, 700px" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230307061328im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2023/01/MLOps-Extension-of-DevOps-1.jpeg?resize=700%2C365&amp;ssl=1"/><figcaption class="wp-element-caption"><em>MLOps is an extension of DevOps</em></figcaption></figure></div>


<p id="1d97">当公司将ML模型添加到他们的产品/服务中时，某些东西已经存在了。</p>



<p id="49be">那就是常规的软件交付过程和DevOps工具堆栈。</p>



<p id="4a68">事实上，几乎没有人是从零开始的。</p>



<p id="2fd1">最后，我认为MLOps和DevOps堆栈不会彼此相邻，而不仅仅是一个堆栈。</p>



<p id="b5fc">我的意思是，如果你同意我说的“ML只是一种特殊类型的软件”，MLOps只是一种特殊类型的DevOps。</p>



<p id="f3d2">因此，弄清楚MLOps架构和原则是很重要的，但我想知道这与扩展现有的DevOps原则、流程和工具堆栈有什么联系。</p>



<h2 id="h-production-ml-team-composition">生产ML团队组成</h2>



<p id="abc3">让我们把这个“MLOps是DevOps的扩展”的讨论带到团队结构中来。</p>



<p id="d7b4">我们需要谁来构建可靠的ML驱动的软件产品？</p>



<ul>
<li>负责软件交付可靠性的人🙂</li>



<li>我们正在开发产品，因此产品和最终用户之间需要有明确的联系。</li>



<li>我们需要构建产品的ML特定部分的人。</li>



<li>我们需要构建产品的非ML特定部分的人。</li>
</ul>



<p id="5005">很好，现在，那些人到底是谁？</p>



<p id="ab5e">我相信这个团队会是这样的:</p>



<ul>
<li>软件交付可靠性:DevOps工程师和sre(<a href="https://web.archive.org/web/20230307061328/https://www.trendmicro.com/en_gb/devops/22/f/devops-vs-sre.html?gclid=CjwKCAjw6fyXBhBgEiwAhhiZsjKUK1GJB8Rrvi1_uTnb3VuAzWk6tORlQTBJEX879swdi1vNergzKBoC8O4QAvD_BwE" target="_blank" rel="noreferrer noopener nofollow">devo PS vs SRE这里</a>)</li>



<li>特定于ML的软件:软件工程师和数据科学家</li>



<li>非特定ML软件:软件工程师</li>



<li>产品:产品人员和主题专家</li>
</ul>



<p id="619b">等等，军事行动工程师在哪里？</p>



<p id="4d17">ML工程师怎么样？</p>



<p id="1e24">让我解释一下。</p>



<h3>MLOps工程师只是DevOps工程师</h3>



<p id="9b6d">这可能有点极端，但我没有在这个团队中看到任何特殊的MLOps工程师角色。</p>



<p id="9a96">今天的MLOps工程师要么是ML工程师(构建特定于ML的软件)，要么是DevOps工程师。这里没什么特别的。</p>



<p id="c031">我们应该称一个主要操作ML驱动的软件交付的DevOps工程师为MLOps工程师吗？</p>



<p id="5387">我的意思是，如果你真的想，我们可以，但我不认为我们需要一个新的角色。这只是一个DevOps工程。</p>



<p id="a595">不管怎样，我们肯定需要这个人在团队里。</p>



<p id="3e4e">现在，让我感兴趣的是这里。</p>



<h3>数据科学家vs ML工程师vs后端软件工程师</h3>



<p id="1be7">首先，数据科学家、ML工程师、软件工程师和ML研究员之间的实际区别是什么？</p>



<p id="f94f">今天我是这样看的。</p>





<p id="b84a">总的来说，ML研究人员非常重视特定于ML的知识，而不太擅长软件开发。</p>



<p id="f21c">软件工程师擅长软件，不太擅长ML。</p>



<p id="0ef2">数据科学家和ML工程师介于两者之间。</p>



<p id="5127">但那是今天，甚至可能是昨天。</p>



<p id="06d8">有几个因素会很快改变这种情况:</p>



<ul>
<li>业务需求</li>



<li>ML教育的成熟</li>
</ul>



<p id="267f">先说<em> </em> <strong>业务需求</strong>。</p>



<p id="8447">产品公司内部部署的大多数ML模型将不会是尖端的，超级重在调整。</p>



<p id="0a61">他们不需要最先进的模型压缩技术来降低延迟或类似的调整。它们将是在该组织拥有的特定数据集上训练的一般模型。</p>



<p id="6919">这意味着数据科学家和ML研究人员对超级定制模型开发的需求将不会像构建包装和部署一般模型那样普遍。</p>



<p id="ca1e">肯定会有需要大量工作的团队。只是市场的大多数不会。尤其是那些基线模型变得如此之好。</p>



<p id="7ff6">好的，所以我们将更需要人工智能工程师而不是数据科学家，对吗？</p>



<p id="90cb">没那么快。</p>



<p id="cf1d">再说说<strong>计算机科学教育。</strong></p>



<p id="9530">我学CS的时候有一学期的ML。今天，在同一个程序中，ML内容增加了4倍以上。</p>



<p id="7af1">我相信包装/构建/部署普通的ML模型将成为后端开发人员的常识。</p>



<p id="3a54">即使在今天，如果需要的话，大多数后端软件工程师也可以很容易地学习足够的ML来做这件事。</p>



<p id="d057">再说一次，不要谈论那些棘手的训练，重在调整模型。我说的是好的基线模型。</p>



<p id="7756">所以考虑到:</p>



<ul>
<li>基线模型会变得更好</li>



<li>经典CS项目中的ML教育将会改善</li>



<li>需要大量ML调整的业务问题将不再常见</li>
</ul>



<p id="ddb3">我相信ML团队目前的角色将会发生变化:</p>



<ul>
<li>ML重要角色-&gt;数据科学家</li>



<li>软件重要角色-&gt;后端软件工程师</li>
</ul>





<p id="e8a7">那么谁应该处理产品的ML特定部分呢？</p>



<p id="df15">我相信你永远都需要大量数据科学家和大量软件后端工程师。</p>



<p id="3612">后端软件工程师将打包这些模型，并将其“发布”到由DevOps工程师运营的生产管道中。</p>



<p id="701d">当商业问题是ML-heavy时，数据科学家将建立模型。</p>



<p id="52ec">但是，即使问题不严重，你也需要数据科学家，后端软件工程师可以很容易地部署一般的模型。</p>



<p id="633c">为什么？</p>



<p id="5535">因为模型失败了。</p>



<p id="5cf6">当它们失败时，很难调试它们并理解根本原因。</p>



<p id="43da">真正理解模型的人是大量数据科学家。</p>



<p id="7cb8">但是，即使ML模型部分“如预期的那样”工作，ML燃料的产品也可能失败。</p>



<p id="2b52">这就是为什么你也需要密切参与交付ML驱动的软件产品的主题专家。</p>



<h3>主题专家</h3>



<p id="a3d3">好的产品交付需要频繁的反馈循环。有些反馈循环可以自动化，但有些不能。</p>



<p id="4323">尤其是在ML。尤其是在没有您或主题专家查看结果的情况下，您无法真正评估您的模型的时候。</p>



<p id="0772">这些主题专家(SME)参与MLOps流程的次数似乎比您想象的要多。</p>



<p id="27cf">我们看到时装设计师注册了我们的ML元数据商店。</p>



<p id="7e00">什么？这是一个很大的惊喜，所以我们看了看。</p>



<p id="7356">结果是<strong>团队非常希望中小型企业参与手工评估/测试。</strong></p>



<p id="d2f3">尤其是AI-first产品公司的团队希望他们的中小企业参与模型开发。</p>



<p id="057f">这是好事。</p>



<p id="c0c3">并非所有东西都可以用AUC或R2这样的指标来测试/评估。有时，人们只需要检查事情是否有所改善，而不仅仅是指标变好了。</p>



<p id="9a6a">这种人在回路的MLOps系统实际上在我们的用户中相当普遍:</p>







<p id="1304">所以这种人在回路中的设计使得真正的自动化变得不可能，对吗？</p>



<p id="432c">很糟糕，对吧？</p>



<p id="4340">乍一看似乎有问题，但这种情况在正规软件中是完全正常和常见的。</p>



<p id="a716">我们有质量保证(QA)或用户研究人员手动测试和调试问题。</p>



<p id="bb47">这发生在自动化测试之上。所以不是“非此即彼”，而是“兼而有之”。</p>



<p id="12db">但是SME肯定存在于(手动)MLOps反馈回路中。</p>



<h2 id="h-principles-and-components-what-is-the-diff-vs-devops">原理和组件:与DevOps的区别是什么</h2>



<p id="8c9c">我真的很喜欢MLOps论文作者做的一些事情。</p>



<p id="5c64">他们从研究MLOps的原理开始。不仅仅是工具，还有原则。您希望通过使用工具、流程或任何其他解决方案来完成的事情。</p>



<p id="773f">它们进入以后解决不同问题的组件(工具)。</p>



<p id="8d8b">太多时候，这是完全相反的，讨论是由工具做什么来决定的。或者更具体地说，这些工具今天声称要做什么。</p>



<p>工具是暂时的。原则是永恒的。可以这么说。</p>



<p id="2804">在我看来，一些关键的<a href="https://web.archive.org/web/20230307061328/https://neptune.ai/blog/mlops-principles" target="_blank" rel="noreferrer noopener"> MLOps原则</a>缺失了，而其他一些原则应该以不同的方式“打包”。</p>



<p id="f0c6">更重要的是，其中一些东西不是“真正的MLOps ”,而实际上只是DevOps的东西。</p>



<p id="202f">我认为作为MLOps工具的构建者和用户社区，我们应该考虑“真正的MLOps”的原则和组件。扩展现有DevOps基础设施的东西。</p>



<p id="ee3f">这是我们为当前环境增加的价值。而不是重新发明轮子并贴上MLOps的标签。</p>



<p id="d4ec">所以，让我们开始吧。</p>



<h3>原则</h3>



<p id="24c2">因此，CI/CD、版本控制、协作、可再现性和持续监控是DevOps中也有的东西。我们在ML中做的许多事情实际上都属于这些。</p>



<p id="beba">让我们深入这些细微差别。</p>



<h4>CI/CD + CT/CE +反馈回路</h4>



<p id="aab7">如果我们说MLOps只是DevOps +“一些东西”，那么CI/CD就是其中的一个核心原则。</p>



<p id="8a8b">使用CI/CD，您可以获得自动触发的测试、批准、审查、反馈循环等等。</p>



<p id="5b1b">随着MLOps而来的是CT(持续培训/测试)和CE(持续评估)，它们对于一个干净的MLOps过程是必不可少的。</p>



<p id="09d5">它们是独立的原则吗？</p>



<p id="663d">不，它们是同一原则的一部分。</p>



<p id="a505">使用CI/CD，您希望以自动化或半自动的方式构建、测试、集成和部署软件。</p>



<p id="f490">训练ML模型不就是搭建吗？</p>



<p id="8b52">评估/测试只是测试？</p>



<p id="1421">它有什么特别之处？</p>



<p id="1434">也许是对新型号的人工检查。</p>



<p id="8f81">这感觉非常像通过查看差异和检查(通常)自动化测试是否通过来审查和批准一个拉请求。</p>



<p id="181b">不仅代码之间有区别，模型/数据集/结果之间也有区别。但还是有区别。</p>



<p id="37f0">然后你批准，它就投入生产了。</p>



<p id="8cbe">我真的不明白为什么CT/CE不仅仅是CI/CD的一部分。如果不在命名，那么至少在把它们放在一起作为一个原则。</p>



<p id="cc01">通过CI/CD的审查和批准机制非常有效。</p>



<p id="3e1f">我们不应该在MLOps工具中构建全新的模型批准机制。</p>



<p id="dc83">我们应该将CI/CD整合到尽可能多的反馈回路中。就像人们在常规软件开发中做QA和测试一样。</p>



<h4>工作流程编排和管道创作</h4>



<p id="1925">当我们谈到ML中的工作流编排时，我们通常会混淆两件事。</p>



<p id="bc29">一个是调度、执行、重试和缓存。我们为确保ML管道正确执行所做的事情。这是一个经典的DevOps用例。没什么新鲜的。</p>



<p id="21cc">但是这里有一些特别的东西:<strong>轻松创建ML管道的能力。</strong></p>



<p id="ec8a">管道创作？</p>



<p id="b0a0">没错。</p>



<p id="9098">当使用Kedro 创建<a href="https://web.archive.org/web/20230307061328/https://docs.neptune.ai/integrations/kedro/" rel="noreferrer noopener" target="_blank">集成时，我们了解了这种区别。</a></p>



<p id="553d"><a href="https://web.archive.org/web/20230307061328/https://kedro.readthedocs.io/en/stable/faq/faq.html#how-does-kedro-compare-to-other-projects" target="_blank" rel="noreferrer noopener nofollow"> Kedro明确声明</a>它们是一个“管道创作”的框架，而不是工作流编排。他们说:</p>



<p id="9c77">“我们关注的是另一个问题，即创作管道的过程，而不是运行、调度和监控管道。”</p>



<p id="d71a">您可以使用不同的后端运行器(如Airflow、Kubeflow、Argo、Prefect)，但您可以在一个框架中创作它们。</p>







<p id="9a86"><strong> Pipeline authoring是orchestrators </strong>之上的开发者体验(DevEx)层，满足数据科学用例的需求。这使得在这些管道上的合作更加容易。</p>



<p id="9bdc">不同团队之间的协作和管道的可重用性正是Kedro成立的原因。</p>



<p id="4f4f">如果你想要ML管道的可重用性，你需要解决可复制性。毕竟，如果您使用相同的输入重新使用模型训练管道，您会得到相同的结果。</p>



<h4>版本控制与ML元数据跟踪/记录</h4>



<p id="80ea">这不是两个独立的原则，实际上是一个原则的一部分。</p>



<p id="a414">我们已经花了数千个小时与用户/客户/潜在客户谈论这些东西。</p>



<p id="279f">你知道我们学到了什么吗？</p>



<p id="27f6">模型、结果和ML元数据的版本化、日志、记录和跟踪是紧密相连的。</p>



<p id="ab4b">我不认为我们确切地知道一个在哪里结束，另一个在哪里开始，更不用说我们的用户了。</p>



<p id="c4ae">他们经常交替使用版本控制和跟踪。</p>



<p id="0a0c">这是有意义的，因为您希望对模型及其附带的所有元数据进行版本化。包括模型/实验历史。</p>



<p id="3911">你想知道:</p>



<ul>
<li>模型是如何建立的，</li>



<li>结果如何，</li>



<li>使用了什么数据，</li>



<li>训练过程是什么样的，</li>



<li>它是如何被评估的，</li>



<li>等等。</li>
</ul>



<p id="3de1">只有这样，你才能谈论再现性和可追溯性。</p>



<p id="4db0">所以在ML中，我们需要这种“版本控制+”，它基本上不仅仅是模型工件的版本控制，而是围绕它的一切(元数据)。</p>



<p id="af60">因此，也许“版本控制”的原则应该只是一个更广泛的“ML版本控制”或“版本控制+”，其中也包括跟踪/记录。</p>



<h4>模型调试、检查和比较(缺失)</h4>



<p id="67c6">ML模型、实验和流水线执行运行的<strong>“调试、检查和比较”</strong>是MLOps论文中缺失的原则。</p>



<p id="3c7a">作者们谈到了版本控制、跟踪和监控，但是我们看到人们想要但没有提到的一个原则是:</p>



<p id="a079">迄今为止，ML中的很多东西都没有实现自动化。它们是手动或半手动的。</p>



<p id="2ed4">理论上，您可以自动优化每个模型的超参数到无穷大，但实际上，您是根据结果探索来调整模型配置。</p>



<p id="dcda">当模型在生产中失败的时候，你不能马上从日志中知道发生了什么(大多数时候)。</p>



<p id="d578">您需要查看、检查、调试和比较模型版本。</p>



<p id="6198">显然，在模型开发过程中，您会进行大量实验，然后比较模型是关键。</p>



<p id="79be">但是，当这些手工构建的模型遇到再培训渠道时，会发生什么呢？</p>



<p id="497d">您仍然需要将in-prod自动重新训练的模型与初始的手动构建的模型进行比较。</p>



<p id="c39c">尤其是当事情没有按计划进行，新的模型版本实际上并不比旧的版本更好的时候。</p>



<p id="5f6d">并且那些比较和检查是手动的。</p>



<h4>自动持续监控(+手动定期检查)</h4>



<p id="6e7e">所以我完全支持自动化。</p>



<p id="f2d1">自动化平凡的任务。自动化单元测试。自动化健康检查。</p>



<p id="da5f">当我们谈到持续监控时，它基本上是各种ML健康检查的自动监控。</p>



<p id="681b">在此之前，您需要回答两个问题:</p>



<ul>
<li>你知道什么会出错，你能为此建立健康检查吗？</li>



<li>你真的有必要进行这些健康检查吗？</li>
</ul>



<p id="f0f0">是的，许多团队并不真正需要生产模型监控。</p>



<p id="d446">我的意思是，你可以每周手动检查一次。找到你不知道自己存在的问题。更熟悉你的问题。</p>



<p id="9312">正如Shreya Shankar在她的“读博一年后对ML工程的思考”中所分享的那样，你可能不需要模型监控。只是定期重新训练你的模型。</p>



<blockquote class="wp-block-quote">
<p id="0dc9">“研究人员认为分布转移非常重要，但源于自然分布转移的模型性能问题会随着再培训而突然消失。”史瑞亚·尚卡尔</p>
</blockquote>



<p id="9cb5">你可以用cron作业来做。通过这种脏活产生的商业价值可能是你购买的工具的10倍。</p>



<p id="356f">好吧，但是有些队伍确实需要，百分百需要。</p>



<p id="92de">这些团队应该为他们知道可能出错的任何东西建立连续的监控、测试和健康检查。</p>



<p id="1c25">但是即使这样，你也需要不时地手工检查/调试/比较你的模型。</p>



<p id="39c0">捕捉你对自己的ML系统不了解的新事物。</p>



<p id="dd9a">没有度量标准可以捕捉的无声的错误。</p>



<p id="0a7d">我想这是一个很长的说法:</p>



<p id="f88d">您不仅需要持续监控，还需要人工定期检查。</p>



<h4>数据管理</h4>



<p id="bfc3">ML中的数据管理不仅仅是版本控制，而是一个重要的、大得多的过程。</p>



<p id="5374">您可以对数据集进行数据标记、检查、探索、比较、供应和协作。</p>



<p id="3400">尤其是现在，当以数据为中心的MLOps(迭代数据集比迭代模型配置更重要)的思想在ML社区获得如此多的关注时。</p>



<p id="34c0">此外，根据您的生产数据变化的速度或您需要如何设置评估数据集和测试套件<strong>，您的数据需求将决定您的堆栈的其余部分</strong>。例如，如果您需要经常重新训练，您可能不需要模型监控组件，或者如果您只是解决CV问题，您可能不需要特征存储等。</p>



<h4>合作</h4>



<p id="1b8e">当作者谈到合作时，他们会说:</p>



<blockquote class="wp-block-quote">
<p id="17fb">“五常协作。协作确保了在数据、模型和代码上协同工作的可能性。”</p>
</blockquote>



<p id="ff9e">他们展示了这种协作(P5)发生在源代码库中:</p>





<p id="2c8f">这与我们观察到的现实相差甚远。</p>



<p id="5775">协作还发生在:</p>



<ul>
<li>实验和模型构建迭代</li>



<li>数据注记、清理、共享数据集和要素</li>



<li>管道创作和重用/传输</li>



<li>CI/CD审查/批准</li>



<li>主题专家参与的人在回路反馈循环</li>



<li>模型移交</li>



<li>处理生产模型中的问题以及来自第一线(用户、产品人员、主题专家)和模型构建者的沟通</li>
</ul>



<p id="9f30">澄清一下，我不认为我们作为一个MLOps社区在这里做得很好。</p>



<p id="5f75">源代码回购中的协作是一个良好的开端，但它甚至没有解决MLOps中一半的协作问题。</p>



<p id="7dac">好了，我们已经讨论了MLOps原则，现在让我们来讨论这些原则是/应该如何在工具堆栈组件中实现的。</p>



<h3>成分</h3>



<p id="7afd">同样，CI/CD、源代码版本控制、培训/服务基础设施和监控等许多组件只是DevOps的一部分。</p>



<p id="bbe5">但是有一些额外的东西和一些现有的细微差别。</p>



<ul>
<li>管道创作</li>



<li>数据管理</li>



<li>ML元数据存储(是的，我知道，我有偏见，但我确实相信，与软件不同，实验、调试和手工检查在ML中起着核心作用)</li>



<li>模型监控作为应用程序监控的插件</li>



<li>不需要模型注册中心(yep)</li>
</ul>



<h4>工作流执行者与工作流创作框架</h4>



<p id="4dc6">正如我们之前在原则中提到的，我们有两个子类别的工作流编排组件:</p>



<ul>
<li><strong>工作流程编排/执行工具</strong></li>



<li><strong>管道创作框架</strong></li>
</ul>



<p id="8229">第一个是确保管道正确有效地执行。像Prefect、Argo和Kubeflow这样的工具可以帮助你做到这一点。</p>



<p id="9c33">第二个是关于创建和重用管道的开发。像Kedro、ZenML和Metaflow这样的框架就属于这一类。</p>



<h4>数据管理</h4>



<p id="bad9">这个组件(或一组组件)应该理想地解决的问题是:</p>



<ul>
<li>数据标记</li>



<li>特征准备</li>



<li>特征管理</li>



<li>数据集版本化</li>



<li>数据集审查和比较</li>
</ul>



<p id="9f4f">如今，这似乎可以通过自主开发的解决方案或一系列工具来实现:</p>



<ul>
<li><strong>特色店</strong>像<a href="https://web.archive.org/web/20230307061328/https://www.tecton.ai/" target="_blank" rel="noreferrer noopener nofollow">泰克顿</a>。有趣的是，现在他们更倾向于功能管理平台:“实时机器学习的功能平台”。</li>



<li><strong>贴标平台</strong>如<a href="https://web.archive.org/web/20230307061328/https://labelbox.com/" target="_blank" rel="noreferrer noopener nofollow">贴标箱</a>。</li>



<li><strong>数据集版本控制</strong>与<a href="https://web.archive.org/web/20230307061328/https://dvc.org/" target="_blank" rel="noreferrer noopener nofollow"> DVC </a>。</li>



<li><strong>利用<a href="https://web.archive.org/web/20230307061328/https://www.getdbt.com/" target="_blank" rel="noreferrer noopener nofollow"> dbt实验室进行特征转换和数据集预处理</a></strong>。</li>
</ul>



<p id="b567">应该将这些捆绑到一个“端到端数据管理平台”中，还是用同类最佳的模块化互操作组件来解决？</p>



<p id="0585">我不知道。</p>



<p id="76d6">但是我相信不同部分的用户之间的合作是非常重要的。</p>



<p id="a62b">尤其是现在这个更加以数据为中心的MLOps世界。当主题专家审查这些数据集时更是如此。</p>



<p id="27d2">目前，没有任何工具/平台/堆栈在这方面做得很好。</p>



<h4>ML元数据存储(只有一个)</h4>



<p id="4bd2">在论文中，ML元数据存储在三个上下文中被提及，并且不清楚我们是在谈论一个组件还是多个组件。作者谈到:</p>



<ul>
<li>配置在实验组件旁边的ML元数据存储</li>



<li>使用工作流编排配置的ML元数据存储</li>



<li>使用模型注册表配置的ML元数据存储</li>
</ul>





<p id="2a0c">在我看来，<strong>应该只有一个ML元数据存储库</strong>来实现以下原则:</p>



<ul>
<li>“再现性”</li>



<li>调试、比较、检查</li>



<li>“版本控制+”(版本控制+ ML元数据跟踪/日志记录)，它包括来自不同阶段的任何测试和评估的元数据/结果(例如，在模型发布候选对象进入模型注册中心之前，它们的健康检查和测试结果)</li>
</ul>



<p id="b21d">让我回顾一下这三个ML元数据存储库，并解释我为什么这样认为。</p>



<ol>
<li><strong>配置在实验组件</strong>旁边的ML元数据存储</li>
</ol>



<p id="e39f">这个很简单。也许是因为我在Neptune一直听到这个消息。</p>



<p id="f450">当您进行实验时，您想要迭代各种实验/运行/模型版本，检查结果，并调试问题。</p>



<p id="6468">您希望能够重现结果，并对准备生产的模型进行版本化。</p>



<p id="471c">您想要“跟踪”实验/运行配置和结果、参数、度量、学习曲线、诊断图表、解释器和示例预测。</p>



<p id="158b">你可以把它想象成一个<strong>运行或者模型优先的ML元数据存储</strong>。</p>



<p id="199a">也就是说，我们交谈的大多数人把解决它的组件称为“实验跟踪器”或“实验跟踪工具”。</p>



<p id="616f">当涉及到实验时,“实验追踪者”似乎是一个很棒的名字。</p>



<p id="a6dd">但是，然后您使用它来比较初始实验的结果与CI/CD触发的、自动运行的生产再培训管道，并且“实验”部分似乎不再起作用。</p>



<p id="1cae">我认为ML元数据存储是一个更好的名字，因为它抓住了这个组件的本质。让“记录、存储、比较、组织、搜索、可视化和共享ML模型元数据”变得简单。</p>



<p id="9542">好了，解释了一个ML元数据存储。还有两个。</p>



<p id="d3d7"><strong> 2。配置了工作流编排的ML元数据存储</strong></p>



<p id="f9d7">这一个很有趣，因为<strong>有两个独立的工作</strong>人们想用这个来解决:与ML相关的(比较、调试)和与软件/基础设施相关的(缓存、高效执行、硬件消耗监控)。</p>



<p id="637d">从我们的用户来看，这两项工作是由两种不同类型的工具解决的:</p>



<ul>
<li>人们通过使用本地解决方案或集成外部实验跟踪器来解决与ML相关的工作。他们希望在有实验结果的地方得到重新训练的跑步结果。当你想要比较/检查/调试它们时，这是有意义的。</li>



<li>与<strong>软件/基础设施相关的工作</strong>由orchestrator组件或Grafana、Datadog等传统软件工具完成。</li>
</ul>



<p id="8688">等等，那么配置在工作流编排工具旁边的ML元数据存储不应该收集所有关于管道执行的元数据吗，包括特定于ML的部分？</p>



<p id="df39">也许应该。</p>



<p id="8665">但是<strong>大多数配置了工作流编排器的ML元数据存储并不是按照“比较和调试”原则专门构建的</strong>。</p>



<p id="56da">他们在其他方面也做得很好，比如:</p>



<ul>
<li>缓存中间结果，</li>



<li>基于执行标志重试，</li>



<li>在可用资源上分配执行</li>



<li>提前停止执行</li>
</ul>



<p id="51fc">可能是因为我们<a href="/web/20230307061328/https://neptune.ai/customers/respo-vision" target="_blank" rel="noreferrer noopener nofollow">看到人们使用</a>我们的实验跟踪器来<a href="https://web.archive.org/web/20230307061328/https://app.neptune.ai/o/common/org/kedro-integration/experiments?split=tbl&amp;dash=images&amp;viewId=6e96f108-97e0-4a66-aef5-eb1ed6952eff" target="_blank" rel="noreferrer noopener nofollow">比较/调试复杂ML流水线执行的结果。</a></p>



<p id="50e6">因此，如果人们使用实验跟踪器(或运行/模型优先的ML元数据存储)来处理ML相关的东西，那么这个管道/执行优先的ML元数据存储会发生什么呢？</p>



<p id="2922">它应该只是工作流程编排器的一部分。事实往往如此。</p>



<p id="cc35">它是一个内部引擎，使管道运行顺畅。通过设计，它与工作流编排器紧密结合。把它外包给一个独立的组件是没有意义的。</p>



<p id="e4d4">好了，再说第三个。</p>



<p id="1320"><strong> 3。用模型注册表</strong>配置的ML元数据存储</p>



<p id="4416">引用论文:</p>



<blockquote class="wp-block-quote">
<p id="e4e4">可以在模型注册中心内配置另一个元数据存储，用于跟踪和记录每个训练作业的元数据(例如，训练日期和时间、持续时间等)。)，包括特定于模型的元数据—例如，使用的参数和产生的性能指标、模型谱系:使用的数据和代码”</p>
</blockquote>



<p id="4ffa">好的，这里列出的几乎所有东西都会被记录到实验跟踪器中。</p>



<p id="09b8">那里通常不记录什么？大概是:</p>



<ul>
<li>生产前测试的结果、再培训运行的日志、CI/CD触发的评估。</li>



<li>有关模型打包方式的信息。</li>



<li>关于模型何时被批准/在阶段之间转换(阶段/生产/归档)的信息。</li>
</ul>



<p id="cf0a">现在，如果你像我一样，更广泛地将“实验跟踪器”视为一个ML元数据存储，它解决了“可再现性”、“调试、比较、检查”和“版本+”原则，那么大部分元数据实际上都在那里。</p>



<p id="8db9">没有的东西，比如阶段转换时间戳，保存在诸如<a href="https://web.archive.org/web/20230307061328/https://docs.github.com/en/actions/managing-workflow-runs/reviewing-deployments" target="_blank" rel="noreferrer noopener nofollow"> Github Actions </a>、Dockerhub、Artifactory或CI/CD tools之类的地方。</p>



<p id="662a">我不认为还有什么需要记录到一个特殊的“配置在模型注册中心旁边的ML元数据存储”中。</p>



<p id="05e8">我也认为这是为什么我们交谈的这么多团队期望实验跟踪和模型注册之间的紧密耦合。</p>



<p id="326f">这很有意义:</p>



<ul>
<li>他们想要实验跟踪器里所有的ML元数据。</li>



<li>他们希望在模型注册中心有一个生产就绪的打包模型</li>



<li>他们希望这两个部分之间有明确的联系</li>
</ul>



<p id="5155">但是不需要另一个ML元数据存储。</p>



<p id="189d">只有一个ML元数据存储。有趣的是，大多数ML从业者甚至不称之为“ML元数据存储”，而是称之为“实验跟踪器”。</p>



<p id="98d9">好了，既然说到“模型注册”，我还有一件事要讨论。</p>



<h4>模型注册表。我们真的需要它吗？</h4>



<p id="647f">前一段时间，我们向Neptune 引入了<a href="/web/20230307061328/https://neptune.ai/product/model-registry" target="_blank" rel="noreferrer noopener">模型注册功能，并且我们一直致力于为我们的用户和客户改进它。</a></p>



<p id="a247">同时，如果您问我，从长远来看，MLOps/DevOps中是否有/将会有对模型注册中心的需求，我会说没有！</p>



<p id="c435">对我们来说，“模型注册”是向用户和社区传达我们的ML元数据存储是存储和管理关于生产模型的ML元数据的正确工具栈组件的一种方式。</p>



<p id="d594">但它不是也不会是实现批准系统、进行模型供应(服务)、自动扩展、金丝雀测试等的正确组件。</p>



<p id="64cb">从软件工程的角度来看，这就像是重新发明轮子一样。</p>



<p id="ed64">像Docker Hub或JFrog Artifactory这样的工件注册中心不是更好吗？</p>



<p id="2e07">难道你不想把包装好的模型放在Kubernetes的舵手图表里，然后就此收工吗？</p>



<p id="3c39">当然，您需要参考模型构建历史或生产前测试的结果。</p>



<p id="6c78">您希望确保新模型的输入-输出模式与预期的模式相匹配。</p>



<p id="756d">您希望在可以比较以前/新模型的同一位置批准模型。</p>



<p id="6f35">但是所有这些并没有真正“存在”在新的模型注册组件中，不是吗？</p>



<p id="2bc1">它们主要存在于CI/CD管道、docker注册表、生产模型监控工具或实验跟踪器中。</p>



<p id="4d91">它们不在名为模型注册中心的闪亮的新MLOps组件中。</p>



<p id="1593">您可以通过完美集成以下内容来解决这个问题:</p>



<ul>
<li>CI/CD反馈循环包括手动批准和“部署按钮”(查看<a href="https://web.archive.org/web/20230307061328/https://circleci.com/docs/workflows#holding-a-workflow-for-a-manual-approval" target="_blank" rel="noreferrer noopener nofollow"> CircleCI </a>或<a href="https://web.archive.org/web/20230307061328/https://docs.gitlab.com/ee/ci/environments/deployment_approvals.html" target="_blank" rel="noreferrer noopener nofollow"> GitLab </a>如何做到这一点)</li>



<li>+模型打包工具(以获得可部署的包)</li>



<li>+容器/工件注册中心(有一个放置现成模型的地方)</li>



<li>+ ML元数据存储(获取完整的建模历史)</li>
</ul>



<p id="a5b7">对吗？</p>



<p id="778a">我可以向我的DevOps朋友解释模型注册中心需要一个单独的工具吗？</p>



<p id="e078">我们交谈过的许多曼梯·里的人似乎都明白这一点。</p>



<p id="3c6d">但这是因为他们没有真正完全理解DevOps工具提供了什么吗？</p>



<p id="9a73">我想可能是这样。</p>



<p id="2f13">说实话，一些团队有自己开发的模型注册解决方案，它只是所有这些工具之上的一个薄层。</p>



<p id="b4da">也许这就足够了。也许这正是注册管理机构的模式。一个抽象薄层，包含对DevOps/MLOps堆栈中其他工具的引用和挂钩。</p>



<h4>模型监控。等等，哪一个？</h4>



<p id="bf1c">“模型监控”是MLOps领域中最模糊、最令人困惑的名称(“ML元数据存储”排在第二位)。</p>



<p id="6958">“模型监控”对三个不同的人来说意味着六件不同的事情。</p>



<p id="7a33">我们与团队交流的意思是:</p>



<ul>
<li><strong> (1)在生产中监控模型性能:</strong>看模型性能是否随时间衰减，你要重新训练。</li>



<li><strong> (2)监控模型输入/输出分布:</strong>查看输入数据的分布、特征或预测分布是否随时间变化。</li>



<li><strong> (3)监控模型训练和再训练:</strong>在训练和再训练过程中，查看学习曲线、训练后的模型预测分布或混淆矩阵。</li>



<li><strong> (4)监控模型评估和测试:</strong>为您的自动化评估或测试管道记录度量、图表、预测和其他元数据</li>



<li><strong> (5)监控基础设施指标:</strong>查看你的模型在训练和推断过程中使用了多少CPU/GPU或内存。</li>



<li><strong> (6)监控CI/CD管道的ML: </strong>查看您的CI/CD管道作业的评估，并进行直观比较。</li>
</ul>



<p id="5464">例如:</p>



<ul>
<li>Neptune在(3)和(4)上做得很好，(5)还可以(正在努力)，但是我们看到团队也在(6)上使用它</li>



<li>普罗米修斯+格拉法纳确实擅长(5)，但人们把它用于(1)和(2)</li>



<li>Whylabs或者Arize AI真的很擅长(1)和(2)</li>
</ul>



<p id="1536">因为我确实相信MLOps只是DevOps的一个扩展，所以我们需要了解像Datadog、Grafana、NewRelic和ELK (Elastic、Logstash、Kibana)这样的软件可观测性工具在今天和未来适合MLOps。</p>



<p id="984b">此外，一些部分本质上是非连续和非自动的。比如比较/检查/调试模型。有主题专家和数据科学家参与其中。我看不出这是如何持续和自动的。</p>



<p id="fcda">但最重要的是，我们应该弄清楚什么是真正特定于ML的，并在那里构建模块化工具或插件。</p>



<p id="e176">对于其他的，我们应该使用更成熟的软件监控组件，很可能你的DevOps团队已经有了。</p>



<p id="5252">因此，也许下面的拆分会让事情变得更加明显:</p>



<ul>
<li>生产模型的可观察性和监控(亚利桑那州WhyLabs)</li>



<li>监控模型培训、再培训、评估和测试(MLflow、Neptune)</li>



<li>基础设施和应用监控(Grafana、Datadog)</li>
</ul>



<p id="853b">我很想看看Datadog和Arize AI的首席执行官如何考虑他们在DevOps/MLOps中的长期位置。</p>



<p id="c72c">漂移检测只是应用程序监控堆栈的一个“插件”吗？我不知道，但实际上似乎很合理。</p>



<h2 id="h-final-thoughts-and-open-challenges">最后的想法和公开的挑战</h2>



<p id="3287">如果我想让你从这篇文章中学到什么，那就是这个。</p>



<p id="d2bc"><strong>我们不应该考虑如何从头开始构建MLOps堆栈。</strong></p>



<p id="0066">我们应该考虑如何逐步扩展现有的DevOps堆栈，以满足您目前的特定ML需求。</p>



<p id="6bb7">作者说:</p>



<blockquote class="wp-block-quote">
<p id="20ad">“为了成功开发和运行ML产品，需要从模型驱动的机器学习向面向产品的学科进行文化转变</p>



<p id="960c">…</p>



<p id="03c2">尤其是在设计ML产品时，与这些活动相关的角色应该有一个以产品为中心的视角。</p>
</blockquote>



<p id="9050">我认为我们需要更大的思维转变:</p>



<p id="4f9b"><strong> ML模型- &gt; ML产品- &gt;使用ML的软件产品- &gt;只是另一个软件产品</strong></p>



<p id="18a6">并且你的ML驱动的软件产品被连接到交付软件产品的现有基础设施上。</p>



<p id="c189">我不明白为什么ML在这里长期是一片特殊的雪花。我真的不知道。</p>



<p id="81c0">但是，即使查看所展示的MLOps堆栈，99%的团队实际需要的实用的v1版本是什么？</p>



<p id="8834">作者采访了拥有6500多名员工的公司的ML从业者。大部分做生产ML的公司都不是那样的。对于大多数团队来说，MLOps堆栈要简单得多。</p>



<p id="8bfb">尤其是那些在合理规模做<a href="/web/20230307061328/https://neptune.ai/blog/mlops-at-reasonable-scale" target="_blank" rel="noreferrer noopener"> ML/MLOps的。</a></p>



<p id="34a9">他们可能会选择1到2个他们深入研究的组件，其余的则是超级基础的东西。</p>



<p id="71d9">或者什么都没有。</p>



<p id="19fe">你不需要:</p>



<ul>
<li>cron作业足够时的工作流程编排解决方案。</li>



<li>当CSV足够时存储功能。</li>



<li>当电子表格足够时，进行实验跟踪。</li>
</ul>



<p id="79f8">真的，你不知道。</p>



<p id="4d0e">我们看到许多团队通过务实和专注于目前对他们来说重要的事情来交付伟大的东西。</p>



<p id="f2b0">在某个时候，他们可能会将其MLOps堆栈增长到我们在本文中看到的规模。</p>



<p id="8f61">或者参加DevOps会议，并意识到他们应该只是扩展DevOps堆栈😉</p>



<hr class="wp-block-separator has-alpha-channel-opacity"/>



<p id="539d">我偶尔会在我的Linkedin个人资料上分享我对ML和MLOps前景的看法。如果你对这个话题感兴趣，请随时跟我来。此外，如果你想和我聊聊，也可以联系我。</p>
        </div>
        
    </div>    
</body>
</html>