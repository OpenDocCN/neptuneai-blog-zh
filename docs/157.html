<html>
<head>
<title>The Ultimate Guide to Word Embeddings </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>单词嵌入终极指南</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/word-embeddings-guide#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/word-embeddings-guide#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p><a href="https://web.archive.org/web/20230213062731/https://www.tensorflow.org/tutorials/text/word_embeddings" target="_blank" rel="noreferrer noopener nofollow">单词嵌入</a>是自然语言处理(NLP)中最常用的技术之一。人们常说，如果没有单词嵌入，SOTA模型的性能和能力就不可能实现。正是因为单词嵌入，像<a href="/web/20230213062731/https://neptune.ai/blog/recurrent-neural-network-guide" target="_blank" rel="noreferrer noopener"> RNN </a> s，LSTMs，ELMo，<a href="/web/20230213062731/https://neptune.ai/blog/bert-and-the-transformer-architecture-reshaping-the-ai-landscape" target="_blank" rel="noreferrer noopener">伯特</a>，阿尔伯特，GPT-2到最近的GPT-3这样的语言模型以惊人的速度进化。</p>



<p>这些算法速度快，可以高精度地生成语言序列和其他下游任务，包括<strong>上下文理解、语义</strong>和<strong>句法属性</strong>、<strong>T5】以及<strong>、</strong>词与词之间的线性关系<strong>。</strong></strong></p>



<p>核心上，这些模型使用嵌入作为从文本或语音序列中提取模式的方法。但是他们是怎么做到的呢？单词嵌入背后的确切机制和数学原理是什么？</p>



<p>在本文中，我们将探索一些早期的神经网络技术，这些技术让我们能够为自然语言处理构建复杂的算法。对于某些主题，会有一个论文的链接和一个附带的colab笔记本，这样你就可以通过尝试来理解这些概念。这样做会帮助你学得更快。</p>



<p>我们将涉及的主题:</p>



<ol>
<li><strong> <a href="#word-embeddings" target="_blank" rel="noreferrer noopener nofollow">什么是单词嵌入？</a>T3】</strong></li>



<li><strong> <a href="#neural-language-model" target="_blank" rel="noreferrer noopener nofollow">神经语言模型</a> </strong></li>



<li><strong><a href="#word2vec" target="_blank" rel="noreferrer noopener nofollow">word 2 vec</a>T3】</strong><ol>
<li>skip程序</li>



<li>连续的单词袋</li>
</ol>
</li>



<li>softmax功能上的<strong><a href="#softmax-function" target="_blank" rel="noreferrer noopener nofollow"/></strong></li>



<li><strong> <a href="#approximation" target="_blank" rel="noreferrer noopener nofollow">提高近似值</a> </strong><ol>
<li>基于Softmax的方法<ol>
<li>分级Softmax</li>
</ol>
</li>



<li>基于抽样的方法<ol>
<li>噪声对比估计</li>



<li>负采样</li>
</ol>
</li>
</ol>
</li>
</ol>



<h2 id="word-embeddings">什么是单词嵌入？</h2>



<p>单词嵌入是以数字方式表示单词和整个句子的一种方式。我们知道计算机理解数字语言，所以我们试图将一个句子中的单词编码成数字，这样计算机就可以阅读和处理它。</p>



<p>但是阅读和处理并不是我们希望计算机做的唯一事情。我们还希望计算机在句子中的每个单词之间建立关系，或者在文档中与其他单词建立关系。</p>



<p>我们希望单词嵌入能够捕获段落或之前句子的上下文，同时捕获语义和句法属性以及它们的相似性。</p>



<p>例如，如果我们取一个句子:</p>



<p>“猫躺在地板上，<strong>狗</strong>在吃东西”，</p>



<p>…然后我们可以把这两个主语(猫和狗)在句子中调换一下，使其成为:</p>



<p>“那只<strong>狗</strong>躺在地板上，那只<strong>猫</strong>在吃东西”。</p>



<p>在这两个句子中，保留了语义或意义相关的关系，即猫和狗都是动物。这句话很有道理。</p>



<p>同样，句子也保留了句法关系，即基于规则的关系或语法。</p>



<p>为了实现这种语义和句法关系，我们需要的不仅仅是将句子或文档中的一个单词映射成简单的数字。我们需要这些数字的一个更大的表示，能够表示语义和语法属性。</p>



<p>我们需要向量。不仅如此，还有<strong>可学习的</strong>向量。</p>



<p>在数学意义上，单词嵌入是单词的参数化函数:</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/14646cf5564249e7c6ec19d485063147.png" alt="Word embedding equation" class="wp-image-45585" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230213062731im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Word-embedding-equation.png?ssl=1"/></figure>



<p>其中是参数，W是句子中的单词。</p>



<p>很多人也将单词嵌入定义为以向量形式的单词的密集表示。</p>



<p>例如，单词猫和狗可以表示为:</p>



<p><em> W(cat) = (0.9，0.1，0.3，-0.23 … ) </em></p>



<p><em> W(狗)= (0.76，0.1，-0.38，0.3 … ) </em></p>



<p>现在，假设来说，如果模型能够保持上下文相似性，那么两个单词在向量空间中将是接近的。</p>





<p>到目前为止，我们已经处理了两个单词(猫和狗)，但如果有更多的单词呢？工作嵌入模型的工作是聚集相似的信息并在它们之间建立关系。</p>



<p>如您所见，单词嵌入将相似的单词聚集在一起。</p>





<p>现在有很多浅层算法可以很好地用于聚类。为什么我们需要神经网络？</p>



<p>最大的误解之一是单词嵌入需要深度神经网络。当我们构建不同的单词嵌入模型时，您会看到，对于所有的嵌入，模型都是浅层神经网络，有些还是线性模型。</p>



<p>我们使用神经网络来创建单词嵌入的原因是:</p>



<ol>
<li>这有助于在嵌入空间中找到最近的邻居。</li>



<li>它可以用作监督学习任务的输入。</li>



<li>它创建了离散变量的映射，例如从单词到向量，再到连续变量的映射。</li>



<li>它还解决了维数灾难。</li>
</ol>







<h2 id="neural-language-model">神经语言模型</h2>



<p>单词嵌入是由Bengio等人提出的。艾尔。(2001，2003)来解决所谓的<strong>维数灾难</strong>，这是<strong>统计语言建模</strong>中的一个常见问题。</p>



<p>事实证明，本吉奥的方法可以训练一个神经网络，使得每个训练句子都可以向模型提供一些语义上可用的相邻单词，这被称为单词的<strong>分布式表示</strong> <strong>。</strong>神经网络没有建立不同单词之间的关系，但它也保留了语义和句法属性方面的关系<strong>。</strong></p>


<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" src="../Images/d9403f815ae0591abe667c3f46e4e044.png" alt="Neural network architecture approach" class="wp-image-45590" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230213062731im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Neural-network-architecture-approach.jpeg?ssl=1"/><figcaption class="wp-element-caption"><em>Source: Bengio et. al. 2003</em></figcaption></figure></div>


<p>这引入了神经网络架构方法，为许多当前方法奠定了基础。</p>



<p>这个神经网络有三个组成部分:</p>



<ol>
<li>生成单词嵌入的<strong>嵌入层</strong>，参数跨单词共享。</li>



<li>一层或多层的<strong>隐藏层</strong> r，这给嵌入引入了非线性。</li>



<li>一个<strong> softmax函数</strong>，产生词汇表中所有单词的概率分布。</li>
</ol>



<p>让我们来理解一个神经网络语言模型是如何在代码的帮助下工作的。</p>



<p>(这里有<a href="https://web.archive.org/web/20230213062731/https://colab.research.google.com/drive/12TQ4CmY6jUnFlQZFnKenmKL3UdTkcatx?usp=sharing" target="_blank" rel="noreferrer noopener nofollow">笔记本</a>和<a href="https://web.archive.org/web/20230213062731/https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf" target="_blank" rel="noreferrer noopener nofollow">原始论文</a>的链接)</p>



<p>第一步:索引单词。我们从索引单词开始。对于<strong>句子中的每个单词</strong>，我们会给它分配一个数字。</p>



<pre class="hljs">word_list = <span class="hljs-string">" "</span>.join(raw_sentence).split()
word_list = list(set(word_list))
word2id = {w: i <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> enumerate(word_list)}
id2word = {i: w <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> enumerate(word_list)}
n_class = len(word2id)</pre>



<p>第二步:建立模型。</p>



<p>我们将完全按照论文中的描述来构建模型。</p>



<pre class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NNLM</span><span class="hljs-params">(nn.Module)</span>:</span>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
       super(NNLM, self).__init__()
       self.embeddings = nn.Embedding(n_class, m) 

       self.hidden1 = nn.Linear(n_step * m, n_hidden, bias=<span class="hljs-keyword">False</span>)
       self.ones = nn.Parameter(torch.ones(n_hidden))

       self.hidden2 = nn.Linear(n_hidden, n_class, bias=<span class="hljs-keyword">False</span>)
       self.hidden3 = nn.Linear(n_step * m, n_class, bias=<span class="hljs-keyword">False</span>) 

       self.bias = nn.Parameter(torch.ones(n_class))

   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, X)</span>:</span>
       X = self.embeddings(X) 
       X = X.view(<span class="hljs-number">-1</span>, n_step * m) 
       tanh = torch.tanh(self.d + self.hidden1(X)) 
       output = self.b + self.hidden3(X) + self.hidden2(tanh) 
       <span class="hljs-keyword">return</span> output</pre>



<p>我们将从初始化一个嵌入层开始。嵌入层是一个查找表。</p>



<p>一旦单词的输入索引通过一个嵌入层被嵌入，它就会通过第一个隐藏层，并添加偏向。这两个函数的输出然后通过一个双曲正切函数。</p>



<p>如果您还记得原始论文中的图表，那么来自嵌入层的输出也被传递到最终的隐藏层，在那里tanh的输出被加在一起。</p>



<pre class="hljs">output = self.b + self.hidden3(X) + self.hidden2(tanh)</pre>



<p>现在，在最后一步，我们将计算整个词汇的概率分布。</p>



<p><strong>第三步:损失和优化函数。</strong></p>



<p>现在我们已经有了模型的输出，我们需要确保我们通过softmax函数传递它以获得概率分布。</p>



<p>我们使用交叉熵损失。</p>



<pre class="hljs">criterion = nn.CrossEntropyLoss()</pre>



<p>交叉熵损失由两个方程组成:对数softmax函数和负对数似然损失或NLLLoss。前者计算softmax归一化，而后者计算负对数似然损失。</p>



<p>对于优化，我们使用Adam优化器。</p>







<p>第四步:训练。</p>



<p>最后，我们训练模型。</p>



<p>简而言之，单词嵌入可以被定义为单词在低维空间中以向量形式的密集表示。这些嵌入伴随着l个<strong>可学习向量，或者参数化函数</strong>。它们使用损失函数在反向传播过程中更新自己，并试图找到单词之间的良好关系，保留语义和突触属性。</p>





<p><em>“事实证明，基于神经网络的模型明显优于基于统计的模型”</em> <strong>米科洛夫等人。艾尔。(2013) </strong>。</p>



<h2 id="word2vec">Word2Vec</h2>



<p>Bengio介绍的方法为NLP研究人员提供了新的机会来修改技术和架构本身，以创建一种计算成本更低的方法。<strong>为什么？</strong></p>



<p>Bengio等人提出的方法从词汇表中提取单词，并将其输入具有嵌入层、隐藏层和softmax函数的前馈神经网络。</p>



<p>这些嵌入有相关联的可学习向量，这些向量通过反向传播来优化自身。本质上，架构的第一层产生单词嵌入，因为它是一个浅层网络。</p>



<p>这种架构的问题在于隐藏层和投影层之间的计算开销很大。原因很复杂:</p>



<ol>
<li>投影中产生的值是<strong>密集</strong>。</li>



<li>隐藏层为词汇表中的<strong>所有单词计算概率分布。</strong></li>
</ol>



<p>为了解决这个问题，研究人员(Mikolov等人在2013年)提出了一个名为<strong>‘word 2 vec’</strong>的模型。</p>



<p>Word2Vec模型本质上解决了本吉奥的NLM问题。</p>



<p>它完全删除了隐藏层，但投影层是所有单词共享的，就像Bengio的模型一样。缺点是，如果数据较少，这个没有神经网络的简单模型将无法像神经网络一样精确地表示数据。</p>



<p>另一方面，对于更大的数据集，它可以在嵌入空间中精确地表示数据。与此同时，它还降低了复杂性，并且该模型可以在更大的数据集中进行训练。</p>



<p>Mikolov等人在2013年提出了两个模型:</p>



<ol>
<li>连续词袋模型</li>



<li>连续跳格模型</li>
</ol>



<h3>连续词袋模型</h3>



<p>连续词袋(Bag-of-Words)或CBOW模型基本上在目标词(wt)之前和之后取'<em> n' </em>个词，并预测后者。<em> n </em>可以是任何数字。</p>



<p>例如，如果n=2，句子是“<em>狗正在公园里玩耍</em>”，那么输入到模型中的单词将是(【the，dog，is，in，the，park】)，后面是目标单词“<strong>正在玩耍“</strong>”。</p>



<p>该模型通过计算<strong> log2(V) </strong>消除了计算词汇表中所有单词的概率分布的复杂性，其中V是词汇表的大小。因此，这种模式更快更有效。</p>





<p>让我们借助代码来理解CBOW模型是如何工作的。</p>



<p>(这里有<a href="https://web.archive.org/web/20230213062731/https://colab.research.google.com/drive/1Jr3hdPt_tC40cf9lvIS2yRnETdxz0PCa?usp=sharing" target="_blank" rel="noreferrer noopener nofollow">笔记本</a>和<a href="https://web.archive.org/web/20230213062731/https://arxiv.org/abs/1310.4546" target="_blank" rel="noreferrer noopener nofollow">原始论文</a>的链接)</p>



<p>首先，我们不会将单词编码方法改为数字。那将保持不变。</p>



<p><strong>第一步:定义一个函数，用目标词左右n个词创建一个上下文窗口。</strong></p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">CBOW</span><span class="hljs-params">(raw_text, window_size=<span class="hljs-number">2</span>)</span>:</span>
   data = []
   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(window_size, len(raw_text) - window_size):
       context = [raw_text[i - window_size], raw_text[i - (window_size - <span class="hljs-number">1</span>)], raw_text[i + (window_size - <span class="hljs-number">1</span>)], raw_text[i + window_size]]
       target = raw_text[i]
       data.append((context, target))

   <span class="hljs-keyword">return</span> data</pre>



<p>该函数应该有两个参数:数据和窗口大小。窗口大小将定义我们应该从右边和左边获取多少单词。</p>



<p>for循环:for i in range(window_size，len(raw _ text)–window _ size):从窗口大小开始遍历一个范围，即2表示将忽略句子中索引0和1中的单词，并在句子结束前结束2个单词。</p>



<p>在for循环中，我们尝试分离上下文和目标单词，并将它们存储在一个列表中。</p>



<p>例如，如果句子是“<em>狗在吃东西，猫躺在地板上</em>”，带有窗口2的CBOW将考虑单词“<em>”、“狗”、“吃东西”</em>和<em>“和”。</em>本质上使目标词‘是’。</p>



<p>设i =窗口大小= 2，则:</p>



<pre class="hljs">context = [raw_text[<span class="hljs-number">2</span> - <span class="hljs-number">2</span>], raw_text[<span class="hljs-number">2</span> - (<span class="hljs-number">2</span> - <span class="hljs-number">1</span>)], raw_text[i + (<span class="hljs-number">2</span> - <span class="hljs-number">1</span>)], raw_text[i + <span class="hljs-number">2</span>]]

target = raw_text[<span class="hljs-number">2</span>]
</pre>



<p>让我们调用该函数并查看输出。</p>



<pre class="hljs">data = CBOW(raw_text)
print(data[<span class="hljs-number">0</span>])</pre>



<pre class="hljs">Output:
([<span class="hljs-string">'The'</span>, <span class="hljs-string">'dog'</span>, <span class="hljs-string">'eating'</span>, <span class="hljs-string">'and'</span>], <span class="hljs-string">'is'</span>)</pre>



<p>第二步:建立模型。</p>



<p>构建CBOW类似于我们之前构建的NNLM，但实际上要简单得多。</p>



<p>在CBOW模型中，我们将隐藏层减少到只有一层。所以我们总共有:一个嵌入层，一个穿过ReLU层的隐藏层，和一个输出层。</p>



<pre class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CBOW_Model</span><span class="hljs-params">(torch.nn.Module)</span>:</span>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, vocab_size, embedding_dim)</span>:</span>
       super(CBOW_Model, self).__init__()

       self.embeddings = nn.Embedding(vocab_size, embedding_dim)
       self.linear1 = nn.Linear(embedding_dim, <span class="hljs-number">128</span>)
       self.activation_function1 = nn.ReLU()

       self.linear2 = nn.Linear(<span class="hljs-number">128</span>, vocab_size)


   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, inputs)</span>:</span>
       embeds = sum(self.embeddings(inputs)).view(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)
       out = self.linear1(embeds)
       out = self.activation_function1(out)
       out = self.linear2(out)
       <span class="hljs-keyword">return</span> out</pre>



<p>这个模型非常简单。上下文词索引被送入嵌入层，然后通过隐藏层，接着是非线性激活层，即ReLU，最后我们得到输出。</p>



<p><strong>第三步:损失和优化函数。</strong></p>



<p>类似于NNLM，我们使用同样的技术来计算词汇表中所有单词的概率分布。nn。CrossEntropyLoss()。</p>



<p>对于优化，我们使用随机梯度下降。你也可以使用Adam优化器。在NLP中，Adam是首选的优化器，因为它比SGD收敛得更快。</p>



<pre class="hljs">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">0.01</span>)</pre>



<p><strong>第四步:训练</strong></p>



<p>培训与NNLM模式相同。</p>



<pre class="hljs"><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):
   total_loss = <span class="hljs-number">0</span>

   <span class="hljs-keyword">for</span> context, target <span class="hljs-keyword">in</span> data:

       context_vector = make_context_vector(context, word_to_ix)

       output = model(context_vector)

       target = torch.tensor([word_to_ix[target]])
       total_loss += loss_function(output, target)

   
   optimizer.zero_grad()
   total_loss.backward()
   optimizer.step()</pre>



<p>make_context_vector把单词变成数字。</p>



<p>值得注意的是，这篇论文的作者发现，NNLM保留了相似词之间的线性关系。比如<em>【国王】</em><em>【王后】</em>与<em>【男人】</em><em>【女人】</em>相同，即NNLM保留了性别线性。</p>



<p>同样，CBOW等模型以及我们接下来将讨论的任何神经网络模型都将保持线性关系，即使我们在神经网络中明确定义了非线性。</p>



<h3>连续跳格模型</h3>



<p>连续跳格，或跳格，类似于CBOW。它不是预测目标单词(wt)，而是通过上下文预测它周围的单词。训练目标是学习擅长预测邻近单词的表示或嵌入。</p>



<p>还需要<em>“n”</em>个单词。例如，如果n=2，句子是“<em>狗在公园里玩</em>”，那么输入到模型中的单词将是<strong>在玩</strong>，目标单词将是(狗在公园里)。</p>





<p>让我们借助代码来理解跳格模型是如何工作的。</p>



<p>(这里有<a href="https://web.archive.org/web/20230213062731/https://colab.research.google.com/drive/1lLRH5BrSD8SWlnDQGWYGxj0WWBUfwg5l?usp=sharing" target="_blank" rel="noreferrer noopener nofollow">笔记本</a>和<a href="https://web.archive.org/web/20230213062731/https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf" target="_blank" rel="noreferrer noopener nofollow">原始论文</a>的链接)</p>



<p>skipgram模型与CBOW模型相同，但有一点不同。区别在于创造语境和目标词。</p>



<p><strong>步骤1:设置目标和上下文变量。</strong></p>



<p>由于skipgram只需要一个上下文单词和n个目标变量，我们只需要从前面的模型中翻转CBOW。</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">skipgram</span><span class="hljs-params">(sentences, window_size=<span class="hljs-number">1</span>)</span>:</span>
   skip_grams = []
   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(window_size, len(word_sequence) - window_size):
       target = word_sequence[i]
       context = [word_sequence[i - window_size], word_sequence[i + window_size]]
       <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> context:
           skip_grams.append([target, w])

   <span class="hljs-keyword">return</span> skip_grams</pre>



<p>如你所见，功能几乎相同。</p>



<p>这里你需要明白，当窗口大小为1时，我们在目标词前后取一个词。</p>



<p>当我们调用该函数时，输出如下所示:</p>



<pre class="hljs">print(skipgram(word_sequence)[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])</pre>



<pre class="hljs">Output:
[[<span class="hljs-string">'my'</span>, <span class="hljs-string">'During'</span>], [<span class="hljs-string">'my'</span>, <span class="hljs-string">'second'</span>]]</pre>



<p>可以看到，目标词是<em>‘我的’</em>，两个词是<em>‘期间’</em>和<em>‘第二’</em>。</p>



<p>本质上，我们试图创建一对单词，使得每对单词都包含一个目标单词。根据上下文窗口，它将包含相邻的单词。</p>



<p>第二步:建立模型。</p>



<p>这个模型非常简单。</p>



<pre class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">skipgramModel</span><span class="hljs-params">(nn.Module)</span>:</span>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
       super(skipgramModel, self).__init__()
       self.embedding = nn.Embedding(voc_size, embedding_size)
       self.W = nn.Linear(embedding_size, embedding_size, bias=<span class="hljs-keyword">False</span>)
       self.WT = nn.Linear(embedding_size, voc_size, bias=<span class="hljs-keyword">False</span>)

   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, X)</span>:</span>
       embeddings = self.embedding(X)
       hidden_layer = nn.functional.relu(self.W(embeddings))
       output_layer = self.WT(hidden_layer)
       <span class="hljs-keyword">return</span> output_layer</pre>



<p>损失函数和优化保持不变。</p>



<pre class="hljs">criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">0.001</span>)</pre>



<p>一旦我们定义了一切，我们就可以训练模型了。</p>



<pre class="hljs"><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> range(<span class="hljs-number">5000</span>):
        input_batch, target_batch = random_batch()
        input_batch = torch.Tensor(input_batch)
        target_batch = torch.LongTensor(target_batch)

        optimizer.zero_grad()
        output = model(input_batch)

        
        loss = criterion(output, target_batch)
        <span class="hljs-keyword">if</span> (epoch + <span class="hljs-number">1</span>) % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:
            print(<span class="hljs-string">'Epoch:'</span>, <span class="hljs-string">'%04d'</span> % (epoch + <span class="hljs-number">1</span>), <span class="hljs-string">'cost ='</span>, <span class="hljs-string">'{:.6f}'</span>.format(loss))

        loss.backward()
        optimizer.step()</pre>



<p>skip-gram模型增加了计算的复杂性，因为它必须根据相邻单词的数量来预测相邻的单词。距离较远的单词往往与当前单词的相关性稍低。</p>



<p>到目前为止的总结:</p>



<ol>
<li><strong>神经网络语言模型</strong> (NNLM)或Bengio的模型优于早期的统计模型，如n-gram模型。</li>



<li>NNLM还解决了维数灾难，并通过其分布式表示保留了上下文，语言规则和模式。</li>



<li>NNLM计算量很大。</li>



<li>Word2Vec模型通过移除隐藏层和共享权重来解决计算复杂性</li>



<li>Word2Vec的缺点是它没有神经网络，这使得它很难表示数据，但优点是如果它可以在大量数据上训练，那么因为它比神经网络更有效，所以它可以计算非常精确的高维单词向量。</li>



<li>Word2Vec有两个型号:CBOW和Skipgram。前者比后者快。</li>
</ol>



<h2 id="softmax-function">关于softmax函数</h2>



<p>到目前为止，您已经看到了<strong> softmax函数</strong>如何在预测给定上下文中的单词时发挥重要作用。但是它有一个复杂的问题。</p>



<p>回想一下softmax函数的等式:</p>



<figure class="wp-block-image"><img decoding="async" src="../Images/17faf41dbb0a9585cd56a5d4ac7fe710.png" alt="" data-original-src="https://web.archive.org/web/20230213062731im_/https://lh4.googleusercontent.com/SB2Y3tXTb7N3KYvXoX5SoNdsuyCteRtY3bIOAOpX5qs3SJVsh_0zjZ4PleZxlTjMqEfiMlUEWgAqzP947Z1St5ivinZpHxcuWdBO4bX1Yux0scESfryO14dfbEiK3x9Z7rc04WXN"/></figure>



<p>其中<em>w<sub>t</sub>T3】是目标单词，<em> c </em>是上下文单词，<em> y </em>是每个目标单词的输出。</em></p>



<p>如果查看上面的等式，当预测值的数量较高时，softmax函数的复杂性就会增加。如果<em> i=3，</em>，那么softmax函数将返回三个类别的概率分布。</p>



<p>但是，在自然语言处理中，我们通常要处理成千上万的单词。获得这么多单词的概率分布会使计算变得非常昂贵和缓慢。</p>



<p>请记住，softmax函数返回精确的概率分布，因此随着参数的增加，它们的速度会变慢。对于每个单词(<em> w <sub> t </sub> </em>)，它在分母中对整个词汇表求和。</p>



<p>那么，有什么不同的方法可以使计算既便宜又快速，同时又能确保近似不被破坏呢？</p>



<p>在下一节中，我们将介绍可以减少计算时间的不同方法。我们将尝试对整个词汇表，甚至是一个样本词汇表进行近似计算，而不是获得整个词汇表的精确概率。这降低了复杂性并提高了处理速度。</p>



<p>我们将讨论两种方法:基于softmax的方法和基于采样的方法。</p>







<h2 id="approximation">改进预测功能</h2>



<p>在本节中，我们探索了三种可能的方法来改进预测，通过修改softmax函数来逼近更好的结果，并用新方法替换softmax。</p>



<h3>基于Softmax的方法</h3>



<p>基于Softmax的方法更倾向于修改softmax以获得预测单词的更好近似，而不是完全消除它。我们将讨论两种方法:分层softmax方法和CNN方法。</p>



<h4>分级softmax</h4>



<p>分层softmax是由Morin和Bengio在2005年引入的，作为完整softmax函数的替代，它用分层来代替完整soft max函数。它借鉴了二进制<strong>哈夫曼树</strong>的技术，将计算概率的复杂度从整个词汇<em> V </em>降低到<em> log <sub> 2 </sub> (V) </em>，即二进制。</p>



<p>编码一棵霍夫曼树是非常复杂的。我尽量不用代码解释，不过你可以在这里找到<a href="https://web.archive.org/web/20230213062731/https://colab.research.google.com/drive/1NGn67rTy27tuN_0mZfpIyN02wsbAS_zu?usp=sharing" target="_blank" rel="noreferrer noopener nofollow">笔记本</a>试试看。</p>



<p>为了理解H-softmax，我们需要理解霍夫曼树的工作原理。</p>



<p>霍夫曼树是一棵二叉树，它从词汇表中提取单词；基于它们在文档中的出现频率，它创建了一个树。</p>



<p>以这段文字为例:“<em>猫在吃东西，狗在叫”</em>。为了创建霍夫曼树，我们需要从整个词汇表中计算单词的频率。</p>



<pre class="hljs">word_to_id = {w:i <span class="hljs-keyword">for</span> i, w <span class="hljs-keyword">in</span> enumerate(set(raw_text))}
id_to_word = {i:w <span class="hljs-keyword">for</span> w, i <span class="hljs-keyword">in</span> word_to_id.items()}
word_frequency = {w:raw_text.count(w) <span class="hljs-keyword">for</span> w,i <span class="hljs-keyword">in</span> word_to_id.items()}</pre>



<pre class="hljs">print(word_frequency)</pre>



<pre class="hljs">Output:

{<span class="hljs-string">'and'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'barking'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'cat'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'dog'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'eating'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'is'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'the'</span>: <span class="hljs-number">2</span>}</pre>



<p>下一步是创建一个霍夫曼树。我们的方法是用最不常用的词。在我们的例子中，我们有很多只出现一次的单词，所以我们可以任意选择两个。让我们以“狗”和“和”为例。然后，我们将通过一个父节点连接两个叶节点，并添加频率。</p>





<p>在下一步中，我们将选择另一个最不常用的单词(同样，这个单词只出现一次)，并将它放在总和为2的节点旁边。记住不常用的单词在左边，常用的单词在右边。</p>





<p>同样，我们将继续构建单词，直到我们使用了词汇表中的所有单词。</p>





<p>记住，所有出现频率最低的单词都在底部。</p>



<pre class="hljs">print(Tree.wordid_code)</pre>



<pre class="hljs">Output:
{<span class="hljs-number">0</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
 <span class="hljs-number">1</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
 <span class="hljs-number">2</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
 <span class="hljs-number">3</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
 <span class="hljs-number">4</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
 <span class="hljs-number">5</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
 <span class="hljs-number">6</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]}</pre>



<p>一旦创建了树，我们就可以开始培训了。</p>



<p>在霍夫曼树中，我们不再计算输出嵌入w`。相反，我们尝试使用sigmoid函数来计算在每个叶节点向右转或向左转的概率。</p>



<p><em> p(右| n,c)=σ(h⊤w′n)</em>，其中n是节点，c是上下文。</p>



<p>正如您将在下面的代码中发现的，sigmoid函数用于决定是向右还是向左。同样重要的是要知道所有单词的概率总和应该是1。这确保了H-softmax在词汇表中的所有单词上具有归一化的概率分布。</p>



<pre class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipGramModel</span><span class="hljs-params">(nn.Module)</span>:</span>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, emb_size, emb_dimension)</span>:</span>
       super(SkipGramModel, self).__init__()
       self.emb_size = emb_size
       self.emb_dimension = emb_dimension
       self.w_embeddings = nn.Embedding(<span class="hljs-number">2</span>*emb_size<span class="hljs-number">-1</span>, emb_dimension, sparse=<span class="hljs-keyword">True</span>)
       self.v_embeddings = nn.Embedding(<span class="hljs-number">2</span>*emb_size<span class="hljs-number">-1</span>, emb_dimension, sparse=<span class="hljs-keyword">True</span>)
       self._init_emb()

   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_init_emb</span><span class="hljs-params">(self)</span>:</span>
       initrange = <span class="hljs-number">0.5</span> / self.emb_dimension
       self.w_embeddings.weight.data.uniform_(-initrange, initrange)
       self.v_embeddings.weight.data.uniform_(<span class="hljs-number">-0</span>, <span class="hljs-number">0</span>)

   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, pos_w, pos_v,neg_w, neg_v)</span>:</span>

       emb_w = self.w_embeddings(torch.LongTensor(pos_w))
       neg_emb_w = self.w_embeddings(torch.LongTensor(neg_w))
       emb_v = self.v_embeddings(torch.LongTensor(pos_v))
       neg_emb_v = self.v_embeddings(torch.LongTensor(neg_v))

       score = torch.mul(emb_w, emb_v).squeeze()
       score = torch.sum(score, dim=<span class="hljs-number">1</span>)
       score = F.logsigmoid(<span class="hljs-number">-1</span> * score)
       neg_score = torch.mul(neg_emb_w, neg_emb_v).squeeze()
       neg_score = torch.sum(neg_score, dim=<span class="hljs-number">1</span>)
       neg_score = F.logsigmoid(neg_score)
       
       loss = <span class="hljs-number">-1</span> * (torch.sum(score) + torch.sum(neg_score))
       <span class="hljs-keyword">return</span> loss</pre>



<h3>基于抽样的方法</h3>



<p>基于采样的方法完全消除了softmax层。</p>



<p>我们将讨论两种方法:噪声对比估计和负采样。</p>



<h4>噪声对比估计</h4>



<p>噪声对比估计(NCE)是一种替代softmax层并降低计算成本的近似方法。<strong>它通过将预测问题转换成分类问题</strong>来实现。<a href="https://web.archive.org/web/20230213062731/https://neptune.ai/wp-admin/edit.php?post_type=post"/></p>



<p>这一节将包含大量的数学解释。</p>



<p>NCE采用非标准化多项式函数(即具有多个标签且其输出未通过softmax层的函数)，并将其转换为二元逻辑回归。</p>



<p>为了学习分布从一些特定的上下文(<em> c </em>)中预测目标词(<em>w<sub>t</sub>T3】，我们需要创建两个类:<strong>正</strong>和<strong>负</strong>。正类包含来自训练数据分布的样本，而负类包含来自噪声分布Q的样本，我们分别将它们标记为1和0。噪声分布是训练集的一个<strong>单字分布</strong>。</em></p>



<p>对于给定上下文的每个目标词，我们从分布<em> Q </em>生成样本噪声作为<em> Q(w)，</em>，使得它比来自数据分布<em> P(w | c)的样本更频繁<em> k </em>倍。</em></p>



<p>这两个概率分布可以表示为彼此的和，因为我们有效地从这两个分布中采样单词。因此，</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/be122e2a00cb8c82b7da3e9a09196323.png" alt="" data-original-src="https://web.archive.org/web/20230213062731im_/https://lh4.googleusercontent.com/NgpolYDT84BW7YhAa1IknGMrB1PWhpSs_jrZQuxBXIoatKTNeOkRJCvAGrECVDtRWfMbGetd3oJOYHlvsh0IalbvwnP4vLAYOnmTROFU_u5y5gRLt2CaxV8LjAstTdm2AXPtJbmW"/></figure>



<p>如前所述，NCE是一个二元分类器，由真标签“1”和假标签“0”组成。直觉上，</p>



<p>当y=1时，</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/5e6339ad6f57d3ae3f20ce5976f87079.png" alt="" data-original-src="https://web.archive.org/web/20230213062731im_/https://lh6.googleusercontent.com/sGdUPssy3DNBrzOrhPWmwBKCH8MEHmhI5TnlAfUB0hNsFcsmOq9-zvCSXuJKf_WBOjNOG09s9XqNOWpnI7bOAJ06lK71YSSEniHTxrL3GkdyRvH9a9kIbPEXEA7kmbvkP8TKWLG7"/></figure>



<p>当y=0时，</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/25424f918de092b28f4558d90e82b231.png" alt="" data-original-src="https://web.archive.org/web/20230213062731im_/https://lh4.googleusercontent.com/_H0HpY4xEfs5En3cKUq5SOSima5-g-BgaPcpt8f-IgJj8ZcbaGR4YKp7WMRIJnJBfw6P-MXNosNXLFhYE6W_nIRWkeegOOgHNrcXIkFgM2OQarx6kMSzhjt5xCyyBGZvvEY3YWPk"/></figure>



<p>我们的目标是开发一个具有参数<em> θ </em>的模型，使得给定一个上下文c，其预测概率<em> P(w，c) </em>近似于原始数据分布<em> P <sub> d </sub> (w，c) </em>。</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/4bc4258cb81e9565536337311308f675.png" alt="" data-original-src="https://web.archive.org/web/20230213062731im_/https://lh5.googleusercontent.com/3-3Bt6GUJ9yY6KX0iElM5JixrkTMuaFSvP1TbJ0Zm4tgs1a3Lf32sBT5Q-QGjvx86AIVVekKNdq8Lhr5qPHXspunnRjJOpcIMCX-Ple5GbMMsgLetaXlYy3Rv_M2VZbmxMrwb9m1"/></figure>



<p>通常，噪声分布通过采样来近似。我们通过生成k个噪声样本<em> {wij}: </em>来做到这一点</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/74355b0d6c891b3cac02a4d073c546e8.png" alt="" data-original-src="https://web.archive.org/web/20230213062731im_/https://lh3.googleusercontent.com/ckpUovADOaYURRXRWLX4HOdF3285EHYTnt5WkLirSwx7bVYD7TM6hFttBHWYSVemFoYzFay-O3epv1_u8RhJjsPMEJizjxqEDYeO9KdOgf07CZU7GeWYNl8A9Eisb6mXGLACWxkA"/></figure>



<p>其中<em> Z <sub> θ </sub> (c) </em>是softmax中的一个规格化术语，您记得这是我们试图消除的。我们消除<em> Z <sub> θ </sub> (c) </em>的方法是让它成为一个可学习的参数。本质上，我们将softmax函数从绝对值(即一次又一次对词汇表中的所有单词求和的值)转换为动态值，该值会不断变化以找到更好的值，这是可以学习的。</p>



<p>但是，事实证明，Mnih等人(2013)指出<em> Z <sub> θ </sub> (c) </em>可以固定为1。即使它又是静态的，但它归一化得相当好，Zoph等人(2016)发现<em> Z <sub> θ </sub> (c)=1 </em>产生一个低方差的模型。</p>



<p>我们可以用<em> exp(s <sub> θ </sub> (w | c)) </em>代替<em> P <sub> θ </sub> (w | c) </em>，这样损失函数可以写成:</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/a5d78796639d469f9a2675ecb6ed6433.png" alt="Word embedding loss function" class="wp-image-45603" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230213062731im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Word-embedding-loss-function.png?ssl=1"/></figure>



<p>需要记住的一点是，随着噪声样本数量k的增加，NCE导数越来越接近似然梯度，即归一化模型的softmax函数。</p>



<p>总之，NCE是一种通过将数据分布与噪声分布进行比较来学习数据分布的方式，并且修改学习参数，使得模型<em> P <sub> θ </sub> </em>几乎等于<em> P <sub> d </sub> </em>。</p>



<h4>负采样</h4>



<p>理解NCE是很重要的，因为负抽样是相同的修改版本。这也是一个更简化的版本。</p>



<p>首先，我们了解到，随着我们增加噪声样本k的数量，NCE导数接近似然梯度，或归一化模型的<strong> softmax函数</strong>。</p>



<p>负采样的工作方式是，用1代替噪声，从而消除噪声。直觉上，</p>



<p>当<em> y=1 </em>时，</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/e28946ceb4870794c04ec051cad05d1f.png" alt="" data-original-src="https://web.archive.org/web/20230213062731im_/https://lh5.googleusercontent.com/z0KcilRXj944KPR6ZIgQY6YoFz0ZuvAVnDJexHOjc9GvODw3q-g8cAtASKnwXd_ExrHYfmq1HCThk0fepBJDtS9yYz99Au0k-ysSxwdlpHERlxknYv1K-XV81nHHOmb0yCLMjfjq"/></figure>



<p>在负采样中，我们使用sigmoid函数，因此我们将上述等式转换为:</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/025a44f3a0711c0185ccc638401b8ffb.png" alt="" data-original-src="https://web.archive.org/web/20230213062731im_/https://lh5.googleusercontent.com/QKyKJiX-SNDMXnS6OGvtTJvwsQXI6Y9Z1egn4TzWaxXIWad-Jj1L4owaDkoJsQzkPa9df-kVw3lPKw7MV41gOJJJsshckFpxE-NeF9KwmG4kqzmfeHsezyALtHfMWVYG3bzy71D9"/></figure>



<p>我们知道<em> P <sub> θ </sub> (w | c) </em>被替换为<em> exp(s <sub> θ </sub> (w | c)) </em>。</p>



<p>因此，</p>



<figure class="wp-block-image size-large is-resized"><img decoding="async" loading="lazy" src="../Images/8d1028babb3132abf01d9fdcb433a6fa.png" alt="" class="wp-image-45604" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230213062731im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Word-embeddings-equation.png?resize=345%2C72&amp;ssl=1"/></figure>



<p>这使得等式更短。它必须计算1而不是噪声，因此该方程在计算上变得高效。但是我们为什么要简化NCE呢？</p>



<p>一个原因是我们关心单词向量的高度表示，所以只要模型产生的单词嵌入保持它们的质量，它就可以简化模型。</p>



<p>如果我们用上面的方程代替最终的NCE方程，我们得到:</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/e47477e3146cb8ca501625273d063dea.png" alt="" data-original-src="https://web.archive.org/web/20230213062731im_/https://lh5.googleusercontent.com/8WyiIAno2v_aJChQMfj-pUOIYQMkEiZVdXYDxo3eP-HioENNuitbidDJSBo4V7ZTqEP0a4Tmv1zGA5VTq1effRFYAxOwbZNNIzs72bTfu2UjvMIPYMgSlolDJJbD6owazhcd2NTI"/></figure>



<p>由于<em> log(1)=0 </em>，</p>



<p>因此，</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/8a9670f569490bdd51e0ff0216308f19.png" alt="" data-original-src="https://web.archive.org/web/20230213062731im_/https://lh5.googleusercontent.com/cprQXL7O4NB4LhebEnqxk9Z572nfq0BYRUhXSvgUqz3eCeBQhQ5bEhriZ_22vkKc3S92OfHyM8A89ISXV92Pnkb_FqbsutPEOY8ZhPrpfgj_4wx4Gj5wmgCfB1JayvalmyPh90Th"/></figure>



<p>因为我们处理的是sigmoid函数。</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/582347a171976cab52067d79818922eb.png" alt="" data-original-src="https://web.archive.org/web/20230213062731im_/https://lh6.googleusercontent.com/ef6rfAjapAVOHVk_Z3z9MIqSOhZta4vTBJOkRSi7ArwZYApqTA7kMk-Dqx4c4dQUg6Xud6YQeKdypPjdXC_1Zvn1urrWeqsAJG8to44I6r_KxA_QkfYVfEx32WnmYDh7xWlMWv6C"/></figure>



<p>我们可以将上面的等式修改为:</p>



<figure class="wp-block-image size-large is-resized"><img decoding="async" loading="lazy" src="../Images/9253addd5ae0212b41d8feb52794e8ea.png" alt="" class="wp-image-45605" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230213062731im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Word-embeddings-equation-2.png?resize=551%2C75&amp;ssl=1"/></figure>



<p>(以下是<a href="https://web.archive.org/web/20230213062731/https://colab.research.google.com/drive/16lUNXMai2EG7Uq0VXFFE_cu3TSv8vTr5?usp=sharing" target="_blank" rel="noreferrer noopener nofollow">笔记本</a>和<a href="https://web.archive.org/web/20230213062731/https://arxiv.org/pdf/1410.8251.pdf" target="_blank" rel="noreferrer noopener nofollow">原始论文</a>的链接)</p>



<h2 id="h-final-thoughts-and-conclusion">最后的想法和结论</h2>



<p>我们探索了用于NLP或机器翻译的基于神经的建模的发展。我们讨论了单词嵌入，这是一种在词汇表中寻找语义、句法和线性关系的方法。虽然前面提到的一些方法不再使用，但它们奠定了该学科的基础，并使进一步的学习更容易。</p>



<p>我们看到了Begio和他的团队如何通过他们的单词嵌入方法引入神经语言模型来找到更好的表示，随后是Mikolov和他的团队如何修改Begio的方法，并通过删除隐藏层引入了一种计算成本更低的方法。虽然word2vec模型是一个简单的模型，但是一旦词汇表变大，它的计算开销就会变大。</p>



<p>引入了不同的方法来纠正复杂性问题，我们在本文后面看到的三个模型通过<strong> softmax函数</strong>解决了这个问题。</p>



<p>最后，我们看到了负采样如何超越所有两种方法(分层softmax和NCE ),并使用更有效的近似技术修改了word2vec模型，该技术可以捕获更好的表示，如语义、语法，并保留线性表示，同时降低了计算成本。</p>



<p>单词嵌入为NLP的研究和开发打开了新的大门。这些模型运行良好，但是它们仍然缺乏概念上的理解。直到2018年，彼得斯等人。艾尔。引入了语言模型中的ELMo:embedding，它通过单词嵌入将寻找<strong>上下文表示</strong>的缺失部分联系起来。</p>



<p>为了更好的理解和清晰，查看每个主题的笔记本。</p>



<h2 id="h-resources">资源</h2>




        </div>
        
    </div>    
</body>
</html>