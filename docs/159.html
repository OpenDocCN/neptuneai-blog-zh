<html>
<head>
<title>ARIMA &amp; SARIMA: Real-World Time Series Forecasting </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>ARIMA和萨里玛:现实世界的时间序列预测</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/arima-sarima-real-world-time-series-forecasting-guide#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/arima-sarima-real-world-time-series-forecasting-guide#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p>时间序列和预测一直是统计学和数据科学中的一些关键问题。当按照具有时间限制的属性(如天数、月数和年数)对数据进行采样时，数据就变成了一个时间序列，这给了它一个隐含的顺序。预测就是我们获取数据并预测未来值。</p>



<p>ARIMA和萨里玛都是预测的<a href="https://web.archive.org/web/20221206094226/https://towardsdatascience.com/forecasting-with-machine-learning-models-95a6b6579090" target="_blank" rel="noreferrer noopener nofollow">算法。<strong> ARIMA </strong>考虑过去的值(自回归，移动平均)并基于此预测未来值。<strong> SARIMA </strong>同样使用过去的值，但也考虑了任何季节性模式。由于萨里玛引入了季节性作为参数，它在预测包含周期的复杂数据空间方面明显比ARIMA更强大。</a></p>







<p>在博客的后面，我们将探索:</p>



<ol><li>ARIMA<ul><li>它是什么以及它如何预测</li><li>用ARIMA预测美国GDP的例子</li></ul></li><li>萨里玛<ul><li>它是什么以及它如何预测</li><li>预测用电量的示例</li></ul></li><li>两种模式的优缺点</li><li>ARIMA和萨里玛的真实使用案例</li></ol>



<p>在我们进入算法之前，有一个关于数据处理的重要部分，在开始预测之旅之前，你应该警惕。</p>



<h2 id="h-data-preprocessing-for-time-series-forecasting">时间序列预测的数据预处理</h2>



<p>时间序列数据很乱。从简单的滚动平均到LSTMs的预测模型要求数据是干净的。因此，在进行预测之前，这里有一些你可以使用的技巧。</p>



<p><em>注意:这个数据预处理步骤是通用的，旨在让读者强调它，因为现实世界的项目涉及许多清理和准备工作。</em></p>



<ul><li><strong>去趋势性/平稳性</strong>:在预测之前，我们希望我们的时间序列变量是均值-方差平稳的。这意味着一个模型的统计特性不会因为取样时间的不同而改变。建立在静态数据上的模型通常更稳健。这可以通过使用差分来实现。</li><li><strong>异常检测:</strong>数据中出现的任何异常值都可能扭曲预测结果，因此在继续预测之前识别异常值并使其正常化通常被认为是一种良好的做法。你可以在这里关注这个<a href="/web/20221206094226/https://neptune.ai/blog/anomaly-detection-in-time-series" target="_blank" rel="noreferrer noopener">博客，在这里我详细解释了异常检测算法</a>。</li><li><strong>检查采样频率:</strong>这是检查采样规律性的重要步骤。在应用任何建模技术之前，必须对不规则数据进行估算或使其一致，因为不规则采样会破坏时间序列的完整性，并且与模型不匹配。</li><li><strong>缺失数据:</strong>有时，某些日期时间值可能会有缺失数据，这需要在建模之前解决。例如，缺少值的时间序列数据如下所示:</li></ul>



<div class="wp-block-image"><figure class="aligncenter size-full"><img decoding="async" src="../Images/128e46dade64968dcae23ccacdab521d.png" alt="Missing data in time series " class="wp-image-65628" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206094226im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Time-series-missing-data.png?ssl=1"/><figcaption>Missing data in time series | <a href="https://web.archive.org/web/20221206094226/https://jagan-singhh.medium.com/missing-data-in-time-series-5dcf19b0f40f" target="_blank" rel="noreferrer noopener nofollow">Source</a></figcaption></figure></div>



<p>现在，让我们继续讨论模型。</p>



<h2 id="h-arima">ARIMA</h2>



<p>ARIMA模型是一类利用历史值预测未来值的线性模型。ARIMA代表<strong>自回归综合移动平均，</strong>每种技术都有助于最终预测。我们一个一个来了解吧。</p>



<h3>自回归(AR)</h3>



<p>在自回归模型中，我们使用该变量过去值的线性组合来预测感兴趣的变量。术语“自回归”表示它是变量对自身的回归。也就是说，我们使用目标变量的滞后值作为输入变量来预测未来的值。p阶的自回归模型将看起来像:</p>



<p class="has-text-align-center">m<sub>t</sub>=<sub>0</sub>+<sub>1</sub>m<sub>t-1</sub>+<sub>2</sub>m<sub>t-2</sub>+<sub>3</sub>m<sub>t-3</sub>+…+<sub>p</sub>m<sub>t-p</sub></p>



<p>在上式中，<em> m </em>的当前观测值是其过去<em> p </em>值的线性函数。[ 0，p]是训练后确定的回归系数。确定<em> p </em>的最优值有一些标准方法，其中之一是分析<strong>自相关</strong>和<strong>偏自相关</strong>函数图。</p>



<p>自相关函数(ACF)是同一变量的当前值和过去值之间的相关性。除了直接影响之外，它还考虑了价值随时间推移而产生的翻译效应。例如，两天前的石油价格会影响一天前的价格，并最终影响今天的价格。但是2天前的石油价格也可能对ACF测量的今天有影响。</p>



<p>另一方面，部分自相关(PACF)仅测量过去值和当前值之间的直接相关性。例如，PACF将只测量两天前的石油价格对今天的影响，而没有平移效应。</p>



<p>ACF和PACF图帮助我们确定过去值的相关性，进而帮助我们推断AR中的<em> p </em>。浏览<a href="https://web.archive.org/web/20221206094226/https://otexts.com/fpp2/non-seasonal-arima.html#acf-and-pacf-plots" target="_blank" rel="noreferrer noopener nofollow">这里的</a>，深入了解如何推导p (AR)和q(MA)的值。</p>



<h3>综合(一)</h3>



<p>Integrated表示为了使数据稳定而必须应用的任何差异。可以对数据运行dickey-fuller测试(代码如下)来检查稳定性，然后用不同的差异因子进行实验。差异因子d=1表示滞后，即mt-mt-1。让我们看一下原始数据与差异数据的对比图。</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img decoding="async" src="../Images/98dadf1302cbc71d69d38cfe7a578e72.png" alt="Arima sarima catfish sales 1" class="wp-image-65629" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206094226im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Arima-sarima-catfish-sales-1.png?ssl=1"/><figcaption><em>Original Data | Source: Author</em></figcaption></figure></div>



<div class="wp-block-image"><figure class="aligncenter size-full"><img decoding="async" src="../Images/079c614c07633aca515cb94c994263ee.png" alt="Arima sarima catfish sales 1" class="wp-image-65630" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206094226im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Arima-sarima-catfish-sales-2.png?ssl=1"/><figcaption><em>After applying d=1 | Source: Author</em></figcaption></figure></div>



<p>他们之间的区别是显而易见的。差分后，我们可以看到它明显比原始数据更稳定，并且多年来平均值和方差大致一致。我们可以使用下面的代码进行dickey-fuller测试。</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_stationarity</span><span class="hljs-params">(ts)</span>:</span>
    dftest = adfuller(ts)
    adf = dftest[<span class="hljs-number">0</span>]
    pvalue = dftest[<span class="hljs-number">1</span>]
    critical_value = dftest[<span class="hljs-number">4</span>][<span class="hljs-string">'5%'</span>]
    <span class="hljs-keyword">if</span> (pvalue &lt; <span class="hljs-number">0.05</span>) <span class="hljs-keyword">and</span> (adf &lt; critical_value):
        print(<span class="hljs-string">'The series is stationary'</span>)
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">'The series is NOT stationary'</span>)</pre>



<h3>移动平均线</h3>



<p>移动平均模型在类似回归的模型中使用过去的预测误差而不是过去的值来预测未来值。移动平均模型可由以下等式表示:</p>



<p class="has-text-align-center">m<sub>t</sub>=<sub>0</sub>+<sub>1</sub>e<sub>t-1</sub>+<sub>2</sub>e<sub>t-2</sub>+<sub>3</sub>e<sub>t-3</sub>+…+<sub>q</sub>e<sub>t-q</sub></p>



<p>这就是所谓的<strong> MA(q) </strong>模型。在上式中，<em> e </em>被称为<em>误差</em>，它代表模型和目标变量之间的随机剩余偏差。因为<em> e </em>只能在拟合模型后确定，并且因为它也是一个参数，所以在这种情况下<em> e </em>是一个<strong>不可观察的参数</strong>。因此，为了求解MA方程，使用像最大似然估计这样的迭代技术来代替OLS。</p>



<p>既然我们已经了解了ARIMA是如何工作的，让我们深入一个例子，看看ARIMA是如何应用于时间序列数据的。</p>



<h3>实施ARIMA</h3>



<p>对于实现，我选择了从1996年到2008年的<a href="https://web.archive.org/web/20221206094226/https://www.kaggle.com/datasets/yekahaaagayeham/time-series-toy-data-set" target="_blank" rel="noreferrer noopener nofollow">鲶鱼销售数据。我们将把上面学到的技术应用到这个数据集，并观察它们的实际应用。尽管数据不需要大量清理，并且处于待分析的读取状态，但您可能必须对数据集应用清理技术。</a></p>



<p>不幸的是，我们不能复制每一个场景，因为清洁方法是高度主观的，也取决于团队的要求。但是这里学到的技术可以在清理后直接应用到您的数据集。</p>



<p>先说导入必备模块。</p>



<h4>导入依赖关系</h4>



<pre class="hljs"><span class="hljs-keyword">from</span> IPython.display <span class="hljs-keyword">import</span> display

<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
pd.set_option(<span class="hljs-string">'display.max_rows'</span>, <span class="hljs-number">15</span>)
pd.set_option(<span class="hljs-string">'display.max_columns'</span>, <span class="hljs-number">500</span>)
pd.set_option(<span class="hljs-string">'display.width'</span>, <span class="hljs-number">1000</span>)

<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> timedelta
<span class="hljs-keyword">from</span> pandas.plotting <span class="hljs-keyword">import</span> register_matplotlib_converters

register_matplotlib_converters()

<span class="hljs-keyword">from</span> statsmodels.tsa.seasonal <span class="hljs-keyword">import</span> seasonal_decompose
<span class="hljs-keyword">from</span> statsmodels.tsa.arima_model <span class="hljs-keyword">import</span> ARIMA
<span class="hljs-keyword">from</span> statsmodels.tsa.statespace.sarimax <span class="hljs-keyword">import</span> SARIMAX
<span class="hljs-keyword">from</span> statsmodels.tsa.stattools <span class="hljs-keyword">import</span> adfuller
<span class="hljs-keyword">from</span> statsmodels.graphics.tsaplots <span class="hljs-keyword">import</span> plot_acf, plot_pacf
<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns
sns.set(style=<span class="hljs-string">"whitegrid"</span>)

<span class="hljs-keyword">import</span> warnings
warnings.filterwarnings(<span class="hljs-string">'ignore'</span>)

RANDOM_SEED = np.random.seed(<span class="hljs-number">0</span>)</pre>



<p>这些是每个数据科学家都熟悉的不言自明的模块。设置RANDOM_SEED以使代码具有相同的结果是一个很好的做法。</p>



<p>接下来，我们将导入并绘制时间序列数据</p>



<h4>提取-转换-加载(ETL)</h4>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parser</span><span class="hljs-params">(s)</span>:</span>
    <span class="hljs-keyword">return</span> datetime.strptime(s, <span class="hljs-string">'%Y-%m-%d'</span>)

catfish_sales = pd.read_csv(<span class="hljs-string">'catfish.csv'</span>, parse_dates=[<span class="hljs-number">0</span>], index_col=<span class="hljs-number">0</span>, date_parser=parser)

catfish_sales = catfish_sales.asfreq(pd.infer_freq(catfish_sales.index))


start_date = datetime(<span class="hljs-number">1996</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)
end_date = datetime(<span class="hljs-number">2008</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)
lim_catfish_sales = catfish_sales[start_date:end_date]


plt.figure(figsize=(<span class="hljs-number">14</span>,<span class="hljs-number">4</span>))
plt.plot(lim_catfish_sales)
plt.title(<span class="hljs-string">'Catfish Sales in 1000s of Pounds'</span>, fontsize=<span class="hljs-number">20</span>)
plt.ylabel(<span class="hljs-string">'Sales'</span>, fontsize=<span class="hljs-number">16</span>)</pre>



<p>为了简单起见，我将数据限制在1996-2008年。上述代码生成的图如下所示:</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img decoding="async" src="../Images/4d37eff52ce238637a7c242d9b5ab8d4.png" alt="Arima sarima catfish sales 3" class="wp-image-65633" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206094226im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Arima-sarima-catfish-sales-3.png?ssl=1"/><figcaption><em>Catfish sales | Source: Author</em></figcaption></figure></div>



<p>第一印象是数据中存在明确的趋势和季节性。让我们做一个STL分解，以便更好地理解。</p>



<h4>STL分解</h4>



<pre class="hljs">plt.rc(<span class="hljs-string">'figure'</span>,figsize=(<span class="hljs-number">14</span>,<span class="hljs-number">8</span>))
plt.rc(<span class="hljs-string">'font'</span>,size=<span class="hljs-number">15</span>)

result = seasonal_decompose(lim_catfish_sales,model=<span class="hljs-string">'additive'</span>)
fig = result.plot()</pre>



<p>结果图如下所示:</p>







<p>思考要点:</p>



<ol><li>可以看到6个月和12个月的季节性模式</li><li>上升和下降的趋势很明显</li></ol>



<p>让我们看看ACF和PACF图，了解一下p和q值</p>



<h4>ACF和PACF图</h4>



<pre class="hljs">plot_acf(lim_catfish_sales[<span class="hljs-string">'Total'</span>], lags=<span class="hljs-number">48</span>);
plot_pacf(lim_catfish_sales[<span class="hljs-string">'Total'</span>], lags=<span class="hljs-number">30</span>);</pre>



<p>上述代码的输出绘制了ACF和PACF:</p>



<div class="wp-block-image"><figure class="aligncenter size-full is-resized"><img decoding="async" loading="lazy" src="../Images/15b27c23fcaaba2eb3b7ee0bd12dbcab.png" alt="Autocorrelation plot for Catfish data" class="wp-image-65638" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206094226im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Autocorrelation-plot-for-Catfish-data.png?resize=831%2C484&amp;ssl=1"/><figcaption><em>Autocorrelation plot for Catfish data</em></figcaption></figure></div>



<div class="wp-block-image"><figure class="aligncenter"><img decoding="async" src="../Images/114fecb4120e0327648d23dd51959339.png" alt="Partial autocorrelation plot for catfish data" data-original-src="https://web.archive.org/web/20221206094226im_/https://lh4.googleusercontent.com/2HjZi09y0R9D9uNPdctwArCQn3e7L-ip0UGruPPt8GymA8iaLhOaPFB_yJ9yacM412Vcck6GOWajpyKonAXbGkXa8P5NCX8VltnUx1gEe_6t03AmXlXu9g4rwXQHtsK8_MOAy5SOn8bN51B4tg"/><figcaption><em>Partial autocorrelation plot for Catfish data</em></figcaption></figure></div>



<p>思考要点:</p>



<ol><li>ACF在6个月和12个月时有一个显著的峰值</li><li>PACF几乎是正弦曲线</li></ol>



<p>差分因子d应保持为1，因为有明确的趋势和非平稳数据。p可以用值6和12来测试。</p>



<h4>安装ARIMA</h4>



<p>我们将使用statsmodels模块来实现和使用ARIMA。为此，我们从statsmodels中导入了ARIMA类。现在，让我们用上一节中讨论的参数来拟合。</p>



<pre class="hljs">arima = ARIMA(lim_catfish_sales[<span class="hljs-string">'Total'</span>], order=(<span class="hljs-number">12</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))
predictions = arima.fit().predict()</pre>



<p>正如你在上面注意到的，我从(p，d，q)的(12，1，1)开始，就像我们在ACF和PACF图中看到的那样。</p>



<p><em>注意:使用算法模块(如scikit-learn)非常方便，您会很高兴知道statsmodels是经常使用的库之一。</em></p>







<p>让我们看看我们的预测如何与原始数据相比较。</p>



<h4>可视化结果</h4>



<pre class="hljs">plt.figure(figsize=(<span class="hljs-number">16</span>,<span class="hljs-number">4</span>))
plt.plot(lim_catfish_sales.diff(), label=<span class="hljs-string">"Actual"</span>)
plt.plot(predictions, label=<span class="hljs-string">"Predicted"</span>)
plt.title(<span class="hljs-string">'Catfish Sales in 1000s of Pounds'</span>, fontsize=<span class="hljs-number">20</span>)
plt.ylabel(<span class="hljs-string">'Sales'</span>, fontsize=<span class="hljs-number">16</span>)
plt.legend()</pre>



<p>上述代码的输出将为您提供预测和实际数据的对比图。</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img decoding="async" src="../Images/34707e667b0db4a39e01107d4a58c478.png" alt="arima comparative plot" class="wp-image-65640" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206094226im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Arima-comparative-plot.png?ssl=1"/><figcaption><em>A comparative plot of predictions and the actual data</em></figcaption></figure></div>



<p>您可以在这里看到，该模型没有真正赶上某些峰值，但很好地捕捉到了数据的本质。我们可以用更多的p，d，q值进行实验，以更好地概括模型，并确保它不会过度拟合。</p>



<p>尝试和优化是一种方法，但你也可以使用自动ARIMA。它本质上为您完成了繁重的工作，并为您调整了超参数。这个<a href="https://web.archive.org/web/20221206094226/https://towardsdatascience.com/time-series-forecasting-using-auto-arima-in-python-bb83e49210cd" target="_blank" rel="noreferrer noopener nofollow">博客</a>是汽车ARIMA的一个很好的起点。</p>



<p>请记住，参数的可解释性将是您在处理自动ARIMA时必须处理的事情，并确保它不会被转换为黑盒，因为预测模型必须在部署之前进行治理。因此，能够解释参数值及其贡献是一种很好的做法。</p>



<h2 id="h-sarima">萨里玛</h2>



<p>萨里玛代表季节性ARIMA，它包括季节性对预测的贡献。季节性的重要性是显而易见的，而ARIMA未能含蓄地概括这一信息。</p>



<p>模型的自回归(AR)、综合(I)和移动平均(MA)部分与ARIMA模型相同。季节性的加入增加了SARIMA模型的稳健性。它表示为:</p>







<p>其中m是每年的观察次数。我们用大写符号表示模型的季节性部分，用小写符号表示模型的非季节性部分。</p>



<p>与ARIMA相似，模型季节性部分的P、D、Q值可以从数据的ACF和PACF图中推导出来。让我们为相同的鲶鱼销售模型实现SARIMA。</p>



<h3>实施SARIMA</h3>



<p>ETL和依赖项将保持与ARIMA相同，因此我们将直接跳到建模部分。</p>



<h4>安装SARIMA</h4>



<pre class="hljs">sarima = SARIMAX(lim_catfish_sales[<span class="hljs-string">'Total'</span>],
                order=(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),
                seasonal_order=(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">12</span>))
predictions = sarima.fit().predict()</pre>



<p>我尝试对非季节性部分取1，1，1，对季节性部分取1，1，0，12，因为ACF显示了6个月和12个月的滞后相关性。让我们看看结果如何。</p>



<h4>可视化结果</h4>



<pre class="hljs">plt.figure(figsize=(<span class="hljs-number">16</span>,<span class="hljs-number">4</span>))
plt.plot(lim_catfish_sales, label=<span class="hljs-string">"Actual"</span>)
plt.plot(predictions, label=<span class="hljs-string">"Predicted"</span>)
plt.title(<span class="hljs-string">'Catfish Sales in 1000s of Pounds'</span>, fontsize=<span class="hljs-number">20</span>)
plt.ylabel(<span class="hljs-string">'Sales'</span>, fontsize=<span class="hljs-number">16</span>)
plt.legend()</pre>



<div class="wp-block-image"><figure class="aligncenter size-full"><img decoding="async" src="../Images/0b4843e595433b623612fee7a5214f02.png" alt="Sarima comparative plot" class="wp-image-65643" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206094226im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Sarima-comparative-plot.png?ssl=1"/><figcaption><em>A comparative plot of predictions and the actual data</em></figcaption></figure></div>



<p>正如你所看到的，在开始模型，努力适应可能是因为偏离路线初始化，但它很快学会了正确的路径。与ARIMA相比，拟合度相当好，这表明萨里玛可以更好地了解季节性，如果它出现在数据中，那么尝试萨里玛是有意义的。</p>



<h2 id="h-pros-and-cons-of-arima-and-sarima-models">ARIMA和萨里玛模式的利与弊</h2>



<p>由于这两种算法的线性性质，它们非常方便，并在行业中用于实验和理解数据，创建基线预测分数。如果用滞后值(p，d，q)调整正确，他们可以表现得更好。这两种算法的简单和可解释的本质使它们成为分析师和数据科学家的首选。然而，与ARIMA和萨里玛大规模合作有利也有弊。让我们来讨论这两个问题:</p>



<h3>ARIMA和萨里玛的优点</h3>



<ul><li>易于理解和解释:你的队友和同事会欣赏的一件事是模型的简单性和可解释性。在保持结果质量的同时关注这两点将有助于与利益相关者进行演示。</li><li><strong>有限变量</strong>:超参数较少，因此如果模型投入生产，配置文件将易于维护。</li></ul>



<h3>ARIMA和萨里玛的缺点</h3>



<ul><li><strong>指数时间复杂度:</strong>当p和q的值增加时，有同样多的系数要拟合，因此如果p和q高，时间复杂度增加。这使得这两种算法很难投入生产，并使数据科学家研究Prophet和其他算法。同样，这也取决于数据集的复杂程度。</li><li><strong>复杂数据:</strong>您的数据可能过于复杂，没有p和q的最优解。尽管ARIMA和萨里玛失败的可能性极小，但如果发生这种情况，您可能不得不另寻他处。</li><li><strong>所需数据量:</strong>这两种算法都需要大量的数据来处理，尤其是在数据是季节性的情况下。例如，使用三年的历史需求可能不足以做出好的预测(短生命周期产品)。</li></ul>







<h2 id="h-real-world-use-cases-of-arima-and-sarima">ARIMA和萨里玛的真实使用案例</h2>



<p>SARIMA萨里玛是最流行的计量经济学模型，用于预测股票价格、<a href="https://web.archive.org/web/20221206094226/https://journals.sagepub.com/doi/10.1177/1847979018808673" target="_blank" rel="noreferrer noopener nofollow">需求预测</a>，甚至传染病的传播。当潜在机制未知或过于复杂时，例如股票市场，或不完全已知时，例如零售，通常最好应用ARIMA或类似的统计模型，而不是像RNNs这样复杂的深度算法。</p>



<p>然而，在某些情况下，应用ARIMA可以得到相同的结果。</p>



<p>以下是一些使用SARIMA萨里玛的策划文件:</p>



<ol><li><a href="https://web.archive.org/web/20221206094226/https://journals.sagepub.com/doi/full/10.1177/0972150920988653" target="_blank" rel="noreferrer noopener nofollow">ARIMA模型在预测印度新冠肺炎疫情动态中的应用</a>:这篇研究论文利用ARIMA预测了印度的新冠肺炎病例数。在这种情况下，利用ARIMA的缺点是，它只利用过去的值来预测未来。但是新冠肺炎会随着时间的推移而改变形状，它取决于除了过去的价值观之外的许多其他行为因素，这是ARIMA无法捕捉到的。</li><li><a href="https://web.archive.org/web/20221206094226/https://www.mdpi.com/2073-8994/11/2/240" target="_blank" rel="noreferrer noopener nofollow">预测日平均和月平均全球太阳辐射的时间序列ARIMA模型:韩国首尔的案例研究</a>:这是一项基于韩国气象局37年来使用s ARIMA获得的每小时太阳辐射数据预测韩国太阳辐射的研究。</li><li><a href="https://web.archive.org/web/20221206094226/https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4872983/" target="_blank" rel="noreferrer noopener nofollow">时间序列中ARIMA模型的疾病管理</a>:利用SARIMA萨里玛模型的广泛适用性，在疾病管理中使用ARIMA的另一个例子。研究论文触及了ARIMA的一些真实使用案例。例如，新加坡的一家医院准确预测了SARS流行期间3天内他们需要的病床数量。</li><li><a href="https://web.archive.org/web/20221206094226/https://journals.sagepub.com/doi/full/10.1177/1847979018808673" target="_blank" rel="noreferrer noopener nofollow">使用ARIMA模型预测需求</a>:这个用例主要使用ARIMA对一家食品公司的需求进行建模和预测。</li></ol>



<p>说到这个行业，这里有一篇关于优步预测的好文章。</p>



<p>当问题陈述仅限于过去的值时，无论是预测医院床位、COVID病例还是预测需求，您都会经常发现使用SARIMA萨里玛。然而，当在预测中有其他因素要考虑时，例如静态属性，缺点就出现了。留意你正在处理的问题陈述，如果这些情况发生在你身上，那么尝试使用其他方法，如<a href="https://web.archive.org/web/20221206094226/https://robjhyndman.com/papers/Theta.pdf" target="_blank" rel="noreferrer noopener nofollow"> Theta </a>，QRF(分位数回归森林)，Prophet，RNNs。</p>



<h2 id="h-conclusion-and-final-notes">结论和最后说明</h2>



<p>你已经到达终点了！在这篇博客中，我们详细讨论了ARIMA和萨里玛，以及他们在行业研究中的应用和重要性。它们的简单性和健壮性使它们成为建模和预测的顶级竞争者。然而，在现实世界的用例中处理它们时，有一些事情需要记住:</p>



<ol><li>增加p，q可以成倍增加训练的时间复杂度。因此，建议先推导出它们的值，然后进行实验。</li><li>他们容易过度适应。因此，请确保您设置了正确的超参数，并在进入生产之前进行验证。</li></ol>



<p>我这边就这样。请继续学习，并关注更多内容！再见！</p>



<h3>参考</h3>



<ol><li><a href="/web/20221206094226/https://neptune.ai/blog/time-series-prediction-vs-machine-learning" target="_blank" rel="noreferrer noopener">https://Neptune . ai/blog/time-series-prediction-vs-machine-learning</a></li><li><a href="https://web.archive.org/web/20221206094226/https://otexts.com/fpp2/arima.html" target="_blank" rel="noreferrer noopener nofollow">https://otexts.com/fpp2/arima.html</a></li><li><a href="https://web.archive.org/web/20221206094226/https://towardsdatascience.com/understanding-arima-time-series-modeling-d99cd11be3f8" target="_blank" rel="noreferrer noopener nofollow">https://towards data science . com/understanding-ARIMA-time-series-modeling-d 99 CD 11 be 3 f 8</a></li><li><a href="https://web.archive.org/web/20221206094226/https://towardsdatascience.com/understanding-sarima-955fe217bc77" target="_blank" rel="noreferrer noopener nofollow">https://towards data science . com/understanding-sa Rima-955 Fe 217 BC 77</a></li><li><a href="/web/20221206094226/https://neptune.ai/blog/anomaly-detection-in-time-series">https://neptune.ai/blog/anomaly-detection-in-time-series</a></li><li><a href="https://web.archive.org/web/20221206094226/https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.html" target="_blank" rel="noreferrer noopener nofollow">https://www . stats models . org/dev/generated/stats models . TSA . statespace . sarimax . sarimax . html</a></li><li><a href="https://web.archive.org/web/20221206094226/https://otexts.com/fpp2/seasonal-arima.html" target="_blank" rel="noreferrer noopener nofollow">https://otexts.com/fpp2/seasonal-arima.html</a></li><li><a href="https://web.archive.org/web/20221206094226/https://towardsdatascience.com/time-series-forecasting-using-auto-arima-in-python-bb83e49210cd" target="_blank" rel="noreferrer noopener nofollow">https://towards data science . com/time-series-forecasting-using-auto-ARIMA-in-python-bb83e 49210 CD</a></li><li><a href="https://web.archive.org/web/20221206094226/https://towardsdatascience.com/time-series-from-scratch-autocorrelation-and-partial-autocorrelation-explained-1dd641e3076f" target="_blank" rel="noreferrer noopener nofollow">https://towards data science . com/time-series-from scratch-自相关-和-部分自相关-解释-1dd641e3076f </a></li><li><a href="https://web.archive.org/web/20221206094226/https://eng.uber.com/forecasting-introduction/" target="_blank" rel="noreferrer noopener nofollow">https://eng.uber.com/forecasting-introduction/</a></li><li><a href="https://web.archive.org/web/20221206094226/https://www.capitalone.com/tech/machine-learning/understanding-arima-models/" target="_blank" rel="noreferrer noopener nofollow">https://www . capital one . com/tech/machine-learning/understanding-ARIMA-models/</a></li><li><a href="https://web.archive.org/web/20221206094226/https://medium.com/analytics-vidhya/why-you-should-not-use-arima-to-forecast-demand-196cc8b8df3d" target="_blank" rel="noreferrer noopener nofollow">https://medium . com/analytics-vid hya/why-you-should-not-use-ARIMA-to-forecast-demand-196 cc 8 b 8d f3d</a></li></ol>



<p/>
        </div>
        
    </div>    
</body>
</html>