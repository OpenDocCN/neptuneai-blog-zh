<html>
<head>
<title>Predicting Stock Prices Using Machine Learning </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用机器学习预测股票价格</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/predicting-stock-prices-using-machine-learning#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/predicting-stock-prices-using-machine-learning#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p>众所周知，股票市场是不稳定的，动态的，非线性的。由于多种(宏观和微观)因素，如政治、全球经济状况、意外事件、公司财务表现等，准确的股价预测极具挑战性。</p>



<p>但是，所有这些也意味着有大量的数据可以从中发现模式。因此，金融分析师、研究人员和数据科学家不断探索分析技术，以检测股市趋势。这就产生了<a href="https://web.archive.org/web/20230125184217/https://en.wikipedia.org/wiki/Algorithmic_trading" target="_blank" rel="noreferrer noopener nofollow">算法交易</a>的概念，它使用自动化、预编程的交易策略来执行订单。</p>







<p/>



<p>在本文中，我们将使用传统的量化金融方法和机器学习算法来预测股票走势。我们将讨论以下主题:</p>



<ul>
<li>股票分析:基本面与技术面分析</li>



<li>作为时间序列数据的股票价格及相关概念</li>



<li>用移动平均技术预测股票价格</li>



<li>LSTMs简介</li>



<li>用LSTM模型预测股票价格</li>



<li>对新方法的最终想法，如ESN</li>
</ul>



<p>免责声明:本项目/文章无意提供金融、交易和投资建议。不保证模型的准确性。在使用本文介绍的方法或准则做出任何投资决定之前，受众应进行尽职调查。</p>



<h2 id="h-stock-analysis-fundamental-analysis-vs-technical-analysis">股票分析:基本面分析与技术面分析</h2>



<p>说到股票，基本面分析和技术分析是市场分析的两个极端。</p>



<ul>
<li>基本面分析(你可以在这里阅读更多信息<a href="https://web.archive.org/web/20230125184217/https://www.investopedia.com/terms/f/fundamentalanalysis.asp#:~:text=Fundamental%20analysis%20(FA)%20is%20a,related%20economic%20and%20financial%20factors.&amp;text=The%20end%20goal%20is%20to,security%20is%20undervalued%20or%20overvalued." target="_blank" rel="noreferrer noopener nofollow">):</a><ul>
<li>通过检查公司的内在价值来评估公司的股票，包括但不限于有形资产、财务报表、管理有效性、战略计划和消费者行为；基本上是一个公司的所有基本要素。</li>



<li>作为长期投资的相关指标，基本面分析依赖于历史和当前数据来衡量收入、资产、成本、负债等。</li>



<li>一般来说，基本面分析的结果不会随着短期消息而改变。</li>
</ul>
</li>



<li>技术分析(你可以在这里了解更多信息<a href="https://web.archive.org/web/20230125184217/https://www.investopedia.com/terms/t/technicalanalysis.asp" target="_blank" rel="noreferrer noopener nofollow">):</a><ul>
<li>分析股票市场活动的可测量数据，如股票价格、历史回报和历史交易量；即可以识别交易信号和捕捉股票市场运动模式的定量信息。</li>



<li>像基本面分析一样，技术分析侧重于历史数据和当前数据，但它主要用于短期交易。</li>



<li>由于其短期性，技术分析结果很容易受到消息的影响。</li>



<li>流行的技术分析方法包括移动平均线(MA)，<a href="https://web.archive.org/web/20230125184217/https://www.investopedia.com/trading/support-and-resistance-basics/" target="_blank" rel="noreferrer noopener nofollow">支撑位和阻力位</a>，以及<a href="https://web.archive.org/web/20230125184217/https://www.investopedia.com/terms/t/trendline.asp" target="_blank" rel="noreferrer noopener nofollow">趋势线和通道</a>。</li>
</ul>
</li>
</ul>



<p>在我们的练习中，我们将只看技术分析，重点是简单的移动平均线和指数移动平均线技术来预测股票价格。此外，我们将利用LSTM(长短期记忆)，一个时间序列的深度学习框架，来建立一个预测模型，并将其性能与我们的技术分析进行比较。</p>



<p>如免责声明所述，股票交易策略不在本文讨论范围之内。我使用交易/投资术语只是为了帮助你更好地理解分析，但这不是财务建议。我们将使用这样的术语:</p>







<h2 id="h-stock-prices-as-time-series-data">作为时间序列数据的股票价格</h2>



<p>尽管存在波动，股票价格并不只是随机产生的数字。因此，它们可以被分析为一系列<a href="https://web.archive.org/web/20230125184217/https://en.wikipedia.org/wiki/Discrete_time_and_continuous_time" target="_blank" rel="noreferrer noopener nofollow">离散时间</a>数据；换句话说，在连续时间点(通常是每天)进行的时间序列观察。<a href="/web/20230125184217/https://neptune.ai/blog/time-series-prediction-vs-machine-learning" target="_blank" rel="noreferrer noopener">时间序列预测</a>(根据历史值预测未来值)非常适用于股票预测。</p>



<p>由于时间序列数据的序列性质，我们需要一种方法来聚合这种信息序列。在所有潜在的技术中，最直观的是马，他能够消除短期波动。我们将在下一节讨论更多的细节。</p>







<h2 id="h-dataset-analysis">数据集分析</h2>



<p>在这个演示练习中，我们将使用过去21年(1999年11月1日至2021年7月9日)苹果股票(股票代码AAPL)的收盘价。分析数据将从<a href="https://web.archive.org/web/20230125184217/https://www.alphavantage.co/documentation/" target="_blank" rel="noreferrer noopener nofollow"> Alpha Vantage </a>加载，它为历史和实时股市数据提供了一个免费的API。</p>



<p>要从Alpha Vantage获取数据，需要一个免费的API键；可以在这里找到<a href="https://web.archive.org/web/20230125184217/https://www.alphavantage.co/" target="_blank" rel="noreferrer noopener nofollow">的演练教程。不想创建API？别担心，我的</a><a href="https://web.archive.org/web/20230125184217/https://github.com/YiLi225/NeptuneBlogs/blob/main/stock_market_data-AAPL.csv" target="_blank" rel="noreferrer noopener nofollow"> Github repo </a>里也有分析数据。如果你想探索其他股票，下载数据的代码也可以在这个<a href="https://web.archive.org/web/20230125184217/https://github.com/YiLi225/NeptuneBlogs/blob/main/Predicting_StockPrices.py" target="_blank" rel="noreferrer noopener nofollow"> Github repo </a>中找到。一旦有了API，您所需要的就是特定股票的股票代码。</p>



<p>对于模型训练，我们将使用最老的80%的数据，并将最近的20%保存为保留测试集。</p>



<pre class="hljs">
test_ratio = <span class="hljs-number">0.2</span>
training_ratio = <span class="hljs-number">1</span> - test_ratio

train_size = int(training_ratio * len(stockprices))
test_size = int(test_ratio * len(stockprices))
print(<span class="hljs-string">"train_size: "</span> + str(train_size))
print(<span class="hljs-string">"test_size: "</span> + str(test_size))

train = stockprices[:train_size][[<span class="hljs-string">'Date'</span>, <span class="hljs-string">'Close'</span>]]
test = stockprices[train_size:][[<span class="hljs-string">'Date'</span>, <span class="hljs-string">'Close'</span>]]</pre>



<h2 id="h-creating-a-neptune-project">创建海王星项目</h2>



<p>关于模型训练和性能比较，Neptune使用户可以方便地跟踪与模型相关的一切，包括超参数规范和评估图。本<a href="https://web.archive.org/web/20230125184217/https://docs.neptune.ai/setup/installation/" target="_blank" rel="noreferrer noopener">完整指南</a>提供了如何用Python设置和配置Neptune项目的分步说明。</p>



<p>现在，让我们为这个特定的练习创建一个项目，并将其命名为“<strong> StockPrediction </strong>”。</p>





<h2 id="h-evaluation-metrics-and-helper-functions">评估指标和助手功能</h2>



<p>由于股票价格预测本质上是一个回归问题，因此<a href="https://web.archive.org/web/20230125184217/https://en.wikipedia.org/wiki/Root-mean-square_deviation"> RMSE(均方根误差)</a>和<a href="https://web.archive.org/web/20230125184217/https://www.statisticshowto.com/mean-absolute-percentage-error-mape/" target="_blank" rel="noreferrer noopener nofollow"> MAPE(平均绝对百分比误差%) </a>将是我们当前的模型评估指标。两者都是预测准确性的有用衡量标准。</p>







<p>，<em>其中N =时间点个数，At =实际/真实股价，Ft =预测/预测值</em>。</p>



<p>RMSE给出了预测值和真实值之间的差异，而MAPE (%)测量了相对于真实值的这种差异。例如，12%的MAPE值表示预测股价和实际股价之间的平均差异为12%。</p>



<p>接下来，让我们为当前的练习创建几个辅助函数。</p>



<ul>
<li>将股票价格数据分成训练序列X和下一个输出值Y，</li>
</ul>



<pre class="hljs">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_seqX_outcomeY</span><span class="hljs-params">(data, N, offset)</span>:</span>
    <span class="hljs-string">"""
    Split time-series into training sequence X and outcome value Y
    Args:
        data - dataset
        N - window size, e.g., 50 for 50 days of historical stock prices
        offset - position to start the split
    """</span>
    X, y = [], []

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(offset, len(data)):
        X.append(data[i-N:i])
        y.append(data[i])

    <span class="hljs-keyword">return</span> np.array(X), np.array(y)</pre>



<ul>
<li>计算RMSE和MAPE (%)，</li>
</ul>



<pre class="hljs">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_rmse</span><span class="hljs-params">(y_true, y_pred)</span>:</span>
    <span class="hljs-string">"""
    Calculate the Root Mean Squared Error (RMSE)
    """</span>
    rmse = np.sqrt(np.mean((y_true-y_pred)**<span class="hljs-number">2</span>))
    <span class="hljs-keyword">return</span> rmse

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_mape</span><span class="hljs-params">(y_true, y_pred)</span>:</span>
    <span class="hljs-string">"""
    Calculate the Mean Absolute Percentage Error (MAPE) %
    """</span>
    y_pred, y_true = np.array(y_pred), np.array(y_true)
    mape = np.mean(np.abs((y_true-y_pred) / y_true))*<span class="hljs-number">100</span>
    <span class="hljs-keyword">return</span> mape</pre>



<ul>
<li>计算技术分析的评估指标并登录到Neptune(带arg。logNeptune = True)，</li>
</ul>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_perf_metrics</span><span class="hljs-params">(var, logNeptune=True, logmodelName=<span class="hljs-string">'Simple MA'</span>)</span>:</span>
    
    rmse = calculate_rmse(np.array(stockprices[train_size:][<span class="hljs-string">'Close'</span>]), np.array(stockprices[train_size:][var]))
    
    mape = calculate_mape(np.array(stockprices[train_size:][<span class="hljs-string">'Close'</span>]), np.array(stockprices[train_size:][var]))

    
    <span class="hljs-keyword">if</span> logNeptune:
        npt_exp[<span class="hljs-string">'RMSE'</span>].log(rmse)
        npt_exp[<span class="hljs-string">'MAPE (%)'</span>].log(mape)

    <span class="hljs-keyword">return</span> rmse, mape</pre>



<ul>
<li>绘制股票价格的趋势，并将该图记录到Neptune(带参数。带参数。logNeptune = True)，</li>
</ul>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_stock_trend</span><span class="hljs-params">(var, cur_title, stockprices=stockprices, logNeptune=True, logmodelName=<span class="hljs-string">'Simple MA'</span>)</span>:</span>
    ax = stockprices[[<span class="hljs-string">'Close'</span>, var,<span class="hljs-string">'200day'</span>]].plot(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>))
    plt.grid(<span class="hljs-keyword">False</span>)
    plt.title(cur_title)
    plt.axis(<span class="hljs-string">'tight'</span>)
    plt.ylabel(<span class="hljs-string">'Stock Price ($)'</span>)

    
    <span class="hljs-keyword">if</span> logNeptune:
        npt_exp[f<span class="hljs-string">'Plot of Stock Predictions with {logmodelName}'</span>].upload(neptune.types.File.as_image(ax.get_figure()))</pre>



<h2 id="h-predicting-stock-price-with-moving-average-ma-technique">用移动平均技术预测股票价格</h2>



<p>MA是一种在股票市场消除随机波动的流行方法。类似于滑动窗口，均线是沿时间尺度/周期移动的平均值；随着新数据点的增加，旧数据点会被丢弃。</p>



<p>短期、中期和长期投资常用的周期分别是<a href="https://web.archive.org/web/20230125184217/https://www.investopedia.com/articles/active-trading/052014/how-use-moving-average-buy-stocks.asp" target="_blank" rel="noreferrer noopener nofollow"> 20天、50天和200天MA </a>。</p>



<p>金融分析师最喜欢两种移动平均线:简单移动平均线和指数移动平均线。</p>



<h3>简单的人</h3>



<p>SMA是简单移动平均线的缩写，它计算一系列股票(收盘)价格在该范围内特定时间段的平均值。SMA的公式为:</p>



<p><img decoding="async" loading="lazy" src="../Images/458b7ea8db5c151b11d3b9e6ad5d104f.png" data-original-src="https://web.archive.org/web/20230125184217im_/https://lh6.googleusercontent.com/9FotEYAEbCRHcf6BaDkf7A59jv6YE-TNOl0fWX6jTXJ0HHEk0VwLkHy3ziZN3995c0rg6tLuQMNtXmAIly0WO_7q7vNj_K3QlqO7cY2PZUtEvpFFKEL7BV6-W1cqOlSJriVe9Gpz"/>，<em>其中P</em><em>N</em><em>= N个时间点的股价，N =时间点的个数。</em></p>



<p>在这个构建SMA模型的练习中，我们将使用下面的Python代码来计算50天的SMA。为了更好的衡量，我们还会添加一个200天的均线。</p>



<pre class="hljs">window_size = <span class="hljs-number">50</span>


npt_exp = neptune.init(
        api_token=os.getenv(<span class="hljs-string">'NEPTUNE_API_TOKEN'</span>),
        project=myProject,
        name=<span class="hljs-string">'SMA'</span>,
        description=<span class="hljs-string">'stock-prediction-machine-learning'</span>,
        tags=[<span class="hljs-string">'stockprediction'</span>, <span class="hljs-string">'MA_Simple'</span>, <span class="hljs-string">'neptune'</span>])

window_var = str(window_size) + <span class="hljs-string">'day'</span>

stockprices[window_var] = stockprices[<span class="hljs-string">'Close'</span>].rolling(window_size).mean()

stockprices[<span class="hljs-string">'200day'</span>] = stockprices[<span class="hljs-string">'Close'</span>].rolling(<span class="hljs-number">200</span>).mean()


plot_stock_trend(var=window_var, cur_title=<span class="hljs-string">'Simple Moving Averages'</span>, logmodelName=<span class="hljs-string">'Simple MA'</span>)
rmse_sma, mape_sma = calculate_perf_metrics(var=window_var, logmodelName=<span class="hljs-string">'Simple MA'</span>)


npt_exp.stop()
</pre>



<p>在我们的Neptune项目中，我们将在测试集上看到性能指标；RMSE = 43.79，MAPE = 12.53%。</p>





<p>此外，下面的趋势图显示了50天，200天的SMA预测与真实的股票收盘价的比较。</p>





<p>不足为奇的是，从中期趋势来看，50日均线是比200日均线更好的趋势指标。尽管如此，这两个指标给出的预测似乎比实际值要小。</p>



<h3>指数毫安</h3>



<p>与对所有历史数据点分配相同权重的SMA不同，EMA(指数移动平均线的缩写)对最近的价格应用较高的权重，即在我们的示例中50天MA的尾部数据点。加权因子的大小取决于时间段的数量。计算EMA的公式是:</p>



<p><img decoding="async" loading="lazy" src="../Images/512bd4f36d6674af5d819fa378c6bfc3.png" data-original-src="https://web.archive.org/web/20230125184217im_/https://lh6.googleusercontent.com/I1AsNkNRJ7tAQBR4-k_fcxtRzpK16grJz_ae2dqOvC4Zj6gNSpq3lcZsIsmVASneZamfP7j9xUOIeNB8YKIjHk_wrzdLNLgI1oCMhXvewgaHXT_auf1pYqHN2mpYadd6xlflb1i_"/>，</p>



<p><em>其中P </em> <em> t </em> <em> =时间点t的价格，</em></p>



<p><em>均线</em> <em> t-1点</em><em>= t-1点均线，</em></p>



<p><em>N = EMA中的时间点数，</em></p>



<p><em>和加权因子k = 2/(N+1)。</em></p>



<p>均线优于均线的一个优点是，均线对价格变化更敏感，这使得它对短线交易很有用。下面是EMA的Python实现:</p>



<pre class="hljs">
npt_exp = neptune.init(
        api_token=os.getenv(<span class="hljs-string">'NEPTUNE_API_TOKEN'</span>),
        project=myProject,
        name=<span class="hljs-string">'EMA'</span>,
        description=<span class="hljs-string">'stock-prediction-machine-learning'</span>,
        tags=[<span class="hljs-string">'stockprediction'</span>, <span class="hljs-string">'MA_Exponential'</span>, <span class="hljs-string">'neptune'</span>])


window_ema_var = window_var+<span class="hljs-string">'_EMA'</span>

    stockprices[window_ema_var] = stockprices[<span class="hljs-string">'Close'</span>].ewm(span=window_size, adjust=<span class="hljs-keyword">False</span>).mean()
    stockprices[<span class="hljs-string">'200day'</span>] = stockprices[<span class="hljs-string">'Close'</span>].rolling(<span class="hljs-number">200</span>).mean()


plot_stock_trend(var=window_ema_var, cur_title=<span class="hljs-string">'Exponential Moving Averages'</span>, logmodelName=<span class="hljs-string">'Exp MA'</span>)
    rmse_ema, mape_ema = calculate_perf_metrics(var=window_ema_var, logmodelName=<span class="hljs-string">'Exp MA'</span>)

npt_exp.stop()
</pre>



<p>检查Neptune中跟踪的性能指标，我们得到RMSE = 36.68，MAPE = 10.71%，这比RMSE和MAPE的SMA分别为43.79和12.53%有所提高。</p>





<p>从这个均线模型生成的趋势图也暗示了它的表现优于均线。</p>





<h3>SMA和EMA预测性能的比较</h3>



<p>下面的剪辑显示了SMA和EMA在Neptune中并排的比较；蓝色和粉色的线分别是SMA和EMA。</p>





<h2 id="h-introduction-to-lstms-for-the-time-series-data">时间序列数据的LSTMs简介</h2>



<p>现在，让我们继续讨论LSTM模型。LSTM是长短期记忆的缩写，是一种非常强大的时间序列算法。它可以捕捉历史趋势模式，并以高精度预测未来值。</p>







<p>简而言之，理解LSTM模型的关键组件是细胞状态(<em> C </em> <em> t </em>)，它代表了细胞内部的短期和长期记忆。</p>





<p>为了控制和管理单元状态，LSTM模型包含三个门/层。值得一提的是，这里的“门”可以被视为让信息进来(被记住)或出去(被忘记)的过滤器。</p>









<p>顾名思义，遗忘门决定从当前单元状态中丢弃哪些信息。数学上，它应用一个<a href="https://web.archive.org/web/20230125184217/https://en.wikipedia.org/wiki/Sigmoid_function" target="_blank" rel="noreferrer noopener nofollow"> sigmoid函数</a>来输出/返回来自前一个单元格状态的每个值的[0，1]之间的值(<em>Ct-1</em>)；这里“1”表示“完全通过”,而“0”表示“完全过滤掉”</p>









<p>它用于选择在当前单元格状态中添加和存储哪些新信息。在这一层中，实现一个sigmoid函数来减少输入向量中的值(<em> i </em> <em> t </em>)，然后一个tanh函数挤压[-1，1]之间的每个值(<em> C </em> <em> t </em>)。<em> i </em> <em> t </em>和<em> C </em> <em> t </em>的逐元素矩阵乘法表示需要添加到当前单元状态的新信息。</p>









<p>输出门用于控制流向下一个单元状态的输出。与输入门类似，输出门先应用一个sigmoid函数，然后应用一个tanh函数来过滤掉不想要的信息，只保留我们决定让其通过的信息。</p>



<p>为了更详细地了解LSTM，你可以查看这个文档。</p>



<p>了解了LSTM理论，你一定想知道它是如何预测现实世界的股票价格的。我们将在下一节找到答案，通过建立一个LSTM模型，并将其性能与两个技术分析模型进行比较:SMA和EMA。</p>



<h3>用LSTM模型预测股票价格</h3>



<p>首先，我们需要创建一个专用于LSTM的海王星实验，其中包括指定的超参数。</p>



<pre class="hljs">layer_units, optimizer = <span class="hljs-number">50</span>, <span class="hljs-string">'adam'</span>
    cur_epochs = <span class="hljs-number">15</span>
    cur_batch_size = <span class="hljs-number">20</span>

    cur_LSTM_pars = {<span class="hljs-string">'units'</span>: layer_units,
                     <span class="hljs-string">'optimizer'</span>: optimizer,
                     <span class="hljs-string">'batch_size'</span>: cur_batch_size,
                     <span class="hljs-string">'epochs'</span>: cur_epochs
                     }


npt_exp = neptune.init(
        api_token=os.getenv(<span class="hljs-string">'NEPTUNE_API_TOKEN'</span>),
        project=myProject,
        name=<span class="hljs-string">'LSTM'</span>,
        description=<span class="hljs-string">'stock-prediction-machine-learning'</span>,
        tags=[<span class="hljs-string">'stockprediction'</span>, <span class="hljs-string">'LSTM'</span>,<span class="hljs-string">'neptune'</span>])
npt_exp[<span class="hljs-string">'LSTMPars'</span>] = cur_LSTM_pars
</pre>



<p>接下来，我们缩放LSTM模型规则的输入数据，并将其分成训练集和测试集。</p>



<pre class="hljs">
scaler = StandardScaler()
scaled_data = scaler.fit_transform(stockprices[[<span class="hljs-string">'Close'</span>]])
    scaled_data_train = scaled_data[:train.shape[<span class="hljs-number">0</span>]]


X_train, y_train = extract_seqX_outcomeY(scaled_data_train, window_size, window_size)</pre>



<p>几个注意事项:</p>



<ul>
<li>我们使用<em>标准定标器</em>，而不是你之前可能见过的<em>最小最大定标器</em>。原因是股票价格是不断变化的，没有真正的最小值或最大值。使用<em> MinMaxScaler </em>是没有意义的，虽然这种选择最终很可能不会导致灾难性的结果；</li>



<li>原始格式的股票价格数据不能直接用于LSTM模型；我们需要使用我们预定义的`<em> extract_seqX_outcomeY` </em>函数来转换它。例如，为了预测第51个价格，该函数预先创建50个数据点的输入向量，并使用第51个价格作为结果值。</li>
</ul>



<p>继续，让我们开始LSTM建模过程。具体来说，我们正在构建一个具有两个隐藏层的LSTM，以及一个基于输出的“线性”激活函数。还有，这个模型登录的是海王星。</p>



<pre class="hljs">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Run_LSTM</span><span class="hljs-params">(X_train, layer_units=<span class="hljs-number">50</span>, logNeptune=True, NeptuneProject=None)</span>:</span>
    inp = Input(shape=(X_train.shape[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>))

    x = LSTM(units=layer_units, return_sequences=<span class="hljs-keyword">True</span>)(inp)
    x = LSTM(units=layer_units)(x)
    out = Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">'linear'</span>)(x)
    model = Model(inp, out)

    
    model.compile(loss = <span class="hljs-string">'mean_squared_error'</span>, optimizer = <span class="hljs-string">'adam'</span>)

    
    <span class="hljs-keyword">if</span> logNeptune:
       model.summary(print_fn=<span class="hljs-keyword">lambda</span> x: NeptuneProject[<span class="hljs-string">'model_summary'</span>].log(x))

    <span class="hljs-keyword">return</span> model

model = Run_LSTM(X_train, layer_units=layer_units, logNeptune=<span class="hljs-keyword">True</span>, NeptuneProject=npt_exp)

history = model.fit(X_train, y_train, epochs=cur_epochs, batch_size=cur_batch_size,
                    verbose=<span class="hljs-number">1</span>, validation_split=<span class="hljs-number">0.1</span>, shuffle=<span class="hljs-keyword">True</span>)</pre>



<p>模型超参数和概要已经登录到海王星。</p>





<p>一旦培训完成，我们将根据我们的坚持集测试模型。</p>



<pre class="hljs">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preprocess_testdat</span><span class="hljs-params">(data=stockprices, scaler=scaler, window_size=window_size, test=test)</span>:</span>
    raw = data[<span class="hljs-string">'Close'</span>][len(data) - len(test) - window_size:].values
    raw = raw.reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)
    raw = scaler.transform(raw)

    X_test = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(window_size, raw.shape[<span class="hljs-number">0</span>]):
        X_test.append(raw[i-window_size:i, <span class="hljs-number">0</span>])

    X_test = np.array(X_test)

    X_test = np.reshape(X_test, (X_test.shape[<span class="hljs-number">0</span>], X_test.shape[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>))
    <span class="hljs-keyword">return</span> X_test

X_test = preprocess_testdat()

predicted_price_ = model.predict(X_test)
predicted_price = scaler.inverse_transform(predicted_price_)


test[<span class="hljs-string">'Predictions_lstm'</span>] = predicted_price</pre>



<p>是时候计算性能指标并将其记录到Neptune了。</p>



<pre class="hljs">
rmse_lstm = calculate_rmse(np.array(test[<span class="hljs-string">'Close'</span>]), np.array(test[<span class="hljs-string">'Predictions_lstm'</span>]))
mape_lstm = calculate_mape(np.array(test[<span class="hljs-string">'Close'</span>]), np.array(test[<span class="hljs-string">'Predictions_lstm'</span>]))


npt_exp[<span class="hljs-string">'RMSE'</span>].log(rmse_lstm)
npt_exp[<span class="hljs-string">'MAPE (%)'</span>].log(mape_lstm)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_stock_trend_lstm</span><span class="hljs-params">(train, test, logNeptune=True)</span>:</span>
    fig = plt.figure(figsize = (<span class="hljs-number">20</span>,<span class="hljs-number">10</span>))
    plt.plot(train[<span class="hljs-string">'Date'</span>], train[<span class="hljs-string">'Close'</span>], label = <span class="hljs-string">'Train Closing Price'</span>)
    plt.plot(test[<span class="hljs-string">'Date'</span>], test[<span class="hljs-string">'Close'</span>], label = <span class="hljs-string">'Test Closing Price'</span>)
    plt.plot(test[<span class="hljs-string">'Date'</span>], test[<span class="hljs-string">'Predictions_lstm'</span>], label = <span class="hljs-string">'Predicted Closing Price'</span>)
    plt.title(<span class="hljs-string">'LSTM Model'</span>)
    plt.xlabel(<span class="hljs-string">'Date'</span>)
    plt.ylabel(<span class="hljs-string">'Stock Price ($)'</span>)
    plt.legend(loc=<span class="hljs-string">"upper left"</span>)


    <span class="hljs-keyword">if</span> logNeptune:
        npt_exp[<span class="hljs-string">'Plot of Stock Predictions with LSTM'</span>].upload(neptune.types.File.as_image(fig))

plot_stock_trend_lstm(train, test)


npt_exp.stop()</pre>



<p>在海王星，很神奇的看到我们的LSTM模型取得了RMSE = 12.63，MAPE = 2.37%的成绩；这是对SMA和EMA模型的巨大改进！</p>





<p>趋势图显示了我们测试集的预测收盘价和实际收盘价近乎完美的叠加。</p>









<h2 id="h-comparison-of-sma-ema-and-lstm-models">SMA、EMA和LSTM模型的比较</h2>



<p>LSTM会占用大量的计算和内存资源吗？毕竟，这是一个比SMA或EMA等传统技术分析模型更复杂的算法。如果LSTM模式确实需要更多的资源来运行，那么扩大规模将是一个挑战，对吗？</p>



<p>幸运的是，海王星自动为我们监控这些信息。</p>





<p>正如我们所看到的，这三种型号的CPU和内存使用量相当接近；LSTM模式并不比并购模式消耗更多的资源。</p>



<h2 id="h-final-thoughts-on-new-methodologies">关于新方法的最后想法</h2>



<p>在预测苹果股票价格的例子中，我们已经看到了LSTMs相对于传统MA模型的优势。对其他股票进行归纳时要小心，因为与其他平稳的时间序列不同，股票市场数据几乎没有季节性，而且更加混乱。</p>



<p>在我们的例子中，苹果作为最大的科技巨头之一，不仅建立了成熟的商业模式和管理，其销售数字也受益于创新产品或服务的发布。这两个因素都有助于降低苹果股票的隐含波动率，使得LSTM模型的预测相对容易，而不同的高波动率股票则相反。</p>



<p>为了解释股票市场的混乱动态，回声状态网络(ESN)被提出。作为RNN(递归神经网络)家族中的一项新发明，ESN利用了一个隐藏层，该隐藏层具有几个流动且松散互连的神经元；这个隐藏层被称为“储层”,用于捕获输入数据的非线性历史信息。</p>





<p>在高层次上，ESN接受时间序列输入向量，并将其映射到高维特征空间，即动态库(神经元不像网络那样连接，而是像一个库)。然后，在输出层，应用线性激活函数来计算最终预测。</p>



<p>如果你有兴趣了解更多关于这种方法的知识，请查阅耶格和哈斯的原创论文。</p>



<p>此外，在新闻和社交媒体上结合关于股票市场以及感兴趣的给定股票的情绪分析也是令人感兴趣的。另一种更好的股票价格预测方法是混合模型，我们将MA预测作为输入向量添加到LSTM模型中。你可能也想探索不同的方法。</p>



<p>希望你喜欢读这篇文章，就像我喜欢写它一样！完整的代码/脚本可以在我的Github repo <a href="https://web.archive.org/web/20230125184217/https://github.com/YiLi225/NeptuneBlogs/blob/main/Predicting_StockPrices_NewVersion.py" target="_blank" rel="noreferrer noopener nofollow">这里</a>找到，我们目前的Neptune项目可以在<a href="https://web.archive.org/web/20230125184217/https://app.neptune.ai/katyl/StockPredictionNewVersion/experiments?split=bth&amp;dash=charts&amp;viewId=standard-view" target="_blank" rel="noreferrer noopener nofollow">这里</a>找到供你参考。</p>
        </div>
        
    </div>    
</body>
</html>