<html>
<head>
<title>Keras Metrics: Everything You Need to Know </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Keras Metrics:您需要知道的一切</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/keras-metrics#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/keras-metrics#0001-01-01</a></blockquote><div><div class="article__content col-lg-10">
<p>Keras指标是用于评估深度学习模型性能的函数。为您的问题选择一个好的度量标准通常是一项困难的任务。</p>


<div class="custom-point-list">
<ul><li>你需要了解【tf.keras和tf.keras中哪些指标已经可用以及如何使用它们，</li><li>在许多情况下，您需要<strong>定义您自己的定制指标</strong>，因为您正在寻找的指标没有随Keras一起提供。</li><li>有时，您希望<strong>通过在每个时期后查看ROC曲线或混淆矩阵</strong>等图表来监控模型性能。</li></ul>
</div>

<div class="note">
    <h3>本文将解释一些术语:</h3>
    <div class="content">
                    <div class="wysiwyg_editor">
                                    <ul id="block-4c25750e-81b5-410c-ba1f-bb452e425e74" class="block-editor-block-list__block is-selected rich-text block-editor-rich-text__editable wp-block" tabindex="0" role="textbox" contenteditable="true" spellcheck="false" aria-label="Write list…" aria-multiline="true" data-block="4c25750e-81b5-410c-ba1f-bb452e425e74" data-type="core/list" data-title="List">
<li>keras度量准确性</li>
<li>keras编译指标</li>
<li>keras自定义指标</li>
<li>回归的keras度量</li>
<li>keras混淆矩阵</li>
<li>tf.kerac.metrics.meaniou</li>
<li>tf.keras.metrics f1分数</li>
<li>tf.keras.metrics.auc</li>
</ul>
                            </div>
            </div>
</div>



<h2>Keras metrics 101</h2>



<p>在Keras中，度量在编译阶段传递，如下所示。您可以通过逗号分隔来传递多个指标。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> keras <span class="hljs-keyword">import</span> metrics

model.compile(loss=<span class="hljs-string">'mean_squared_error'</span>, optimizer=<span class="hljs-string">'sgd'</span>,
              metrics=[metrics.mae,
                       metrics.categorical_accuracy])</pre>



<p>您应该如何选择这些评估指标？</p>



<p>其中一些在Keras中可用，另一些在tf.keras中可用。</p>



<p>让我们回顾一下所有这些情况。</p>



<h2>Keras中提供了哪些指标？</h2>



<p>Keras提供了丰富的内置指标。根据你的问题，你会使用不同的。</p>



<p>让我们来看看你可能正在解决的一些问题。</p>



<h3>二元分类</h3>



<p>二元分类度量用于只涉及两个类别的计算。一个很好的例子是建立深度学习<strong>模型来预测猫和狗</strong>。我们有两个类别要预测，阈值决定了它们之间的分离点。<strong> <em> binary_accuracy </em> </strong>和<strong> <em> accuracy </em> </strong>就是Keras中的两个这样的函数。</p>



<p><em> <strong> binary_accuracy </strong>，</em>例如，计算二进制分类问题的所有预测的平均准确率。</p>



<pre class="hljs">keras.metrics.binary_accuracy(y_true, y_pred, threshold=<span class="hljs-number">0.5</span>)
</pre>



<p><strong> <em>准确性</em> </strong>指标计算所有预测的准确率。<em> y_true </em>代表真实标签，而<em> y_pred </em>代表预测标签。</p>



<pre class="hljs">keras.metrics.accuracy(y_true, y_pred)
</pre>



<p><em> <strong> confusion_matrix </strong> </em>显示一个表格，显示真阳性、真阴性、假阳性和假阴性。</p>



<pre class="hljs">keras.metrics.confusion_matrix(y_test, y_pred)
</pre>







<p>在上面的混淆矩阵中，模型做出了3305 + 375个正确的预测，106 + 714个错误的预测。</p>



<p>你也可以把它想象成一个matplotlib图表，我们稍后会讲到。</p>


<div class="note">
    <h3>什么是Keras精度？</h3>
    <div class="content">
                    <div class="wysiwyg_editor">
                                    <p>这似乎很简单，但实际上并不明显。</p>
                            </div>
                    
                    <div class="wysiwyg_editor">
                                    <blockquote><p>术语“准确度”是一个表达式，让<a href="https://web.archive.org/web/20220926093651/https://github.com/keras-team/keras/blob/d8b226f26b35348d934edb1213061993e7e5a1fa/keras/engine/training.py#L651" target="_blank" rel="noopener">训练文件</a>决定应该使用哪个度量标准(<strong>二进制准确度</strong>、<strong>分类准确度</strong>或<strong>稀疏分类准确度</strong>)。该决定基于某些参数，如输出形状(由该层产生的张量的形状，并且将是下一层的输入)和损失函数。</p></blockquote>
                            </div>
                    <div class="wysiwyg_editor">
                                    <p>因此，有时质疑甚至是最简单的事情也是好的，尤其是当您的度量发生了意想不到的事情时。</p>
                            </div>
            </div>
</div>



<h3>多类分类</h3>



<p>这些度量用于涉及两个以上类别的分类<strong>问题。扩展我们的动物分类例子，你可以有三种动物，猫、狗和熊。因为我们要对两种以上的动物进行分类，所以这是一个多类分类问题。</strong></p>



<p><em> y_true </em>的形状是条目数乘以1，即(n，1 ),但是<em> y_pred </em>的形状是条目数乘以类数(n，c)</p>



<p><em><strong>category _ accuracy</strong></em>指标计算所有预测的平均准确率。</p>



<pre class="hljs">keras.metrics.categorical_accuracy(y_true, y_pred)
</pre>



<p><em><strong>sparse _ categorial _ accuracy</strong></em>与<em>categorial _ accuracy</em>类似，但大多在对稀疏目标进行预测时使用<strong>。一个很好的例子是在深度学习问题中处理文本，如word2vec。在这种情况下，一个人用<strong>数千个类</strong>工作，目的是预测下一个单词。这个任务会产生一种情况，y_true是一个几乎全是零的巨大矩阵，这是使用稀疏矩阵的最佳位置。</strong></p>



<pre class="hljs">keras.metrics.sparse_categorical_accuracy(y_true, y_pred)
</pre>



<p><em><strong>top _ k _ category _ accuracy</strong></em>计算top-k分类准确率。我们从我们的模型中取出前k个预测类，并查看正确的类是否被选为前k个。如果是，我们说我们的模型是正确的。</p>



<pre class="hljs">keras.metrics.top_k_categorical_accuracy(y_true, y_pred, k=<span class="hljs-number">5</span>)
</pre>



<h3>回归</h3>



<p>回归问题中使用的度量包括<strong>均方误差、平均绝对误差和平均绝对百分比误差。</strong>这些指标用于预测房屋销售和价格等数值。查看这个参考资料，获得关于回归度量的<a href="https://web.archive.org/web/20220926093651/https://scikit-learn.org/stable/modules/model_evaluation.html#regression-metrics" target="_blank" rel="noreferrer noopener">完整指南。</a></p>



<pre class="hljs"><span class="hljs-keyword">from</span> keras <span class="hljs-keyword">import</span> metrics

model.compile(loss=<span class="hljs-string">'mse'</span>, optimizer=<span class="hljs-string">'adam'</span>, 
              metrics=[metrics.mean_squared_error, 
                       metrics.mean_absolute_error, 
                       metrics.mean_absolute_percentage_error])
                       metrics.categorical_accuracy])</pre>





<h2>如何在Keras中创建自定义指标？</h2>



<p>正如我们前面提到的，Keras还允许您定义自己的定制指标。</p>



<p>您定义的函数<strong>必须将<em> y_true </em>和<em> y_pred </em>作为参数，并且必须返回单个张量值</strong>。这些对象是具有float32数据类型的张量类型。对象的形状是行数乘以1。例如，如果有4，500个条目，形状将是(4500，1)。</p>



<p>可以在深度学习模型的编译阶段传递函数来使用。</p>



<pre class="hljs">model.compile(...metrics=[your_custom_metric])</pre>



<h3>如何计算Keras中的F1分数(精度，召回作为加分)？</h3>



<p>让我们看看如何在Keras中计算<strong> f1分数、精确度和召回率。</strong>我们将为多类场景创建它，但您也可以将其用于二进制分类。</p>



<p>f1分数是精确度和召回率的加权平均值。因此，为了计算f1，我们需要首先创建计算精度和召回率的函数。请注意，在多类场景中，您需要查看所有的类，而不仅仅是正类(这是二进制分类的情况)</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recall</span><span class="hljs-params">(y_true, y_pred)</span>:</span>
    y_true = K.ones_like(y_true) 
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)))
    all_positives = K.sum(K.round(K.clip(y_true, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)))
    
    recall = true_positives / (all_positives + K.epsilon())
    <span class="hljs-keyword">return</span> recall

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">precision</span><span class="hljs-params">(y_true, y_pred)</span>:</span>
    y_true = K.ones_like(y_true) 
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)))
    
    predicted_positives = K.sum(K.round(K.clip(y_pred, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)))
    precision = true_positives / (predicted_positives + K.epsilon())
    <span class="hljs-keyword">return</span> precision

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1_score</span><span class="hljs-params">(y_true, y_pred)</span>:</span>
    precision = precision_m(y_true, y_pred)
    recall = recall_m(y_true, y_pred)
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*((precision*recall)/(precision+recall+K.epsilon()))
</pre>



<p>下一步是在我们深度学习模型的编译阶段使用这些函数。我们还添加了默认可用的Keras <em>准确性</em>指标。</p>



<pre class="hljs">model.compile(...,metrics=[<span class="hljs-string">'accuracy'</span>, f1_score, precision, recall])
</pre>



<p>现在让我们根据训练集和测试集来调整模型。</p>



<pre class="hljs">model.fit(x_train, y_train, epochs=<span class="hljs-number">5</span>)
</pre>



<p>现在您可以评估您的模型，并访问您刚刚创建的指标。</p>



<pre class="hljs">(loss, 
accuracy, 
f1_score, precision, recall) = model.evaluate(x_test, y_test, verbose=<span class="hljs-number">1</span>)
</pre>



<p>很好，您现在知道如何在keras中创建定制指标了。</p>



<p>也就是说，有时你可以使用已经存在的东西，只是在一个不同的库中，比如tf.keras🙂</p>



<h2>tf.keras中有哪些指标？</h2>



<p>最近<strong> Keras已经成为TensorFlow </strong>中的标准API，有许多有用的指标可供您使用。</p>



<p>让我们来看看其中的一些。与在Keras中只使用<em> keras.metrics </em>函数调用指标不同，在tf.keras中，您必须实例化一个<em>指标</em>类。</p>



<p>例如:</p>



<pre class="hljs">tf.keras.metrics.Accuracy() 
</pre>



<p>keras指标和tf.keras 之间有很多重叠。但是，有一些指标你只能在tf.keras中找到。</p>



<p>让我们看看那些。</p>



<h3>tf.keras分类指标</h3>



<p><strong><em>TF . keras . metrics . AUC</em></strong>通过<a href="https://web.archive.org/web/20220926093651/https://www.khanacademy.org/math/ap-calculus-ab/ab-integration-new/ab-6-2/a/left-and-right-riemann-sums" target="_blank" rel="noreferrer noopener">黎曼和</a>计算ROC曲线的近似AUC(曲线下面积)。</p>



<pre class="hljs">model.compile(<span class="hljs-string">'sgd'</span>, loss=<span class="hljs-string">'mse'</span>, metrics=[tf.keras.metrics.AUC()])
</pre>



<p>您可以使用precision，回想一下我们以前在tf.keras中实现的开箱即用。</p>



<pre class="hljs">model.compile(<span class="hljs-string">'sgd'</span>, loss=<span class="hljs-string">'mse'</span>, 
               metrics=[tf.keras.metrics.Precision(), 
                        tf.keras.metrics.Recall()])
</pre>



<h3>tf.keras细分指标</h3>



<p><em><strong>TF . keras . metrics . meaniou</strong></em>–<em>Mean Intersection-Over-Union</em>是用于评估语义图像分割模型的度量。我们首先计算每个类的欠条:</p>







<p>所有班级的平均值。</p>



<pre class="hljs">model.compile(... metrics=[tf.keras.metrics.MeanIoU(num_classes=<span class="hljs-number">2</span>)])
</pre>



<h3>tf.keras回归度量</h3>



<p>就像Keras一样，tf.keras也有类似的回归度量。我们不会过多讨论它们，但有一个有趣的指标值得强调，叫做<em> <strong>表示相对误差</strong> </em>。</p>



<p><em> <strong>表示相对误差</strong> </em>取一次观测的绝对误差，除以常数。这个常数，<strong>归一化因子</strong>，可以对所有观测值相同，也可以对每个样本不同。</p>



<p>因此，平均相对误差是相对误差的平均值。</p>



<pre class="hljs">tf.keras.metrics.MeanRelativeError(normalizer=[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</pre>





<h2>如何在tf.keras中创建自定义指标？</h2>



<p>在<em> tf.keras </em>中，您可以通过扩展<em> keras.metrics.Metric </em>类来创建一个自定义指标。</p>



<p>为此，您必须覆盖update_state、result和reset_state函数:</p>


<div class="custom-point-list">
<ul><li><em><strong>【update _ state()</strong></em>对状态变量进行所有更新并计算度量，</li><li><em> <strong> result() </strong> </em>从状态变量中返回度量值，</li><li><em> <strong> reset_state() </strong> </em>将每个时期开始时的度量值设置为预定义的常数(通常为0)</li></ul>
</div>


<pre class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MulticlassTruePositives</span><span class="hljs-params">(tf.keras.metrics.Metric)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name=<span class="hljs-string">'multiclass_true_positives'</span>, **kwargs)</span>:</span>
        super(MulticlassTruePositives, self).__init__(name=name, **kwargs)
        self.true_positives = self.add_weight(name=<span class="hljs-string">'tp'</span>, initializer=<span class="hljs-string">'zeros'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_state</span><span class="hljs-params">(self, y_true, y_pred, sample_weight=None)</span>:</span>
        y_pred = tf.reshape(tf.argmax(y_pred, axis=<span class="hljs-number">1</span>), shape=(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>))
        values = tf.cast(y_true, <span class="hljs-string">'int32'</span>) == tf.cast(y_pred, <span class="hljs-string">'int32'</span>)
        values = tf.cast(values, <span class="hljs-string">'float32'</span>)
        <span class="hljs-keyword">if</span> sample_weight <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
            sample_weight = tf.cast(sample_weight, <span class="hljs-string">'float32'</span>)
            values = tf.multiply(values, sample_weight)
        self.true_positives.assign_add(tf.reduce_sum(values))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">result</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.true_positives

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset_states</span><span class="hljs-params">(self)</span>:</span>
        
        self.true_positives.assign(<span class="hljs-number">0.</span>)</pre>



<p>然后我们简单地在编译阶段传递它:</p>



<pre class="hljs">model.compile(...,metrics=[MulticlassTruePositives()])
</pre>





<h2>性能图表:Keras中的ROC曲线和混淆矩阵</h2>



<p><strong>有时，性能不能用一个数字</strong>来表示，而是用性能图表来表示。这种图表的例子有ROC曲线或混淆矩阵。在这些情况下，您可能希望将这些图表记录在某个地方，以便进一步检查。</p>



<p>为了做到这一点，你需要创建一个回调函数，它将在每个时期结束时跟踪你的模型的性能。然后，你可以在一个文件夹中或者在<a href="https://web.archive.org/web/20220926093651/https://neptune.ai/blog/best-ml-experiment-tracking-tools" target="_blank" rel="noreferrer noopener">实验跟踪工具</a>中查看改进。让我们开始吧。</p>



<p>首先，我们需要一个回调，在每个时期结束时创建ROC曲线和混淆矩阵。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> os

<span class="hljs-keyword">from</span> keras.callbacks <span class="hljs-keyword">import</span> Callback
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> scikitplot.metrics <span class="hljs-keyword">import</span> plot_confusion_matrix, plot_roc


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceVisualizationCallback</span><span class="hljs-params">(Callback)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, model, validation_data, image_dir)</span>:</span>
        super().__init__()
        self.model = model
        self.validation_data = validation_data
        
        os.makedirs(image_dir, exist_ok=<span class="hljs-keyword">True</span>)
        self.image_dir = image_dir

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_epoch_end</span><span class="hljs-params">(self, epoch, logs={})</span>:</span>
        y_pred = np.asarray(self.model.predict(self.validation_data[<span class="hljs-number">0</span>]))
        y_true = self.validation_data[<span class="hljs-number">1</span>]             
        y_pred_class = np.argmax(y_pred, axis=<span class="hljs-number">1</span>)

        
        fig, ax = plt.subplots(figsize=(<span class="hljs-number">16</span>,<span class="hljs-number">12</span>))
        plot_confusion_matrix(y_true, y_pred_class, ax=ax)
        fig.savefig(os.path.join(self.image_dir, f<span class="hljs-string">'confusion_matrix_epoch_{epoch}'</span>))

       
        fig, ax = plt.subplots(figsize=(<span class="hljs-number">16</span>,<span class="hljs-number">12</span>))
        plot_roc(y_true, y_pred, ax=ax)
        fig.savefig(os.path.join(self.image_dir, f<span class="hljs-string">'roc_curve_epoch_{epoch}'</span>))
</pre>



<p>现在我们简单地将它传递给<em> model.fit() </em> callbacks参数。</p>



<pre class="hljs">performance_cbk = PerformanceVisualizationCallback(
                      model=model,
                      validation_data=validation_data,
                      image_dir=<span class="hljs-string">'performance_vizualizations'</span>)

history = model.fit(x=x_train,
                    y=y_train,
                    epochs=<span class="hljs-number">5</span>,
                    validation_data=validation_data,
                    callbacks=[performance_cbk])</pre>



<p>如果你愿意，你可以有多个回调。</p>



<p>现在，您将能够在模型训练时看到这些可视化效果:</p>



<figure class="wp-block-video"><video controls="" src="https://web.archive.org/web/20220926093651im_/https://neptune.ai/wp-content/uploads/keras_roc_curve_cut_hd.mp4"/></figure>



<p>你也可以像Neptune一样把一切记录到实验跟踪工具中。这种方法将让您在一个地方拥有所有的模型元数据。为此，您可以使用<a href="https://web.archive.org/web/20220926093651/https://docs.neptune.ai/integrations-and-supported-tools/model-training/tensorflow-keras" target="_blank" rel="noreferrer noopener"> Neptune + TensorFlow / Keras集成</a>:</p>



<pre class="hljs">from neptune.new.integrations.tensorflow_keras <span class="hljs-keyword">import</span> NeptuneCallback
<span class="hljs-keyword">import</span> neptune.new <span class="hljs-keyword">as</span> neptune
from scikitplot.metrics <span class="hljs-keyword">import</span> plot_confusion_matrix
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

run = neptune.init(
        project=<span class="hljs-string">'YOUR_WORKSAPCE/YOUR_PROJECT_NAME'</span>,
        api_token=<span class="hljs-string">'YOUR_API_TOKEN'</span>)

</pre>



<p>请注意，您不需要为图像创建文件夹，因为图表将直接发送到您的工具。另一方面，你必须<a href="https://web.archive.org/web/20220926093651/https://docs.neptune.ai/api-reference/management#.create_project" target="_blank" rel="noreferrer noopener">创建一个项目</a>来开始跟踪你的跑步。</p>



<p>一旦你做到了这一点，一切照常。</p>



<pre class="hljs"><span class="hljs-attr">neptune_cbk</span> = NeptuneCallback(<span class="hljs-attr">run=run,</span> <span class="hljs-attr">base_namespace='metrics')</span>


<span class="hljs-attr">history</span> = model.fit(<span class="hljs-attr">x=x_train,</span>
                    <span class="hljs-attr">y=y_train,</span>
                    <span class="hljs-attr">epochs=5,</span>
                    <span class="hljs-attr">validation_data=validation_data,</span>
                    <span class="hljs-attr">callbacks=[neptune_cbk])</span>

fig, <span class="hljs-attr">ax</span> = plt.subplots(<span class="hljs-attr">figsize=(16,</span> <span class="hljs-number">12</span>))
plot_confusion_matrix(y_train, y_train_pred, <span class="hljs-attr">ax=ax)</span>


run['confusion_matrix'].upload(neptune.types.File.as_image(fig))

</pre>



<p>您可以在<a href="https://web.archive.org/web/20220926093651/https://app.neptune.ai/common/tf-keras-integration/e/TFK-18/charts" target="_blank" rel="noreferrer noopener">应用</a>中探索指标和性能图表。</p>






<p id="block_5ffefbec57a4c" class="separator separator-5"/>



<h2>如何绘制Keras历史对象？</h2>



<p>每当调用<em> fit() </em>时，它都返回一个<strong> <em>历史</em> </strong>对象，该对象可用于可视化训练历史。<strong>它包含一个字典，其中包含为训练和验证数据集计算的每个历元的损失和度量值</strong>。</p>



<p>例如，让我们提取“<em>准确性</em>”指标，并使用matplotlib绘制它。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

history = model.fit(x_train, y_train, 
                    validation_split=<span class="hljs-number">0.25</span>, 
                    epochs=<span class="hljs-number">50</span>, batch_size=<span class="hljs-number">16</span>, verbose=<span class="hljs-number">1</span>)


plt.plot(history.history[<span class="hljs-string">'accuracy'</span>])
plt.plot(history.history[<span class="hljs-string">'val_‘accuracy'</span>])
plt.title(<span class="hljs-string">'Model accuracy'</span>)
plt.ylabel(<span class="hljs-string">'Accuracy'</span>)
plt.xlabel(<span class="hljs-string">'Epoch'</span>)
plt.legend([<span class="hljs-string">'Train'</span>, <span class="hljs-string">'Test'</span>], loc=<span class="hljs-string">'upper left'</span>)
plt.show()</pre>









<h2>Keras指标示例</h2>



<p>好了，你已经走了很长一段路，学到了很多。为了唤起你的记忆，让我们把它们放在一个例子中。</p>



<p>我们将从mnist数据集开始，并创建一个简单的CNN模型:</p>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

mnist = tf.keras.datasets.mnist

(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / <span class="hljs-number">255.0</span>, x_test / <span class="hljs-number">255.0</span>
validation_data = x_test, y_test

model = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(input_shape=(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>)),
    tf.keras.layers.Dense(<span class="hljs-number">512</span>, activation=<span class="hljs-string">'relu'</span>),
    tf.keras.layers.Dropout(<span class="hljs-number">0.2</span>),
    tf.keras.layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>)
])
</pre>



<p>我们将在keras 中创建一个自定义指标、多类别<strong> f1分数:</strong></p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recall</span><span class="hljs-params">(y_true, y_pred)</span>:</span>
    y_true = K.ones_like(y_true) 
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)))
    all_positives = K.sum(K.round(K.clip(y_true, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)))
    
    recall = true_positives / (all_positives + K.epsilon())
    <span class="hljs-keyword">return</span> recall

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">precision</span><span class="hljs-params">(y_true, y_pred)</span>:</span>
    y_true = K.ones_like(y_true) 
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)))
    
    predicted_positives = K.sum(K.round(K.clip(y_pred, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)))
    precision = true_positives / (predicted_positives + K.epsilon())
    <span class="hljs-keyword">return</span> precision

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1_score</span><span class="hljs-params">(y_true, y_pred)</span>:</span>
    precision = precision_m(y_true, y_pred)
    recall = recall_m(y_true, y_pred)
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*((precision*recall)/(precision+recall+K.epsilon()))
</pre>



<p>我们将创建一个定制的tf.keras度量:<strong>multiclasstruepoints</strong>确切地说:</p>



<pre class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MulticlassTruePositives</span><span class="hljs-params">(tf.keras.metrics.Metric)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name=<span class="hljs-string">'multiclass_true_positives'</span>, **kwargs)</span>:</span>
        super(MulticlassTruePositives, self).__init__(name=name, **kwargs)
        self.true_positives = self.add_weight(name=<span class="hljs-string">'tp'</span>, initializer=<span class="hljs-string">'zeros'</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_state</span><span class="hljs-params">(self, y_true, y_pred, sample_weight=None)</span>:</span>
        y_pred = tf.reshape(tf.argmax(y_pred, axis=<span class="hljs-number">1</span>), shape=(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>))
        values = tf.cast(y_true, <span class="hljs-string">'int32'</span>) == tf.cast(y_pred, <span class="hljs-string">'int32'</span>)
        values = tf.cast(values, <span class="hljs-string">'float32'</span>)
        <span class="hljs-keyword">if</span> sample_weight <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
            sample_weight = tf.cast(sample_weight, <span class="hljs-string">'float32'</span>)
            values = tf.multiply(values, sample_weight)
        self.true_positives.assign_add(tf.reduce_sum(values))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">result</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.true_positives

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset_states</span><span class="hljs-params">(self)</span>:</span>
        
        self.true_positives.assign(<span class="hljs-number">0.</span>)</pre>



<p>我们将<strong>用我们的指标编译keras模型</strong>:</p>



<pre class="hljs"><span class="hljs-keyword">import</span> keras

model.compile(optimizer=<span class="hljs-string">'sgd'</span>,
              loss=<span class="hljs-string">'sparse_categorical_crossentropy'</span>,
              metrics=[<span class="hljs-string">'accuracy'</span>,
                       keras.metrics.categorical_accuracy,
                       f1_score, 
                       recall_score, 
                       precision_score,
                       tf.keras.metrics.TopKCategoricalAccuracy(k=<span class="hljs-number">5</span>),
                       MulticlassTruePositives()])</pre>



<p>我们将实现keras <strong>回调，它将ROC曲线和混淆矩阵</strong>绘制到一个文件夹中:</p>



<pre class="hljs"><span class="hljs-keyword">import</span> os

<span class="hljs-keyword">from</span> keras.callbacks <span class="hljs-keyword">import</span> Callback
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> scikitplot.metrics <span class="hljs-keyword">import</span> plot_confusion_matrix, plot_roc

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceVisualizationCallback</span><span class="hljs-params">(Callback)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, model, validation_data, image_dir)</span>:</span>
        super().__init__()
        self.model = model
        self.validation_data = validation_data
        
        os.makedirs(image_dir, exist_ok=<span class="hljs-keyword">True</span>)
        self.image_dir = image_dir

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_epoch_end</span><span class="hljs-params">(self, epoch, logs={})</span>:</span>
        y_pred = np.asarray(self.model.predict(self.validation_data[<span class="hljs-number">0</span>]))
        y_true = self.validation_data[<span class="hljs-number">1</span>]             
        y_pred_class = np.argmax(y_pred, axis=<span class="hljs-number">1</span>)

        
        fig, ax = plt.subplots(figsize=(<span class="hljs-number">16</span>,<span class="hljs-number">12</span>))
        plot_confusion_matrix(y_true, y_pred_class, ax=ax)
        fig.savefig(os.path.join(self.image_dir, f<span class="hljs-string">'confusion_matrix_epoch_{epoch}'</span>))

       
        fig, ax = plt.subplots(figsize=(<span class="hljs-number">16</span>,<span class="hljs-number">12</span>))
        plot_roc(y_true, y_pred, ax=ax)
        fig.savefig(os.path.join(self.image_dir, f<span class="hljs-string">'roc_curve_epoch_{epoch}'</span>))

performance_viz_cbk = PerformanceVisualizationCallback(
                                       model=model,
                                       validation_data=validation_data,
                                       image_dir=<span class="hljs-string">'perorfmance_charts'</span>)</pre>



<p>我们将<strong>进行培训</strong>并监控表现:</p>



<pre class="hljs">history = model.fit(x=x_train,
                    y=y_train,
                    epochs=<span class="hljs-number">5</span>,
                    validation_data=validation_data,
                    callbacks=[performance_viz_cbk])</pre>



<p>我们将<strong>可视化来自keras历史对象的指标:</strong></p>



<pre class="hljs">plt.plot(history.history[<span class="hljs-string">'accuracy'</span>])
plt.plot(history.history[<span class="hljs-string">'val_accuracy'</span>])
plt.title(<span class="hljs-string">'Model accuracy'</span>)
plt.ylabel(<span class="hljs-string">'Accuracy'</span>)
plt.xlabel(<span class="hljs-string">'Epoch'</span>)
plt.legend([<span class="hljs-string">'Train'</span>, <span class="hljs-string">'Test'</span>], loc=<span class="hljs-string">'upper left'</span>)
plt.show()
</pre>



<p>我们将在TensorBoard或Neptune等工具中监控和探索您的实验。</p>






<h2>海王星</h2>



<pre class="hljs"><span class="hljs-attr">run</span> = neptune.init(
        <span class="hljs-attr">project='YOUR_WORKSAPCE/YOUR_PROJECT_NAME',</span>
        <span class="hljs-attr">api_token='YOUR_API_TOKEN')</span>

<span class="hljs-attr">neptune_cbk</span> = NeptuneCallback(<span class="hljs-attr">run=run,</span> <span class="hljs-attr">base_namespace='metrics')</span>
<span class="hljs-attr">history</span> = model.fit(..., <span class="hljs-attr">callbacks=[neptune_cbk])</span>

</pre>



<p>如果您感兴趣，请查看此<a href="https://web.archive.org/web/20220926093651/https://docs.neptune.ai/integrations-and-supported-tools/model-training/tensorflow-keras" target="_blank" rel="noreferrer noopener">文档</a>和示例<a href="https://web.archive.org/web/20220926093651/https://app.neptune.ai/o/common/org/tf-keras-integration/e/TFK-35541/dashboard/metrics-b11ccc73-9ac7-4126-be1a-cf9a3a4f9b74" target="_blank" rel="noreferrer noopener">实验运行</a>:</p>







<p>👉了解更多关于Neptune与Keras的整合。</p>



<h2>张量板</h2>



<p>您只需要<strong>添加另一个回调或者修改您之前已经</strong>创建的回调:</p>



<pre class="hljs"><span class="hljs-keyword">from</span>  tf.keras.callbacks <span class="hljs-keyword">import</span> TensorBoard

tensorboard_cbk = TensorBoard(log_dir=<span class="hljs-string">"logs/training-example/"</span>)

history = model.fit(..., callbacks=[performance_viz_cbk, 
                                    tensorboard_cbk])</pre>



<p>使用TensorBoard，您需要启动本地服务器并在浏览器中浏览您的跑步记录。</p>



<pre class="hljs">tensorboard --logdir logs/training-example/</pre>










<h2>最后的想法</h2>



<p>希望这篇文章能给你一些keras中模型评估技术的背景知识。</p>



<p>我们涵盖了:</p>


<div class="custom-point-list">
<ul><li>keras和tf.keras中的内置方法，</li><li>实现您自己的定制指标，</li><li>如何在模型训练时可视化自定义性能图表。</li></ul>
</div>


<p>欲了解更多信息，请查看Keras知识库和张量流度量文档。</p>



<p>快乐训练！</p>




<div id="author-box-new-format-block_6007356684165" class="article__footer article__author">
  

  <div class="article__authorContent">
          <h3 class="article__authorContent-name">德里克·姆维蒂</h3>
    
          <p class="article__authorContent-text">Derrick Mwiti是一名数据科学家，他对分享知识充满热情。他是数据科学社区的热心贡献者，例如Heartbeat、Towards Data Science、Datacamp、Neptune AI、KDnuggets等博客。他的内容在网上被浏览了超过一百万次。德里克也是一名作家和在线教师。他还培训各种机构并与之合作，以实施数据科学解决方案并提升其员工的技能。你可能想看看他在Python课程中完整的数据科学和机器学习训练营。</p>
    
          
    
  </div>
</div>


<div class="wp-container-1 wp-block-group"><div class="wp-block-group__inner-container">
<hr class="wp-block-separator"/>



<p class="has-text-color"><strong>阅读下一篇</strong></p>



<h2>如何在您的项目中跟踪机器学习模型指标</h2>



<p class="has-small-font-size">3分钟阅读| Jakub Czakon |发布于2020年6月22日</p>


<p id="block_5ffc75def9f8e" class="separator separator-10"/>



<p>跟踪机器学习模型的评估指标至关重要，以便:</p>


<div class="custom-point-list">
<ul><li>了解您的模型做得如何</li><li>能够将它与以前的基线和想法进行比较</li><li>了解你离项目目标有多远</li></ul>
</div>


<p>“如果你不衡量它，你就不能改进它。”</p>



<p>但是你应该跟踪什么呢？</p>



<p>我从来没有发现自己在这样的情况下，我认为我已经为我的机器学习实验记录了太多的指标。</p>



<p>此外，在现实世界的项目中，您所关心的指标可能会由于新的发现或不断变化的规范而改变，因此记录更多的指标实际上可以在将来为您节省一些时间和麻烦。</p>



<p>不管怎样，我的建议是:</p>



<p>“记录比你认为需要的更多的指标。”</p>



<p>好吧，但是你具体是怎么做的呢？</p>



<h3>跟踪单一数字的指标</h3>



<p>在许多情况下，您可以为机器学习模型的性能分配一个数值。您可以计算保留验证集的准确度、AUC或平均精度，并将其用作模型评估指标。</p>



<p>在这种情况下，您应该跟踪每次实验运行的所有这些值。</p>


<a class="button continous-post blue-filled" href="/web/20220926093651/https://neptune.ai/blog/how-to-track-machine-learning-model-metrics" target="_blank">
    Continue reading -&gt;</a>



<hr class="wp-block-separator"/>
</div></div>



<p/>
</div>
      </div>    
</body>
</html>