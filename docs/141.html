<html>
<head>
<title>How to Choose a Loss Function For Face Recognition </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>人脸识别如何选择损失函数</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/how-to-choose-loss-function-for-face-recognition#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/how-to-choose-loss-function-for-face-recognition#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p><a href="https://web.archive.org/web/20221231065532/https://machinelearningmastery.com/introduction-to-deep-learning-for-face-recognition/" target="_blank" rel="noreferrer noopener nofollow">人脸识别</a> (FR)是深度学习最有趣的任务之一。从表面上看，这就像是另一个<a href="https://web.archive.org/web/20221231065532/https://towardsdatascience.com/machine-learning-multiclass-classification-with-imbalanced-data-set-29f6a177c1a" target="_blank" rel="noreferrer noopener nofollow">多类分类问题</a>。当你试着去实现它时，你会意识到它有更多的含义。损失函数的选择可能是决定模型性能的最关键因素。</p>



<p>为了让FR模型表现良好，它必须学会以这样一种方式从图像中提取这样的特征，即将属于同一张脸的所有图像紧密地放置在一起(在特征空间中)，并将不同脸的图像远离放置。换句话说，我们需要模型来减少特征空间中数据点的类内距离<em>，增加类间</em>距离<em>。本文的前半部分描述了对这两个子任务提供细粒度控制的损失函数。</em></p>



<p>与一般的分类任务不同，预先收集所有可能人脸的样本图像是不切实际的。因此，使用依赖于固定数量的类的损失函数可能不是一个好主意。在本文的后半部分，我们将探索损失函数，其目的是<em>学习图像的良好的</em><em/>表示，而不是<em>将</em>图像分类到一组预定的类别中。这些表示然后被馈送到任何合适的最近邻分类器，例如k-NN。</p>







<h2 id="h-loss-functions-based-on-classification">基于分类的损失函数</h2>



<p><a href="https://web.archive.org/web/20221231065532/https://www.section.io/engineering-education/understanding-loss-functions-in-machine-learning/" target="_blank" rel="noreferrer noopener nofollow">损失函数</a>将任何图像分类到已知类别。我的理解是，如果你有一个小的固定数量的类和更少的可用数据，它们会工作得更好。可以使用不同的度量来测量数据点之间的距离。欧几里德距离和余弦相似性(及其修改)是最流行的。</p>



<h3>用欧几里得距离来衡量</h3>



<h4>软最大损失</h4>



<h5>背景/动机</h5>



<p>Softmax损失只不过是最后一层中softmax激活的分类交叉熵损失。这是FR最基本的损失函数，也可能是最差的。为了完整起见，我将它包含在这里，因为在此之后出现的损失是对softmax损失的一些修改。</p>







<h5>定义</h5>



<p>softmax损耗定义如下:</p>







<p><strong>X</strong><strong><sub>I</sub></strong><strong/>是第i <sup>幅</sup>幅图像的特征向量。<em> W </em> <em> <sub> j </sub> </em>是权重的第j<sup/>列，<em> b </em> <em> <sub> j </sub> </em>是偏置项。类别数和图像数分别为<em> n </em>和<em> m </em>，而<em>y</em><em><sub>I</sub></em><em/>是第<em>I</em><em><sup>th</sup></em>幅图像的类别。</p>



<h5>优势</h5>



<ul><li>这种损失在文献中有很好的探讨，并且在信息理论中有很强的概念基础</li><li>大多数标准的机器学习框架已经提供了这种损失的内置实现。</li></ul>



<h5>不足之处</h5>



<ul><li>每个类都需要在训练集中表示</li><li>无法对类内/类间距离进行精细控制</li></ul>



<h5>代码示例</h5>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">softmax_loss</span><span class="hljs-params">(y_true, W, b, x)</span>:</span>

    y_pred = tf.matmul(x, W) + b
    numerators = tf.reduce_sum(y_true * tf.exp(y_pred), axis=<span class="hljs-number">1</span>)
    denominators = tf.reduce_sum(tf.exp(y_pred), axis=<span class="hljs-number">1</span>)
    loss = - tf.reduce_sum(tf.log(numerators / denominators))

    <span class="hljs-keyword">return</span> loss</pre>



<h4>中心损失</h4>



<h5>背景/动机</h5>



<ul><li>为了解决Softmax损失的局限性，这篇论文的作者提出了中心损失的概念。</li><li>首先，他们注意到数据在特征空间中的分布存在显著的类内差异。</li><li>他们用一个玩具模型来证明这一点，这个玩具模型的最后一层只有两个完全连接的节点。</li><li>训练后最终层激活的图如下图所示(摘自论文)</li></ul>







<ul><li>为了缓解这种情况，他们在softmax loss中引入了一个额外的项，如果数据点远离其类的质心，则该项会惩罚模型。</li></ul>



<h5>定义</h5>



<p>中心损耗定义为:</p>







<ul><li>第一项(灰色)与softmax损失相同。</li><li>在第二项中，<em>c</em><em><sub>yi</sub></em><strong/>是属于特征空间中第i <sup>个</sup>数据点的类<em>y</em>T10】I的所有点的质心。</li><li>第二项实质上是所有点距其各自类质心的平方距离之和。实际上，这个质心是一次为一个批次而不是整个数据集计算的。</li><li>是控制第二项效果的超参数。</li></ul>



<h5>优势</h5>



<ul><li>圆形损失明确地惩罚了<em>类内</em>变化。</li><li>与对比损失或三重损失(稍后讨论)不同，它不需要将训练样本复杂地重新组合成对或三重。</li></ul>



<h5>不足之处</h5>



<ul><li>如果类的数量非常大，那么质心的计算就变得非常昂贵[ <a href="https://web.archive.org/web/20221231065532/https://arxiv.org/abs/1801.07698" target="_blank" rel="noreferrer noopener nofollow"> Source </a></li><li>它没有明确地惩罚<em>类间</em>的变化。</li></ul>



<h5>代码示例</h5>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">circle_loss</span><span class="hljs-params">(W, b, lamda_center)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">(y_true, x)</span>:</span>
        y_pred = tf.matmul(x, W) + b
        numerators = tf.reduce_sum(y_true * tf.exp(y_pred), axis=<span class="hljs-number">1</span>)
        denominators = tf.reduce_sum(tf.exp(y_pred), axis=<span class="hljs-number">1</span>)
        loss_softmax = - tf.reduce_sum(tf.log(numerators / denominators))

        class_freqs = tf.reduce_sum(y_true, axis=<span class="hljs-number">0</span>, keepdims=<span class="hljs-keyword">True</span>)
        class_freqs = tf.transpose(class_freqs)

        centres = tf.matmul(tf.transpose(y_true), x)
        centres = tf.divide(centres, class_freqs)
        repeated_centres = tf.matmul(y_true, centres)

        sq_distances = tf.square(tf.norm(x - repeated_centres, axis=<span class="hljs-number">1</span>))
        loss_centre = tf.reduce_sum(sq_distances)

        loss = loss_softmax + (lambda_center/<span class="hljs-number">2</span>) * loss_centre

        <span class="hljs-keyword">return</span> loss
    <span class="hljs-keyword">return</span> inner</pre>



<h3>通过角距离测量</h3>



<h4>A-Softmax(又名SphereFace)</h4>



<h5>背景/动机</h5>



<ul><li>从softmax损耗中学习的特征本质上具有角度分布(参见中心损耗部分的图)。</li><li>这篇论文的作者明确利用了这个事实。</li></ul>



<h5>定义</h5>



<ul><li>作者根据特征向量和与其在权重矩阵中的类别相对应的列向量之间的角度来改写softmax损失的表达式(参考softmax损失以了解除θ之外的术语的解释):</li></ul>







<ul><li>然后，他们通过L <sub> 2 </sub>归一化每个W <sub> j </sub>并忽略偏差项来简化表达式。这仍然是一个很好的近似值(我的理解是，这只是为了计算损耗，而不是在实际架构中)。</li></ul>







<ul><li>然后他们添加一个超参数<em> m </em>来控制这个表达式对角度的敏感度</li></ul>







<ul><li>这是球面损失。为了完整起见，本文描述了进一步的修改，但是这种表达对于概念性的理解是足够的。</li><li>余弦函数被修改的余量如下(绿色为未修改)。</li></ul>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img decoding="async" loading="lazy" src="../Images/5756b1c9f247c537c098eb6db5ac51b5.png" alt="SphereFace" class="wp-image-49208" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221231065532im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/SphereFace-loss-function.png?resize=433%2C413&amp;ssl=1"/><figcaption><em>Source: Author</em></figcaption></figure></div>



<p>优势</p>



<h5>该损失函数直接与角度变量一起工作，这更符合如前所述的数据的内在分布。</h5>



<ul><li>它不需要将训练样本复杂地重组成对或三元组。</li><li>这种损失有助于减少<em>类内</em>距离，同时增加<em>类间</em>距离(在分母中可以清楚地看到，因为<em>类内</em>角度比<em>类间</em>角度受到更大的惩罚)</li><li>不足之处</li></ul>



<h5>原论文做了几个近似和假设(如<em> m </em>被约束为整数)。</h5>



<ul><li>随着<em> m </em>的增加，余弦函数的局部极小值也来到可能的θ的范围内，在此之后该函数是非单调的(即在θ = /m之后)。</li><li>作者需要对原始损失函数进行分段修正来解决这个问题。</li><li>代码示例</li></ul>



<h5>大幅度余弦损失(又名余弦损失)</h5>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SphereFaceLoss</span><span class="hljs-params">(W, x, m)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">(y_true, x)</span>:</span>

        
        M = (m<span class="hljs-number">-1</span>) * y_true + <span class="hljs-number">1</span>

        
        normalized_W, norms = tf.linalg.normalize(W, axis=<span class="hljs-number">0</span>)

        
        y_pred = x * normalized_W

        
        
        

        cos_theta, norm_x = tf.linalg.normalize(y_pred, axis=<span class="hljs-number">1</span>)
        theta = tf.acos(cos_theta)

        
        new_theta = theta * M
        new_cos_theta = tf.cos(new_theta)
        new_y_pred = norm_x * new_cos_theta

        
        numerators = tf.reduce_sum(y_true * tf.exp(new_y_pred), axis=<span class="hljs-number">1</span>)
        denominators = tf.reduce_sum(tf.exp(new_y_pred), axis=<span class="hljs-number">1</span>)
        loss = - tf.reduce_sum(tf.log(numerators / denominators))

        <span class="hljs-keyword">return</span> loss
    <span class="hljs-keyword">return</span> inner</pre>



<h4>背景/动机</h4>



<h5>这种损失是由与SphereFace相同的推理引起的，但是论文的作者声称它更容易理解和执行。</h5>



<ul><li>定义</li></ul>



<h5>在这种损失中，特征向量也被归一化(类似于W <sub> j </sub>)并通过常数因子<em> s </em>进行缩放</h5>



<ul><li>余量<em> m </em>被加到角度的余弦上。公式是:</li><li>余弦函数修改如下(绿色未修改):</li></ul>







<ul><li>优势</li></ul>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img decoding="async" loading="lazy" src="../Images/c1140b8b70b60f49b6a3209299f33651.png" alt="Cosine loss function" class="wp-image-47860" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221231065532im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Cosine-loss-function.png?resize=514%2C517&amp;ssl=1"/><figcaption><em>Source: Author</em></figcaption></figure></div>



<h5>与SphereFace不同，余弦函数的非单调性不会产生问题。</h5>



<ul><li>因为特征向量也被归一化，所以模型必须学习更好的角度分离，因为它没有通过学习不同的范数来减少损失的自由。</li><li>代码示例</li></ul>



<h5>附加角裕度损失(又名弧面)</h5>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">CosFaceLoss</span><span class="hljs-params">(W, m, s)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">(y_true, x)</span>:</span>
        
        y_true = tf.cast(y_true, dtype=tf.float32)
        M = m * y_true

        
        

        dot_product = tf.matmul(x, W)
        cos_theta, cos_theta_norm = tf.linalg.normalize(dot_product,axis=<span class="hljs-number">0</span>)

        
        
        y_pred = s * cos_theta - M

        
        numerators = tf.reduce_sum(y_true * tf.exp(y_pred), axis=<span class="hljs-number">1</span>)
        denominators = tf.reduce_sum(tf.exp(y_pred), axis=<span class="hljs-number">1</span>)
        loss = - tf.reduce_sum(tf.math.log(numerators/denominators))
        <span class="hljs-keyword">return</span> loss
    <span class="hljs-keyword">return</span> inner</pre>



<h4>背景/动机</h4>



<h5>这是angular softmax损失系列中的又一损失。论文的作者声称它比它的前辈有更好的性能和更清晰的几何解释。</h5>



<ul><li>定义</li></ul>



<h5>这里，cos函数内部的余量被添加到角度本身。</h5>



<ul><li>优势</li></ul>







<h5>这里的余量<em> m </em>可以解释为半径<em> s </em>的超球面上的附加弧长</h5>



<ul><li>(从实验来看)在具有大致相同的<em>类内</em>相似性的同时，类间差异似乎比三重丢失更好。</li><li>该论文中的模型优于前面提到的论文中的所有模型。</li><li>余弦函数修改如下(绿色未修改):</li><li>不足之处</li></ul>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img decoding="async" loading="lazy" src="../Images/2fc22d59744632efe239fcf92658dca6.png" alt="Additive angular margin loss" class="wp-image-47862" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221231065532im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Additive-angular-margin-loss.png?resize=466%2C444&amp;ssl=1"/><figcaption><em>Source: Author</em></figcaption></figure></div>



<h5>余弦函数的非单调性会在θ值大于<em>–</em><em>m</em>时产生问题，但作者似乎没有具体解决这个问题。</h5>



<ul><li>代码示例</li></ul>



<h5>基于表征学习的损失函数</h5>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ArcFaceLoss</span><span class="hljs-params">(W, m)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">(y_true, x)</span>:</span>
        
        M = (m<span class="hljs-number">-1</span>) * y_true + <span class="hljs-number">1</span>

        
        normalized_W, norms_w = tf.linalg.normalize(W, axis=<span class="hljs-number">0</span>)
        normalized_x, norms_x = tf.linalg.normalize(x, axis=<span class="hljs-number">0</span>)

        
        
        
        cos_theta = normalized_x * normalized_W

        theta = tf.acos(cos_theta)

        
        new_theta = theta + M
        new_cos_theta = tf.cos(new_theta)

        
        y_pred = s * new_cos_theta

        
        numerators = tf.reduce_sum(y_true * tf.exp(y_pred), axis=<span class="hljs-number">1</span>)
        denominators = tf.reduce_sum(tf.exp(y_pred), axis=<span class="hljs-number">1</span>)
        loss = - tf.reduce_sum(tf.log(numerators / denominators))

        <span class="hljs-keyword">return</span> loss

    <span class="hljs-keyword">return</span> inner</pre>



<h2 id="h-loss-functions-based-on-representation-learning">明确的反面例子</h2>



<h3>对比损失</h3>



<h4>背景/动机</h4>



<h5>这是人脸识别中最著名的损失函数之一。</h5>



<ul><li>这种损失背后的动机是开发一种模型，该模型将学习在特征空间中表示图像，使得该空间中的距离将对应于原始空间中的语义距离。</li><li>这种损失是基于神经网络的连体结构</li><li>定义</li></ul>



<h5>数据集由属于相同类别(y <sub> i </sub> = 1)或不同类别(y <sub> i </sub> = 0)的图像对组成。</h5>











<ul><li>每幅图像(x <sub> i，1 </sub>，x <sub> i，2 </sub>)通过基神经网络，得到其特征向量(f(x <sub> i，1 </sub>)，f(x <sub> i，2 </sub>)。则d <sub> i </sub>为嵌入之间的距离，即d <sub> i </sub> = || f(x <sub> i，1</sub>)–f(x<sub>I，2 </sub> ) ||</li><li>如果这一对属于同一类，那么如果嵌入的距离很近，损失就比较小。否则，模型会尝试让配对之间至少相隔<em>米</em>的距离。</li><li>优势</li></ul>



<h5>损失很简单理解。</h5>



<ul><li>Margin <em> m </em>作为一种控制，控制着模型将不同的嵌入分开的努力程度。</li><li>非常容易为新的/看不见的类别扩展训练的模型，因为模型学习创建图像的语义表示，而不是简单地在预定的类别集合中对其进行分类。</li><li>不足之处</li></ul>



<h5>对于<em> n </em>个图像，有O(n <sup> 2 </sup>个图像对。因此，覆盖所有可能的对在计算上是昂贵的。</h5>



<ul><li>裕量<em> m </em>对于所有不相似的对都是相同的常数，这隐含地告诉模型在所有不相似的对之间具有相同的距离是可以的，即使一些对比其他对更不相似。【<a href="https://web.archive.org/web/20221231065532/https://arxiv.org/pdf/1706.07567.pdf" target="_blank" rel="noreferrer noopener">酸</a>T4】cT6】e</li><li>这里使用了相似和不相似对的绝对概念，它不能从一个上下文转移到另一个上下文。例如，在随机对象的图像对上训练的模型在仅在人的图像数据集上测试时将很难表现良好。[ <a href="https://web.archive.org/web/20221231065532/https://arxiv.org/pdf/1412.6622.pdf" target="_blank" rel="noreferrer noopener nofollow">来源</a></li><li>代码示例</li></ul>



<h5>三重损失</h5>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">contrastive_loss</span><span class="hljs-params">(m)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">(y_true, d)</span>:</span>
        loss = tf.reduce_mean(y_true*d+(<span class="hljs-number">1</span>-y_true)*tf.maximum(m-d, <span class="hljs-number">0</span>))
        <span class="hljs-keyword">return</span> loss
    <span class="hljs-keyword">return</span> inner </pre>



<h4>背景/动机</h4>



<h5>三重损失可能是人脸识别中最著名的损失函数。</h5>



<ul><li>数据被排列成三个一组的图像:锚、正例、反例。</li><li>图像通过一个共同的网络，目的是减少锚正距离，同时增加锚负距离。</li><li>损失基础的架构如下所示:</li><li>定义</li></ul>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img decoding="async" loading="lazy" src="../Images/5cda8457303a0a1b95987d114fb30455.png" alt="Triplet loss" class="wp-image-47864" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221231065532im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Triplet-loss.png?resize=478%2C554&amp;ssl=1"/><figcaption><em>Source: Original image from <a href="https://web.archive.org/web/20221231065532/https://arxiv.org/pdf/1412.6622.pdf" target="_blank" rel="noreferrer noopener nofollow">this</a> paper with modifications by author</em></figcaption></figure></div>



<h5>这里，A <sub> i </sub>，P <sub> i </sub>，N <sub> i </sub>，分别是主播，正面例子，反面例子形象。</h5>











<ul><li>f(A <sub> i </sub>)，f(P <sub> i </sub>)，f(N <sub> i </sub>)是这些图像在特征空间中的嵌入。</li><li>余量为<em>米</em></li><li>优势</li></ul>



<h5>意象的相似和相异的概念只是在相对意义上使用，而不是像对比损失那样在绝对意义上定义。</h5>



<ul><li>尽管对于所有的三连音来说余量<em> m </em>是相同的，但是在每种情况下锚负距离(d<sup>–</sup>)可以是不同的，因为锚正距离(d <sup> + </sup>)是不同的。</li><li>最初的论文声称胜过基于损失的对比模型。</li><li>不足之处</li></ul>



<h5>对d <sup> + </sup>和d<sup>–</sup>的惩罚被约束为相同。损失是无视(d<sup>+</sup>–d<sup>–</sup>)值的根本原因:高d <sup> + </sup> vs低d<sup>–</sup>。这是低效的。[ <a href="https://web.archive.org/web/20221231065532/https://arxiv.org/pdf/2002.10857.pdf" target="_blank" rel="noreferrer noopener nofollow">来源</a></h5>



<ul><li>代码示例</li></ul>



<h5>圆形损失</h5>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">triplet_loss</span><span class="hljs-params">(m)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">(d_pos, d_neg)</span>:</span>
        loss = tf.square(tf.maximum(d_pos - d_neg + m, <span class="hljs-number">0</span>))
        loss = tf.reduce_mean(loss)
        <span class="hljs-keyword">return</span> loss
    <span class="hljs-keyword">return</span> inner</pre>



<h4>背景/动机</h4>



<h5>受上面提到的三重态损失的不利影响，<a href="https://web.archive.org/web/20221231065532/https://arxiv.org/pdf/2002.10857.pdf" target="_blank" rel="noreferrer noopener nofollow">本文的作者</a>提出了一个损失函数来解决这个问题。</h5>



<ul><li>该论文还提出了一个框架，该框架将基于分类的损失和基于表示学习的损失统一在一个保护伞下。</li><li>定义</li></ul>



<h5>损失使用的是两幅图像之间的相似性概念，而不是距离。比方说，这种相似性可以是点积。</h5>



<ul><li>该文件还提供了一个类似softmax的损失公式，以固定类别数表示。这里，我们将只考虑相似和不相似对的公式。</li><li>设有K个具有相似度s<sup>I</sup>T2】p= { 1，2，3，…，K}和M个具有相似度s<sub>n</sub>T6】j= { 1，2，3，…，L}的负相关像对</li><li>那么损失定义为:</li><li>这里，是超参数，是系数，可以更好地控制各项对损耗的影响。</li></ul>







<ul><li>它们被定义为:</li><li>这里，O <sub> p </sub>和O <sub> n </sub>是分别表示正图像对和负图像对中相似度的最佳值的超参数。</li></ul>











<ul><li>这导致了一个循环决策边界，如图所示:</li><li>优势</li></ul>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img decoding="async" loading="lazy" src="../Images/9c93d32ef91aff42438263b3e2357871.png" alt="Cirle loss" class="wp-image-47866" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221231065532im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Cirle-loss.png?resize=671%2C371&amp;ssl=1"/><figcaption><em>(a) Decision boundary with Triplet loss (b) Decision Boundary with Circle Loss [<a href="https://web.archive.org/web/20221231065532/https://arxiv.org/pdf/2002.10857.pdf" target="_blank" rel="noreferrer noopener nofollow">source</a>]</em></figcaption></figure></div>



<h5>圆损耗比三重损耗具有更明确的收敛目标，因为在(S <sub> n </sub>，S <sub> p </sub>空间中有一个单点，优化被驱动向该单点(O <sub> n </sub>，O <sub> p </sub></h5>



<ul><li>不足之处</li></ul>



<h5>这里，O <sub> p </sub>和O <sub> n </sub>的选择有些随意</h5>



<ul><li>需要显式的反例挖掘(或者在替换公式中，类的数量是固定的)</li><li>代码示例</li></ul>



<h5>该代码使用了纸张损耗的简化表达式</h5>



<ul><li>没有明确的反面例子</li></ul>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">circle_loss</span><span class="hljs-params">(s_pos, O_pos, s_neg, O_neg, gamma)</span>:</span>
    alpha_pos = tf.maximum(O_pos - s_pos, <span class="hljs-number">0</span>)
    alpha_neg = tf.maximum(O_neg - s_neg, <span class="hljs-number">0</span>)

    sum_neg = tf.reduce_sum(tf.exp(gamma * alpha_neg * s_neg))
    sum_pos = tf.reduce_sum(tf.exp(<span class="hljs-number">-1</span> * gamma * alpha_pos * s_pos))

    loss = tf.log(<span class="hljs-number">1</span> + sum_neg * sum_pos)

    <span class="hljs-keyword">return</span> loss</pre>



<h3>巴洛双胞胎</h3>



<h4>背景/动机</h4>



<h5>这是一个<a href="/web/20221231065532/https://neptune.ai/blog/self-supervised-learning" target="_blank" rel="noreferrer noopener">自我监督学习(SSL) </a>的例子。SSL中的一种常见方法是学习对输入图像的失真不变的图像表示。</h5>



<ul><li>这种方法中的一个常见问题是崩溃到平凡解，即所有图像的相同常数表示。</li><li><a href="https://web.archive.org/web/20221231065532/https://arxiv.org/pdf/2103.03230.pdf" target="_blank" rel="noreferrer noopener nofollow">本文</a>提出了一种损失函数，该函数抑制同一图像的两种不同表示之间的互相关。</li><li>定义</li></ul>



<h5>图像受到2种不同的(随机选择的)失真，并通过共享权重的连体结构:</h5>



<ul><li>损失函数定义为:</li></ul>







<ul><li>其中每一项C <sub> ij </sub>计算如下:</li></ul>







<ul><li>z是学习的表示向量。下标I，j分别表示矢量表示的第i <sup>个</sup>和第j <sup>个</sup>分量。上标A、B表示同一输入图像的不同失真版本。下标b表示批次中的索引。</li></ul>







<ul><li>优势</li></ul>



<h5>这种方法不需要固定数量的类</h5>



<ul><li>它也不会受到数据膨胀的影响，因为它不需要明确的反面例子</li><li>不足之处</li></ul>



<h5>该论文中的模型需要最终表示的大维数以获得良好的性能。</h5>



<ul><li>对于消除输入的某些失真，性能并不稳定。</li><li>simsimi代码示例</li></ul>



<h5>背景/动机</h5>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">import</span> tensorflow_probability <span class="hljs-keyword">as</span> tfp

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">barlow_twins_loss</span><span class="hljs-params">(lamda_bt)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">(z_a, z_b,)</span>:</span>
        correlation_matrix = tfp.stats.correlation(z_a, z_b)
        identity_matrix = tf.eye(correlation_matrix.shape[<span class="hljs-number">0</span>])
        loss = tf.reduce_sum(tf.abs(identity_matrix - correlation_matrix))
        <span class="hljs-keyword">return</span> loss
    <span class="hljs-keyword">return</span> inner</pre>



<h4>这个损失是在<a href="https://web.archive.org/web/20221231065532/https://arxiv.org/pdf/2011.10566.pdf" target="_blank" rel="noreferrer noopener nofollow">这篇论文</a>中提出的。</h4>



<h5>本文试图构建一个最简单的连体建筑，它可以很好地表达图像。</h5>



<ul><li>定义</li><li>损失基于以下架构:</li></ul>



<h5>这里，stop-grad意味着z <sub> 2 </sub>被视为常数，并且编码器网络的权重不从其接收任何梯度更新。</h5>



<ul><li>在最终损失表达式中，添加了另一个对称项，预测器网络位于右分支而不是左分支。</li></ul>







<ul><li>单个图像的损失为:</li><li>其中每一项定义如下:(|| || <sub> 2 </sub>是L<sub>2</sub>-范数)</li><li>这是整个批次的总和或平均值。</li></ul>







<ul><li>优势</li></ul>







<ul><li>这种损失不需要明确的反面例子挖掘</li></ul>



<h5>它不需要固定数量的类</h5>



<ul><li>与SimCLR或BYOL(本文未讨论)不同，它也不需要大批量</li><li>不足之处</li><li>这篇论文不能从理论上解释为什么这个模型不能塌缩成一个平凡的解(常数表示)，而只能从经验上证明它。</li></ul>



<h5>代码示例</h5>



<ul><li>运行中的示例代码</li></ul>



<h5>本文探讨的每种损失都有利弊。对于一个给定的问题，很难预测哪种损失效果最好。你需要在训练中进行大量的实验，以找到最适合你的情况的解决方案。</h5>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SimSiamLoss</span><span class="hljs-params">(p_1, p_2, z_1, z_2)</span>:</span>

    cosine_loss = tf.keras.losses.CosineSimilarity(axis=<span class="hljs-number">1</span>)
    D_1 = cosine_loss(p_1, tf.stop_gradient(z_2))
    D_2 = cosine_loss(p_2, tf.stop_gradient(z_1))
    loss = <span class="hljs-number">0.5</span> * (D_1 + D_2)

    <span class="hljs-keyword">return</span> loss</pre>



<h2 id="h-example-code-in-action">Neptune提供了一个很好的工具来监控模型的损失(和其他指标)。它还能与您可能正在使用的其他工具/框架无缝协作。以下代码显示了如何将MNIST数字分类器模型的陪面损失与TensorFlow中的简单Neptune回调合并。</h2>



<p>您可以使用CosFace和ArcFace loss分别运行一次以下脚本。只需注释/取消注释所需损失函数的函数调用(第83行)。</p>



<p>借助Neptune上的“比较运行”选项，我能够比较两者的性能:</p>



<p>由于两种损失的函数形式不同，直接比较两种损失的绝对值意义不大(但它们的总体趋势可能会提供信息)。为了更好地比较性能，我们来看看结果的准确性。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">import</span> neptune.new <span class="hljs-keyword">as</span> neptune
<span class="hljs-keyword">from</span> neptune.new.integrations.tensorflow_keras <span class="hljs-keyword">import</span> NeptuneCallback

run = neptune.init(project=<span class="hljs-string">'common/tf-keras-integration'</span>,
api_token=<span class="hljs-string">'ANONYMOUS'</span>)

mnist = tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / <span class="hljs-number">255.0</span>, x_test / <span class="hljs-number">255.0</span>

y_train = tf.one_hot(y_train, <span class="hljs-number">10</span>)
y_test = tf.one_hot(y_test, <span class="hljs-number">10</span>)

model_input = tf.keras.Input((<span class="hljs-number">28</span>, <span class="hljs-number">28</span>))
flat = tf.keras.layers.Flatten()(model_input)
dense_1 = tf.keras.layers.Dense(<span class="hljs-number">32</span>, activation=tf.keras.activations.relu)(flat)
dense_2 = tf.keras.layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'sigmoid'</span>)(dense_1)
dense_2.trainable = <span class="hljs-keyword">False</span>

model = tf.keras.models.Model(inputs=model_input, outputs=[dense_1, dense_2])
model.build(input_shape=(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>))
model.summary()

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">CosFaceLoss</span><span class="hljs-params">(W, m, s)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">(y_true, x)</span>:</span>
        
        y_true = tf.cast(y_true, dtype=tf.float32)
        M = m * y_true

        
        

        dot_product = tf.matmul(x, W)
        cos_theta, cos_theta_norm = tf.linalg.normalize(dot_product,axis=<span class="hljs-number">0</span>)

        
        
        y_pred = s * cos_theta - M

        
        numerators = tf.reduce_sum(y_true * tf.exp(y_pred), axis=<span class="hljs-number">1</span>)
        denominators = tf.reduce_sum(tf.exp(y_pred), axis=<span class="hljs-number">1</span>)
        loss = - tf.reduce_sum(tf.math.log(numerators/denominators))
        <span class="hljs-keyword">return</span> loss
    <span class="hljs-keyword">return</span> inner

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ArcFaceLoss</span><span class="hljs-params">(W, m, s)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">(y_true, x)</span>:</span>
        
        M = (m<span class="hljs-number">-1</span>) * y_true + <span class="hljs-number">1</span>

        
        
        
        dot_product = tf.matmul(x, W)
        cos_theta,cos_theta_norms = tf.linalg.normalize(dot_product,axis=<span class="hljs-number">0</span>)

        theta = tf.acos(cos_theta)

        
        new_theta = theta + M
        new_cos_theta = tf.cos(new_theta)

        
        y_pred = s * new_cos_theta

        
        numerators = tf.reduce_sum(y_true * tf.exp(y_pred), axis=<span class="hljs-number">1</span>)
        denominators = tf.reduce_sum(tf.exp(y_pred), axis=<span class="hljs-number">1</span>)
        loss = - tf.reduce_sum(tf.log(numerators / denominators))

        <span class="hljs-keyword">return</span> loss

    <span class="hljs-keyword">return</span> inner
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dummy_loss</span><span class="hljs-params">(ytrue, ypred)</span>:</span>
    <span class="hljs-keyword">return</span> tf.constant([<span class="hljs-number">0</span>])



loss_func = CosFaceLoss(W=model.layers[<span class="hljs-number">-1</span>].weights[<span class="hljs-number">0</span>], m=<span class="hljs-number">10.0</span>, s=<span class="hljs-number">10.0</span>)


model.compile(optimizer=<span class="hljs-string">'adam'</span>, metrics=[<span class="hljs-string">'accuracy'</span>],
              loss=[loss_func, dummy_loss])

neptune_cbk = NeptuneCallback(run=run, base_namespace=<span class="hljs-string">'metrics'</span>)

model.fit(x_train,y_train,epochs=<span class="hljs-number">5</span>,batch_size=<span class="hljs-number">64</span>,callbacks=[neptune_cbk])</pre>



<p>从这个图来看，ArcFace loss在这里的表现似乎更好。请记住，这只是一个玩具示例，在真实世界的数据集中，结果可能会有所不同，并且可能需要对边缘值和其他超参数进行更广泛的实验。</p>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img decoding="async" loading="lazy" src="../Images/66732c6e6b66f300c0d843dce10298d5.png" alt="Loss in Neptune" class="wp-image-47893" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221231065532im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Loss-in-Neptune.png?resize=548%2C405&amp;ssl=1"/><figcaption><em>The blue curve represents CosFace loss and the purple represents ArcFace. X-axis is the batch number and Y-axis is the loss value. <em>| Source: <a href="https://web.archive.org/web/20221231065532/https://app.neptune.ai/charudatta.manwatkar/my-first-neptune/experiments?split=cmp&amp;dash=charts&amp;viewId=standard-view" target="_blank" rel="noreferrer noopener">Author’s Neptune project</a></em></em></figcaption></figure></div>



<p>检查如何<a href="https://web.archive.org/web/20221231065532/https://docs.neptune.ai/integrations-and-supported-tools/model-training/tensorflow-keras" target="_blank" rel="noopener">跟踪和监控您的TensorFlow模型训练</a>(包括损失、指标、超参数、硬件消耗等)。</p>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img decoding="async" loading="lazy" src="../Images/8c6dec85adc208be1760347fee6caa15.png" alt="Accuracy in Neptune" class="wp-image-47897" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221231065532im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Accuracy-in-Neptune-1.png?resize=554%2C405&amp;ssl=1"/><figcaption><em>The blue curve represents CosFace loss and the purple represents ArcFace. X-axis is the epoch number and Y-axis is the accuracy. | Source: <a href="https://web.archive.org/web/20221231065532/https://app.neptune.ai/charudatta.manwatkar/my-first-neptune/experiments?split=cmp&amp;dash=charts&amp;viewId=standard-view" target="_blank" rel="noreferrer noopener">Author’s Neptune project</a></em></figcaption></figure></div>



<p>结论</p>



<section id="blog-intext-cta-block_60c76ad4a88a5" class="block-blog-intext-cta  c-box c-box--default c-box--dark c-box--no-hover c-box--standard ">

            
    
            <p>损失函数可能是人脸识别模型中最重要的组成部分。本文中讨论的每个损失函数都有一组独特的特征。有些提供了对类分离的强大控制，有些提供了更好的可伸缩性和可扩展性。我希望这篇文章能帮助您更好地理解可用的选项以及它们对您的特定问题的适用性。我很想听听你对我提到的和我遗漏的问题的看法。感谢阅读！</p>
    
    </section>



<h2 id="h-conclusion">Conclusion</h2>



<p>Loss Function is possibly the most important component of a Face Recognition model. Each loss function discussed in this article comes with a unique set of characteristics. Some provide great control over class separations, others provide better scalability and extensibility.  I hope this article helps you develop a better understanding of the available options and their suitability for your particular problem. I would love to hear your thoughts on the ones I mentioned and also the ones I left out. Thanks for reading!</p>
        </div>
        
    </div>    
</body>
</html>