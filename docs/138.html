<html>
<head>
<title>Implementing Customer Segmentation Using Machine Learning [Beginners Guide] </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用机器学习实现客户细分[初学者指南]</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/customer-segmentation-using-machine-learning#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/customer-segmentation-using-machine-learning#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p>如今，你可以个性化一切。没有一刀切的方法。但是，对于企业来说，这其实是一件很棒的事情。它为良性竞争创造了大量空间，也为企业创造了获得和留住客户的创造性机会。</p>



<p>实现更好的个性化的一个基本步骤是客户细分。这是个性化开始的地方，适当的细分将帮助你做出关于新功能、新产品、定价、营销策略，甚至是应用内推荐的决定。</p>



<p>但是，手动进行分段可能会很累人。为什么不使用机器学习来为我们做这件事呢？在本文中，我将告诉你如何做到这一点。</p>



<h2 id="what">什么是客户细分</h2>



<p><a href="https://web.archive.org/web/20221206005800/https://www.optimove.com/resources/learning-center/customer-segmentation" target="_blank" rel="noreferrer noopener nofollow">客户细分</a>简单来说就是根据各种特征对您的客户进行分组(例如根据年龄对客户进行分组)。</p>



<p>这是组织了解客户的一种方式。了解客户群体之间的差异，就更容易做出关于产品增长和营销的战略决策。</p>



<p>细分市场的机会是无限的，这主要取决于你有多少客户数据可供使用。从基本标准开始，如性别、爱好或年龄，一直到“在网站X上花费的时间”或“自用户打开我们的应用程序以来的时间”。</p>



<p>客户细分有不同的方法，它们取决于四种类型的参数:</p>



<ul><li>地理，</li><li>人口统计学，</li><li>行为上的，</li><li>心理上。</li></ul>



<p><strong>地理</strong>客户细分非常简单，都是关于用户的位置。这可以通过多种方式实现。您可以按国家、州、城市或邮政编码分组。</p>



<p><strong>人口统计</strong>细分与客户的结构、规模和在空间和时间上的移动有关。许多公司利用性别差异来创造和营销产品。父母身份是另一个重要特征。你可以从客户调查中获得这样的数据。</p>



<p><strong>行为</strong>客户细分基于过去观察到的客户行为，可用于预测未来行动。比如顾客购买的品牌，或者购买最多的瞬间。客户细分的行为方面不仅试图了解购买的原因，还试图了解这些原因在一年中是如何变化的。</p>



<p>顾客的心理细分通常涉及性格特征、态度或信仰。这些数据是通过客户调查获得的，可以用来衡量客户情绪。</p>



<h2 id="advantages">客户细分的优势</h2>



<p>实施客户细分会带来大量新的商机。您可以在以下方面进行大量优化:</p>



<ul><li>预算，</li><li>产品设计，</li><li>推广，</li><li>营销，</li><li>客户满意度。</li></ul>



<p>让我们更深入地讨论这些好处。</p>







<p>没有人喜欢投资那些不能产生新客户的活动。大多数公司都没有庞大的营销预算，所以钱必须花在正确的地方。细分使您能够首先锁定具有最高潜在价值的客户，因此您可以从营销预算中获得最大收益。</p>







<p>客户细分有助于你了解你的用户需要什么。您可以识别最活跃的用户/客户，并根据他们的需求优化您的应用/产品。</p>







<p>正确实施的客户细分有助于您规划特别优惠和交易。在过去的几年里，频繁的交易已经成为电子商务和商业软件的主要内容。如果你在正确的时间给客户提供了正确的报价，他们就有很大的机会购买。客户细分将帮助您完美定制您的特别优惠。</p>







<p>通过细分可以直接改善营销策略，因为您可以利用客户最常用的渠道为不同的客户群规划个性化的营销活动。</p>







<p>通过研究不同的客户群体，你可以了解他们最看重你公司的什么。这些信息将帮助您创建完全符合客户偏好的个性化产品和服务。</p>



<p>在下一部分，我们将讨论机器学习为什么用于客户细分。</p>



<h2 id="ml">面向客户细分的机器学习</h2>



<p>机器学习方法是分析客户数据和发现洞察力和模式的伟大工具。人工智能模型是决策者的有力工具。他们可以精确地识别客户群，这是手工或传统分析方法难以做到的。</p>



<p>机器学习算法有很多种，每一种都适合特定类型的问题。适用于客户细分问题的一种非常常见的<strong>机器学习算法是k均值聚类算法</strong>。还有其他聚类算法，如DBSCAN、凝聚聚类和BIRCH等。</p>



<p>为什么要为客户细分实现机器学习？</p>



<h3>更多的时间</h3>



<p>手动客户细分非常耗时。手动分析成堆的数据并找到模式需要几个月甚至几年的时间。此外，如果启发式地完成，它可能没有预期的有用的准确性。</p>



<p>客户细分过去是手动完成的，并且不太精确。您需要手动创建和填充不同的数据表，并像侦探戴着镜子一样分析数据。现在，仅仅使用机器学习要好得多(并且由于ML的快速发展而相对容易)，这可以腾出你的时间来专注于需要创造力来解决的更高要求的问题。</p>



<h3>易于再培训</h3>



<p>客户细分不是一个“开发一次，永远使用”的项目。数据是不断变化的，趋势是振荡的，在您的模型部署后，一切都在不断变化。通常，更多的标记数据在开发后变得可用，这对于提高模型的整体性能是一个很好的资源。</p>



<p>有许多方法可以更新客户细分模型，但这里有两种主要方法:</p>



<ul><li>以旧模式为起点，重新训练。</li><li>保留现有模型，并将其输出与新模型相结合。</li></ul>



<h3>更好的缩放</h3>



<p>由于云基础设施，在生产中部署的机器学习模型支持可扩展性。这些模型对于未来的变化和反馈非常灵活。例如，假设一家公司今天有10000名客户，他们实施了一个客户细分模型。一年后，如果公司有100万客户，那么理想情况下，我们不需要创建一个单独的项目来处理这些增加的数据。机器学习模型具有处理更多数据和生产规模的内在能力。</p>



<h3>更高的精度</h3>



<p>对于给定的客户数据，使用机器学习方法(如elbow方法)很容易找到最佳聚类数的值。当我们使用机器学习时，不仅最优的聚类数，而且模型的性能也要好得多。</p>







<h2 id="dataset">探索客户数据集及其特征</h2>



<p>让我们分析一个客户数据集。我们的数据集有24，000个数据点和四个特征。其特点是:</p>



<ul><li>客户ID–这是特定企业的客户ID。</li><li>购买的产品–该功能表示客户一年中购买的产品数量。</li><li>投诉–该列值表示客户去年提出的投诉数量</li><li>支出金额–该列值表示客户去年支付的金额。</li></ul>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/1d95115e71fb247f8b9e591f6c782bab.png" alt="Customer segmentation - dataset" class="wp-image-48051" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206005800im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Customer-segmentation-dataset.png?ssl=1"/></figure>



<p>在接下来的部分，我们将预处理这个数据集。</p>



<h2 id="preprocessing">预处理数据集</h2>



<p>在将数据输入k-means聚类算法之前，我们需要预处理数据集。让我们为客户数据集实现必要的预处理。</p>



<figure class="wp-block-image size-large is-resized"><img decoding="async" loading="lazy" src="../Images/e589a71408a2eda028c5ea8325aaf5ed.png" alt="Customer segmentation - dataset" class="wp-image-48052" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206005800im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Customer-segmentation-dataset-2.png?resize=692%2C427&amp;ssl=1"/></figure>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/7298648e7e4fc5d374bf3bf639b29bf2.png" alt="Customer segmentation - dataset" data-original-src="https://web.archive.org/web/20221206005800im_/https://lh6.googleusercontent.com/QUOWiw3YI2SE5dhlcuee_FsB60nHCYzssL3mrxTH_TpKIdItmMp5is--irtIxF_gMDMXmx1SN8NXudiMMw9NEEQeEOsALLutCyMUhJjlQrJAqSDwQQJ9hSZrldm-wUWe1lNpTbY"/></figure>



<p>接下来，我们将用Python实现k-means聚类算法。</p>







<h2 id="implementing">在Python中实现K-means聚类</h2>



<p>K-Means聚类是解决数据聚类问题的一种有效的机器学习算法。这是一种非监督算法，非常适合解决客户细分问题。在我们继续之前，让我们快速探索两个关键概念</p>



<h3>无监督学习</h3>



<p>无监督机器学习与有监督机器学习截然不同。这是一种特殊的机器学习算法，可以从未标记的数据中发现数据集中的模式。</p>



<p>无监督的机器学习算法可以根据数据集中的相似属性对数据点进行分组。无监督模型的主要类型之一是聚类模型。</p>



<p>注意，监督学习帮助我们从先前的经验中产生一个输出。</p>



<h3>聚类算法</h3>



<p>聚类机器学习算法是一种无监督的机器学习算法。它用于发现数据集中的自然分组或模式。值得注意的是，聚类算法只是解释输入数据，并在其中找到自然的聚类。</p>



<p>一些最流行的聚类算法有:</p>



<ul><li>k均值聚类</li><li>凝聚层次聚类</li><li>期望最大化聚类</li><li>基于密度的空间聚类</li><li>均值漂移聚类</li></ul>



<p>在下一节中，我们将使用k-means聚类算法和机器学习来分析客户细分问题。但是，在此之前，让我们快速讨论一下为什么使用k-means聚类算法。</p>



<h3>为什么使用K-means聚类进行客户细分？</h3>



<p>与监督学习算法不同，K-means聚类是一种<a href="https://web.archive.org/web/20221206005800/https://blogs.oracle.com/ai-and-datascience/post/supervised-vs-unsupervised-machine-learning" target="_blank" rel="noreferrer noopener nofollow">非监督机器学习</a>算法。当我们有未标记的数据时，使用这种算法。未标记数据是指没有提供类别或组的输入数据。我们的客户细分数据对于这个问题是这样的。</p>



<p>该算法发现数据中的组(聚类),其中聚类的数量由K值表示。根据所提供的特征，该算法迭代地将每个输入数据分配给K个聚类之一。所有这些使得k-means非常适合客户细分问题。</p>



<p>给定一组数据点，根据特征相似性进行分组。K均值聚类算法的输出是:</p>



<ul><li>K个簇的质心值，</li><li>每个输入数据点的标签。</li></ul>



<p>在实施结束时，我们将获得输出，例如一组群集以及哪个客户属于哪个群集。</p>



<p>首先，我们需要实现所需的Python库，如下表所示。</p>



<pre class="hljs">

<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> KMeans
<span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px
<span class="hljs-keyword">import</span> plotly.graph_objects <span class="hljs-keyword">as</span> go
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
</pre>



<p>我们已经导入了pandas、NumPy sklearn、plotly和matplotlib库。Pandas和NumPy用于数据争论和操作，sklearn用于建模，plotly和matplotlib将用于绘制图形和图像。</p>



<p>导入库之后，我们的下一步是加载pandas数据框中的数据。为此，我们将使用熊猫的read_csv方法。</p>



<pre class="hljs">
customersdata = pd.read_csv(<span class="hljs-string">"customers-data.csv"</span>)
</pre>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/1cb6d283f1ae2d934b5058c37cfcdcef.png" alt="Customer segmentation - dataset" data-original-src="https://web.archive.org/web/20221206005800im_/https://lh6.googleusercontent.com/cUJZB1Uj9WggzV7hZaSE1H8Qvt0v8vnAEGc3EH5QTu8Be1nYXvMQanps40N78lsZqqK6M6EHTXTNW0x1bfsS_YNt42xiSTOSIHYtlNEJiwG1OOdUr53ThUMXFvfw6Cnq_0Ue8_Q"/></figure>



<p>加载数据后，我们需要定义K均值模型。这是在我们从sklearn导入的KMeans类的帮助下完成的，如下面的代码所示。</p>



<pre class="hljs">
kmeans_model = KMeans(init=<span class="hljs-string">'k-means++'</span>,  max_iter=<span class="hljs-number">400</span>, random_state=<span class="hljs-number">42</span>)
</pre>



<p>定义模型后，我们要使用训练数据集进行训练。这是通过使用fit方法实现的，如下面的代码所示。</p>



<pre class="hljs">
kmeans_model.fit(customersdata[[<span class="hljs-string">'products_purchased'</span>,<span class="hljs-string">'complains'</span>,
<span class="hljs-string">'money_spent'</span>]])
</pre>



<p>注意，我们将三个特性传递给fit方法，即products_purchased、complains和money _ spent。</p>



<p>尽管我们已经训练了一个K-means模型达到这些点，但我们还没有找到在这种客户细分情况下所需的最佳聚类数。对于给定的数据集，找到最佳的聚类数目对于产生高性能的k-means聚类模型是重要的。</p>



<p>在接下来的部分中，我们将找到给定数据集的最佳聚类数，然后使用这些最佳k值重新训练k-means聚类模型。这将生成我们的最终模型。</p>



<h2 id="clusters">寻找最佳的聚类数</h2>



<p>实现k-means聚类算法的关键任务之一是找到最佳的聚类数。值得注意的是，K均值聚类模型可能会收敛于任何K值，但同时，并不是所有的K值都会产生最佳模型。</p>



<p>对于某些数据集，数据可视化有助于了解最佳聚类数，但这并不适用于所有数据集。我们有一些方法，如肘方法、间隙统计法和平均轮廓法，来评估给定数据集的最佳聚类数。我们将逐一讨论它们。</p>



<ul><li><strong>肘方法</strong>使用总的组内平方和值来寻找最佳组数的值。这代表了所生成的集群彼此之间的分散程度。在这种情况下，K-means算法针对K的几个值进行评估，并针对K的每个值计算类内平方和。之后，我们绘制K与平方和的关系图。在分析该图之后，选择聚类的数量，以便添加新的聚类不会显著改变平方和的值。</li><li><strong>平均轮廓法</strong>是一种衡量每个数据点与其对应聚类拟合程度的方法。该方法评估聚类的质量。作为一般规则，高平均轮廓宽度表示更好的聚类输出。</li><li><strong>缺口统计方法</strong>是对缺口统计值的衡量。间隙统计是不同k值的总簇内变化与其预期值之间的差异。该计算使用数据点的零参考分布来完成。最佳聚类数是使间隙统计值最大化的值。</li></ul>



<p>我们将使用肘法。K-means聚类算法通过将给定的数据点分成K组等方差来对数据进行聚类。这有效地最小化了一个叫做惯性的参数。在这种情况下，惯性只不过是群内距离的平方和。</p>



<p>当我们使用肘方法时，我们从2开始逐渐增加簇的数量，直到达到添加更多簇不会导致惯性值显著下降的簇的数量。</p>



<p>达到这个分类数的阶段称为分类模型的肘部。我们会看到在我们的例子中K =5。</p>



<p>为了实现肘方法，首先创建名为“try_different_clusters”的函数。它接受两个值作为输入:</p>



<ul><li>k(簇的数量)，</li><li>数据(输入数据)。</li></ul>



<pre class="hljs">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">try_different_clusters</span><span class="hljs-params">(K, data)</span>:</span>

    cluster_values = list(range(<span class="hljs-number">1</span>, K+<span class="hljs-number">1</span>))
    inertias=[]

    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> cluster_values:
        model = KMeans(n_clusters = c,init=<span class="hljs-string">'k-means++'</span>,max_iter=<span class="hljs-number">400</span>,random_state=<span class="hljs-number">42</span>)
        model.fit(data)
        inertias.append(model.inertia_)

    <span class="hljs-keyword">return</span> inertias
</pre>



<p>下面的代码调用了try_different_clusters方法，其中我们将K的值从1传递到12，并计算K的每个值的惯性。</p>



<pre class="hljs">
outputs = try_different_clusters(<span class="hljs-number">12</span>, customersdata[[<span class="hljs-string">'products_purchased'</span>,<span class="hljs-string">'complains'</span>,<span class="hljs-string">'money_spent'</span>]])
distances = pd.DataFrame({<span class="hljs-string">"clusters"</span>: list(range(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>)),<span class="hljs-string">"sum of squared distances"</span>: outputs})
</pre>



<p>使用下面的代码，我们绘制了K值(在x轴上)相对于Y轴上相应的惯性值。</p>



<pre class="hljs">
figure = go.Figure()
figure.add_trace(go.Scatter(x=distances[<span class="hljs-string">"clusters"</span>], y=distances[<span class="hljs-string">"sum of squared distances"</span>]))

figure.update_layout(xaxis = dict(tick0 = <span class="hljs-number">1</span>,dtick = <span class="hljs-number">1</span>,tickmode = <span class="hljs-string">'linear'</span>),
                  xaxis_title=<span class="hljs-string">"Number of clusters"</span>,
                  yaxis_title=<span class="hljs-string">"Sum of squared distances"</span>,
                  title_text=<span class="hljs-string">"Finding optimal number of clusters using elbow method"</span>)
figure.show()
</pre>



<p>我们可以使用上面的代码生成下图。代码的拐点在K=5处。我们已经选择了5，如果我们将集群的数量增加到5个以上，那么惯性或平方距离的和会有非常小的变化。</p>







<p><strong>K = 5的最佳值</strong></p>



<p>聚类数达到最佳值的阶段称为聚类模型的拐点。例如，在下图中，肘部位于五个簇处(K =5)。添加5个以上的集群将导致创建效率低下或性能较差的集群模型。</p>



<p>如前所述，我们需要使用找到的最佳聚类数再次训练k-means聚类模型。</p>



<pre class="hljs">
kmeans_model_new = KMeans(n_clusters = <span class="hljs-number">5</span>,init=<span class="hljs-string">'k-means++'</span>,max_iter=<span class="hljs-number">400</span>,random_state=<span class="hljs-number">42</span>)

kmeans_model_new.fit_predict(customersdata[[<span class="hljs-string">'products_purchased'</span>,<span class="hljs-string">'complains'</span>,<span class="hljs-string">'money_spent'</span>]])
</pre>



<p>请注意，我们使用fit_predict方法来训练模型。</p>



<p>在下一节中，我们将讨论如何在三维空间中可视化客户细分群。</p>



<h2 id="visualizing">可视化客户群</h2>



<p>在本节中，我们将使用plotly express实现一些代码。通过这种方式，我们可以用k-means算法在三维空间中可视化聚类。Plotly express是一个基于Plotly的库，可处理多种类型的数据集并生成高度风格化的绘图。</p>



<p>首先，让我们向现有的客户数据集中添加一个名为“clusters”的新列。该列将能够表明哪个客户属于哪个集群。</p>



<pre class="hljs">
cluster_centers = kmeans_model_new.cluster_centers_
data = np.expm1(cluster_centers)
points = np.append(data, cluster_centers, axis=<span class="hljs-number">1</span>)
points
</pre>



<p>注意，我们在这里使用NumPy expm1方法。NumPy expm1函数为NumPy数组中的每个元素返回负一的指数值作为输出。因此，np.expm1方法接受arr_name和out参数，然后将数组作为输出返回。</p>



<pre class="hljs">
points = np.append(points, [[<span class="hljs-number">0</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]], axis=<span class="hljs-number">1</span>)
customersdata[<span class="hljs-string">"clusters"</span>] = kmeans_model_new.labels_
</pre>



<p>添加名为clusters的新列后，客户数据数据集将如下所示。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/35adc5f1c0acad50c29029c7496d9861.png" alt="Customer segmentation - dataset " class="wp-image-48054" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206005800im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Customer-segmentation-dataset-5.png?ssl=1"/></figure>



<p>最后，我们将使用下面的代码来可视化所创建的五个集群。这是使用plotly和express库完成的。</p>



<p>Plotly是一个Python库，用于绘图、统计、绘图和分析。这可以与Python、R、Julia和其他编程语言一起使用。Plotly是一个免费的开源库。</p>



<section id="blog-intext-cta-block_60cb2b985dadf" class="block-blog-intext-cta  c-box c-box--default c-box--dark c-box--no-hover c-box--standard ">

            
    
            <p>想要组织你的实验过程吗？检查如何<a href="https://web.archive.org/web/20221206005800/https://docs.neptune.ai/integrations-and-supported-tools/model-visualization-and-debugging/plotly" target="_blank" rel="noopener">将交互式Plotly图表存储在与模型元数据</a>(指标、参数、权重等)相同的位置。</p>
    
    </section>



<p>Plotly Express是Plotly上的一个高级接口，可用于多种类型的数据集并生成高度风格化的图。</p>



<p>plotly.express类具有可以一次性生成完整数字的函数。一般来说，它被称为px。值得注意的是plotly express是plotly库的内置模块。这是创建推荐的最常见地块的起点。注意，每个plotly express函数在内部创建<a href="https://web.archive.org/web/20221206005800/https://plotly.com/python/graph-objects/" target="_blank" rel="noreferrer noopener nofollow">图形对象</a>，并返回plotly.graph_objects。</p>



<p>使用plotly express通过单一方法调用创建的图形也可以仅使用图形对象创建。然而，在这种情况下，它需要大约5到100倍的代码。</p>



<p>与<a href="https://web.archive.org/web/20221206005800/https://plotly.com/python/line-and-scatter/" target="_blank" rel="noreferrer noopener nofollow"> 2D散点图</a>一样，px.scatter在二维空间中绘制单个数据，而3D方法px.scatter_3d在三维空间中绘制单个数据。</p>



<pre class="hljs">
figure = px.scatter_3d(customersdata,
                    color=<span class="hljs-string">'clusters'</span>,
                    x=<span class="hljs-string">"products_purchased"</span>,
                    y=<span class="hljs-string">"complains"</span>,
                    z=<span class="hljs-string">"money_spent"</span>,
                    category_orders = {<span class="hljs-string">"clusters"</span>: [<span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>]}
                    )
figure.update_layout()
figure.show()
</pre>















<p>数据点聚类的可视化非常重要。图表的不同边缘提供了复杂输入数据集的快速视图。</p>



<h2 id="conclusion">结论</h2>



<p>用相同的产品型号、电子邮件、短信活动或广告来服务所有客户是不明智的。客户有不同的需求。一刀切的商业模式通常会导致更少的参与，更低的点击率，最终更少的销售。客户细分是解决这个问题的方法。</p>



<p>找到最佳数量的独特客户群将有助于您了解您的客户有何不同，并帮助您准确满足他们的需求。客户细分改善了客户体验，增加了公司收入。这就是为什么如果你想超越你的竞争对手，获得更多的客户，细分是必须的。用机器学习来做肯定是正确的方向。</p>



<p>如果你做到了这一步，感谢你的阅读！</p>
        </div>
        
    </div>    
</body>
</html>