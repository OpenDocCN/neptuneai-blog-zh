<html>
<head>
<title>The Best ML Frameworks &amp; Extensions For Scikit-learn </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Scikit的最佳ML框架和扩展-学习</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/the-best-ml-framework-extensions-for-scikit-learn#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/the-best-ml-framework-extensions-for-scikit-learn#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p>许多包实现了<a href="https://web.archive.org/web/20230204025453/https://scikit-learn.org/" target="_blank" rel="noreferrer noopener nofollow">sci kit-learn</a>estimator API。</p>



<p>如果您已经熟悉Scikit-learn，您会发现这些库的集成非常简单。</p>



<p>有了这些包，我们可以扩展Scikit-learn估算器的功能，我将在本文中向您展示如何使用它们。</p>



<h2 id="h-data-formats">数据格式</h2>



<p>在这一节中，我们将探索可用于处理和转换数据的库。</p>







<p>您可以使用这个包将“DataFrame”列映射到Scikit-learn转换。然后，您可以将这些列组合成功能。</p>



<p>要开始使用该软件包，请通过pip安装“sklearn-pandas”。“DataFrameMapper”可用于将pandas数据框列映射到Scikit-learn转换。让我们看看它是怎么做的。</p>



<p>首先，创建一个虚拟数据帧:</p>



<pre class="hljs">data =pd.DataFrame({
    <span class="hljs-string">'Name'</span>:[<span class="hljs-string">'Ken'</span>,<span class="hljs-string">'Jeff'</span>,<span class="hljs-string">'John'</span>,<span class="hljs-string">'Mike'</span>,<span class="hljs-string">'Andrew'</span>,<span class="hljs-string">'Ann'</span>,<span class="hljs-string">'Sylvia'</span>,<span class="hljs-string">'Dorothy'</span>,<span class="hljs-string">'Emily'</span>,<span class="hljs-string">'Loyford'</span>],
    <span class="hljs-string">'Age'</span>:[<span class="hljs-number">31</span>,<span class="hljs-number">52</span>,<span class="hljs-number">56</span>,<span class="hljs-number">12</span>,<span class="hljs-number">45</span>,<span class="hljs-number">50</span>,<span class="hljs-number">78</span>,<span class="hljs-number">85</span>,<span class="hljs-number">46</span>,<span class="hljs-number">135</span>],
    <span class="hljs-string">'Phone'</span>:[<span class="hljs-number">52</span>,<span class="hljs-number">79</span>,<span class="hljs-number">80</span>,<span class="hljs-number">75</span>,<span class="hljs-number">43</span>,<span class="hljs-number">125</span>,<span class="hljs-number">74</span>,<span class="hljs-number">44</span>,<span class="hljs-number">85</span>,<span class="hljs-number">45</span>],
    <span class="hljs-string">'Uni'</span>:[<span class="hljs-string">'One'</span>,<span class="hljs-string">'Two'</span>,<span class="hljs-string">'Three'</span>,<span class="hljs-string">'One'</span>,<span class="hljs-string">'Two'</span>,<span class="hljs-string">'Three'</span>,<span class="hljs-string">'One'</span>,<span class="hljs-string">'Two'</span>,<span class="hljs-string">'Three'</span>,<span class="hljs-string">'One'</span>]
})
</pre>



<p>“DataFrameMapper”接受元组列表——第一项的名称是数据帧中的列名。</p>



<p>第二个传递的项是将应用于该列的转换类型。</p>



<p>例如，'<a href="https://web.archive.org/web/20230204025453/https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelBinarizer.html" target="_blank" rel="noreferrer noopener nofollow"> LabelBinarizer </a>可应用于' Uni '列，而' Age '列则使用'<a href="https://web.archive.org/web/20230204025453/https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" target="_blank" rel="noreferrer noopener nofollow"> StandardScaler </a>进行缩放。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> sklearn_pandas <span class="hljs-keyword">import</span> DataFrameMapper
mapper = DataFrameMapper([
     (<span class="hljs-string">'Uni'</span>, sklearn.preprocessing.LabelBinarizer()),
     ([<span class="hljs-string">'Age'</span>], sklearn.preprocessing.StandardScaler())
 ])</pre>



<p>定义映射器后，接下来我们用它来拟合和转换数据。</p>



<pre class="hljs">mapper.fit_transform(data)</pre>



<p>映射器的“transformed_names_”属性可用于显示转换后的结果名称。</p>



<pre class="hljs">mapper.transformed_names_</pre>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/391fb770bcc0fc8b21f9dd19510149fc.png" alt="scikit-learn extensions" class="wp-image-34927" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230204025453im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/scikit-learn-extensions.png?ssl=1"/></figure>



<p>向映射器传递“df_out=True”将会以熊猫数据帧的形式返回您的结果。</p>



<pre class="hljs">mapper = DataFrameMapper([
     (<span class="hljs-string">'Uni'</span>, sklearn.preprocessing.LabelBinarizer()),
     ([<span class="hljs-string">'Age'</span>], sklearn.preprocessing.StandardScaler())

 ],df_out=<span class="hljs-keyword">True</span>)</pre>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/70c3b45ccdaaf5ac5b91680f0a871d95.png" alt="scikit-learn extensions " class="wp-image-34930" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230204025453im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/scikit-learn-extensions-2.png?ssl=1"/></figure>







<p>这个包结合了来自<a href="https://web.archive.org/web/20230204025453/http://xarray.pydata.org/en/stable/" target="_blank" rel="noreferrer noopener nofollow"> xarray </a>的n维标签数组和<a href="https://web.archive.org/web/20230204025453/http://scikit-learn.org/stable/" target="_blank" rel="noreferrer noopener nofollow"> Scikit-learn </a>工具。</p>



<p>您可以将Scikit-learn估值器应用于“xarrays ”,而不会丢失它们的标签。您还可以:</p>



<ul>
<li>确保Sklearn估算器与xarray数据阵列和数据集之间的兼容性，</li>



<li>使估计者能够改变样本数，</li>



<li>有预处理变压器。</li>
</ul>



<p>Sklearn-xarray基本上是xarray和Scikit-learn之间的桥梁。为了使用其功能，请通过pip或“conda”安装“sklearn-xarray”。</p>



<p>这个包有包装器，允许您在xarray数据数组和数据集上使用sklearn估计器。为了说明这一点，让我们首先创建一个“数据阵列”。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> xarray <span class="hljs-keyword">as</span> xr
data = np.random.rand(<span class="hljs-number">16</span>, <span class="hljs-number">4</span>)
my_xarray = xr.DataArray(data)</pre>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/a92a3b0346a3f5494b178adad99bfefc.png" alt="scikit-learn extensions " class="wp-image-34933" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230204025453im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/scikit-learn-extensions-3.png?ssl=1"/></figure>



<p>从Sklearn中选择一个转换以应用于此“数据阵列”。在这种情况下，<a href="https://web.archive.org/web/20230204025453/https://phausamann.github.io/sklearn-xarray/content/wrappers.html">让我们应用</a>“标准缩放器”。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler
Xt = wrap(StandardScaler()).fit_transform(X)
</pre>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/f9a37321c642d4969618707c719213b0.png" alt="scikit-learn extensions " class="wp-image-34936" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230204025453im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/scikit-learn-extensions-4.png?ssl=1"/></figure>



<p>包装估计器可以无缝地用于Sklearn管道中。</p>



<pre class="hljs">pipeline = Pipeline([
    (<span class="hljs-string">'pca'</span>, wrap(PCA(n_components=<span class="hljs-number">50</span>), reshapes=<span class="hljs-string">'feature'</span>)),
    (<span class="hljs-string">'cls'</span>, wrap(LogisticRegression(), reshapes=<span class="hljs-string">'feature'</span>))
])
</pre>



<p>当安装这个管道时，您只需传入DataArray。</p>



<p>类似地，DataArrays可以用于交叉验证的网格搜索。</p>



<p>为此，您需要从“sklearn-xarray”创建一个“CrossValidatorWrapper”实例。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> sklearn_xarray.model_selection <span class="hljs-keyword">import</span> CrossValidatorWrapper
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV, KFold
cv = CrossValidatorWrapper(KFold())
pipeline = Pipeline([
     (<span class="hljs-string">'pca'</span>, wrap(PCA(), reshapes=<span class="hljs-string">'feature'</span>)),
     (<span class="hljs-string">'cls'</span>, wrap(LogisticRegression(), reshapes=<span class="hljs-string">'feature'</span>))
 ])
gridsearch = GridSearchCV(
     pipeline, cv=cv, param_grid={<span class="hljs-string">'pca__n_components'</span>: [<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">60</span>]}
)
</pre>



<p>之后，您将使“gridsearch”适合“DataArray”数据类型中的X和y。</p>



<h2 id="h-auto-ml">自动毫升</h2>



<p>有没有整合Sklearn的工具和库来更好的Auto-ML？是的，这里有一些例子。</p>







<p>有了这个，你就可以用Scikit-learn进行自动化的机器学习了。对于设置，您需要手动安装一些依赖项。</p>



<pre class="hljs">$ curl https://raw.githubusercontent.com/automl/auto-sklearn/master/requirements.txt | xargs -n <span class="hljs-number">1</span> -L <span class="hljs-number">1</span> pip install
</pre>



<p>接下来，通过pip安装“auto-sklearn”。</p>



<p>使用该工具时，您不需要担心算法选择和超参数调整。Auto-sklearn会为您完成所有这些工作。</p>



<p>这要归功于贝叶斯优化、元学习和集成构建方面的最新进展。</p>



<p>要使用它，您需要选择一个分类器或回归器，并使其适合训练集。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> autosklearn.classification <span class="hljs-keyword">import</span> AutoSklearnClassifier
cls = AutoSklearnClassifier()
cls.fit(X_train, y_train)
predictions = cls.predict(X_test)</pre>



<h3><a href="https://web.archive.org/web/20230204025453/https://github.com/AutoViML" target="_blank" rel="noreferrer noopener nofollow">Auto _ ViML</a>–自动变量可解释机器学习”(读作“Auto_Vimal”)</h3>



<p>给定一个特定的数据集，Auto_ViML尝试不同的模型和不同的特性。它最终选定了性能最佳的模型。</p>



<p>该软件包还在构建模型时选择尽可能少的特征。这给了你一个不太复杂和可解释的模型。该套件还:</p>



<ul>
<li>通过建议更改缺少的值、格式和添加变量来帮助您清理数据。</li>



<li>自动分类变量，无论是文本，数据，还是数字；</li>



<li>当verbose设置为1或2时，自动生成模型性能图；</li>



<li>允许您使用“功能工具”进行功能工程；</li>



<li>当“不平衡标志”设置为“真”时，处理不平衡数据</li>
</ul>



<p>要查看它的运行，请通过pip安装“autoviml”。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split, cross_validate

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.1</span>, random_state=<span class="hljs-number">42</span>)
X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=<span class="hljs-number">0.25</span>, random_state=<span class="hljs-number">54</span>)

train, test = X_train.join(y_train), X_val.join(y_val)
model, features, train, test = Auto_ViML(train,<span class="hljs-string">"target"</span>,test,verbose=<span class="hljs-number">2</span>)</pre>



<h3><a href="https://web.archive.org/web/20230204025453/http://proceedings.mlr.press/v64/olson_tpot_2016.pdf" target="_blank" rel="noreferrer noopener nofollow">TPOT—</a>基于采油树的管道优化工具</h3>



<p>这是一个基于Python的自动ml工具。它使用遗传编程来优化机器学习管道。</p>



<p>它会探索多个管道，以便为您的数据集选择最佳管道。</p>



<p>通过pip安装“tpot ”,开始修改它。运行“tpot”后，可以将生成的管道保存在一个文件中。一旦浏览过程完成或您终止该过程，文件将被导出。</p>



<p>下面的代码片段展示了如何在digits数据集上创建分类管道。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> tpot <span class="hljs-keyword">import</span> TPOTClassifier
<span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_digits
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split

digits = load_digits()
X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target,
                                                    train_size=<span class="hljs-number">0.75</span>, test_size=<span class="hljs-number">0.25</span>, random_state=<span class="hljs-number">42</span>)

tpot = TPOTClassifier(generations=<span class="hljs-number">5</span>, population_size=<span class="hljs-number">50</span>, verbosity=<span class="hljs-number">2</span>, random_state=<span class="hljs-number">42</span>)
tpot.fit(X_train, y_train)
print(tpot.score(X_test, y_test))
tpot.export(<span class="hljs-string">'tpot_digits_pipeline.py'</span>)</pre>







<p>这是一个自动化特征工程的工具。它的工作原理是将时态和关系数据集转换成特征矩阵。</p>



<p>通过pip安装“featuretools[complete]”开始使用它。</p>



<p>深度特征合成(DFS)可用于自动化特征工程。</p>



<p>首先，定义一个包含数据集中所有实体的字典。在“featuretools”中，实体是单个表格。之后，定义不同实体之间的关系。</p>



<p>下一步是将实体、关系列表和目标实体传递给DFS。这将为您提供特性矩阵和相应的特性定义列表。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> featuretools <span class="hljs-keyword">as</span> ft

entities = {
   <span class="hljs-string">"customers"</span> : (customers_df, <span class="hljs-string">"customer_id"</span>),
  <span class="hljs-string">"sessions"</span> : (sessions_df, <span class="hljs-string">"session_id"</span>, <span class="hljs-string">"session_start"</span>),
   <span class="hljs-string">"transactions"</span> : (transactions_df, <span class="hljs-string">"transaction_id"</span>, <span class="hljs-string">"transaction_time"</span>)
 }

relationships = [(<span class="hljs-string">"sessions"</span>, <span class="hljs-string">"session_id"</span>, <span class="hljs-string">"transactions"</span>, <span class="hljs-string">"session_id"</span>),
               (<span class="hljs-string">"customers"</span>, <span class="hljs-string">"customer_id"</span>, <span class="hljs-string">"sessions"</span>, <span class="hljs-string">"customer_id"</span>)]

feature_matrix, features_defs = ft.dfs(entities=entities,
                                                 relationships = relationships,
                                                  target_entity = <span class="hljs-string">"customers"</span>)</pre>







<p>您可以使用Neuraxle进行超参数调整和AutoML。通过pip安装“neuraxle”以开始使用它。</p>



<p>除了Scikit-learn，Neuraxle还兼容Keras、TensorFlow和PyTorch。它还具有:</p>



<ul>
<li>并行计算和串行化，</li>



<li>通过提供这类项目的关键抽象来处理时间序列。</li>
</ul>



<p>要使用Neuraxle进行自动ml，您需要:</p>



<ul>
<li>定义的管道</li>



<li>验证拆分器</li>



<li>通过“计分回调”定义计分指标</li>



<li>选定的“超参数”存储库</li>



<li>选定的“超参数”优化器</li>



<li>“自动”循环</li>
</ul>



<p>点击查看完整的<a href="https://web.archive.org/web/20230204025453/https://www.neuraxle.org/stable/hyperparameter_tuning.html" target="_blank" rel="noreferrer noopener nofollow">示例。</a></p>



<h2 id="h-experimentation-frameworks">实验框架</h2>



<p>现在是时候使用一些SciKit工具来进行机器学习实验了。</p>











<p>SciKit-Learn Laboratory是一个命令行工具，可以用来运行机器学习实验。要开始使用它，请通过pip安装“skll”。</p>



<p>之后，您需要获得一个“SKLL”格式的数据集。<br/>接下来，为实验创建一个<a href="https://web.archive.org/web/20230204025453/https://skll.readthedocs.io/en/latest/run_experiment.html#create-config" target="_blank" rel="noreferrer noopener nofollow">配置文件</a>，并在终端中运行实验。</p>



<pre class="hljs">$ run_experimen experiment.cfg</pre>



<p>当实验完成时，多个文件将被存储在<a href="https://web.archive.org/web/20230204025453/https://skll.readthedocs.io/en/latest/run_experiment.html#results">结果</a>文件夹中。您可以使用这些文件来检查实验。</p>



<h3>海王星</h3>



<p>Neptune与Scikit-learn的集成让你可以使用Neptune记录你的实验。例如，您可以记录Scikit-learn回归器的摘要。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> neptunecontrib.monitoring.sklearn <span class="hljs-keyword">import</span> log_regressor_summary

log_regressor_summary(rfr, X_train, X_test, y_train, y_test)
</pre>



<p>查看本<a href="https://web.archive.org/web/20230204025453/https://colab.research.google.com/github/neptune-ai/neptune-examples/blob/master/integrations/sklearn/docs/Neptune-Scikit-learn.ipynb#scrollTo=GvDSBSrOx-R4" target="_blank" rel="noreferrer noopener">笔记本</a>获取完整示例。</p>



<p>型号选择</p>



<h2 id="h-model-selection">现在让我们换个话题，看看专注于模型选择和优化的SciKit库。</h2>



<p>这个库实现了基于顺序模型的优化方法。通过pip安装“scikit-optimize ”,开始使用这些功能。</p>











<p>Scikit-optimize可用于通过基于贝叶斯定理的贝叶斯优化来执行超参数调整。</p>



<p>您使用“BayesSearchCV”来获得使用该定理的最佳参数。一个Scikit-learn模型作为第一个参数传递给它。</p>



<p>拟合后，您可以通过' best_params_ '属性获得模型的最佳参数。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> skopt.space <span class="hljs-keyword">import</span> Real, Categorical, Integer
<span class="hljs-keyword">from</span> skopt <span class="hljs-keyword">import</span> BayesSearchCV
regressor = BayesSearchCV(
    GradientBoostingRegressor(),

     {
         <span class="hljs-string">'learning_rate'</span>: Real(<span class="hljs-number">0.1</span>,<span class="hljs-number">0.3</span>),
         <span class="hljs-string">'loss'</span>: Categorical([<span class="hljs-string">'lad'</span>,<span class="hljs-string">'ls'</span>,<span class="hljs-string">'huber'</span>,<span class="hljs-string">'quantile'</span>]),
   <span class="hljs-string">'max_depth'</span>: Integer(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>),
    },
     n_iter=<span class="hljs-number">32</span>,
     random_state=<span class="hljs-number">0</span>,
      verbose=<span class="hljs-number">1</span>,
      cv=<span class="hljs-number">5</span>,n_jobs=<span class="hljs-number">-1</span>,
 )
regressor.fit(X_train,y_train)</pre>



<p>Sklearn-deap是一个用来实现<a href="https://web.archive.org/web/20230204025453/https://en.wikipedia.org/wiki/Evolutionary_algorithm" target="_blank" rel="noreferrer noopener nofollow">进化算法</a>的包。它减少了为模型寻找最佳参数所需的时间。</p>







<p>它不会尝试每一种可能的组合，而只会改进产生最佳性能的组合。通过pip安装“sklearn-deap”。</p>



<p>用于生产的模型出口</p>



<pre class="hljs"><span class="hljs-keyword">from</span> evolutionary_search <span class="hljs-keyword">import</span> EvolutionaryAlgorithmSearchCV
cv = EvolutionaryAlgorithmSearchCV(estimator=SVC(),
                                   params=paramgrid,
                                   scoring=<span class="hljs-string">"accuracy"</span>,
                                   cv=StratifiedKFold(n_splits=<span class="hljs-number">4</span>),
                                   verbose=<span class="hljs-number">1</span>,
                                   population_size=<span class="hljs-number">50</span>,
                                   gene_mutation_prob=<span class="hljs-number">0.10</span>,
                                   gene_crossover_prob=<span class="hljs-number">0.5</span>,
                                   tournament_size=<span class="hljs-number">3</span>,
                                   generations_number=<span class="hljs-number">5</span>,
                                   n_jobs=<span class="hljs-number">4</span>)
cv.fit(X, y)</pre>



<h2 id="h-model-export-for-production">接下来，让我们来看看Scikit工具，您可以使用这些工具来导出您的生产模型。</h2>



<p>sklearn-onnx支持将sklearn模型转换为<a href="https://web.archive.org/web/20230204025453/https://onnx.ai/" target="_blank" rel="noreferrer noopener nofollow"> ONNX </a>。</p>







<p>要使用它，您需要通过pip获得‘skl 2 onnx’。一旦你的管道准备好了，你就可以使用‘to _ onnx’函数将模型转换成ONNX。</p>



<p>这是一个决策树集成的模型编译器。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> skl2onnx <span class="hljs-keyword">import</span> to_onnx
onx = to_onnx(pipeline, X_train[:<span class="hljs-number">1</span>].astype(numpy.float32))
</pre>







<p>它处理各种基于树的模型，如随机森林和梯度增强树。</p>



<p>您可以使用它来导入Scikit-learn模型。这里，“模型”是一个scikit-learn模型对象。</p>



<p>模型检查和可视化</p>



<pre class="hljs"><span class="hljs-keyword">import</span> treelite.sklearn
model = treelite.sklearn.import_model(model)
</pre>



<h2 id="h-model-inspection-and-visualization">在这一节中，让我们看看可用于模型可视化和检查的库。</h2>



<p>dtreeviz用于决策树可视化和模型解释。</p>











<p>eli5是一个可以用来调试和检查机器学习分类器的包。你也可以用它来解释他们的预测。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> dtreeviz.trees <span class="hljs-keyword">import</span> dtreeviz
viz = dtreeviz(
              model,
               X_train,
               y_train,
               feature_names=boston.feature_names,
               fontname=<span class="hljs-string">"Arial"</span>,
               title_fontsize=<span class="hljs-number">16</span>,
               colors = {<span class="hljs-string">"title"</span>:<span class="hljs-string">"red"</span>}
              )
</pre>









<p>例如，Scikit-learn估计器权重的解释如下所示:</p>



<p><a href="https://web.archive.org/web/20230204025453/https://github.com/amueller/dabl" target="_blank" rel="noreferrer noopener nofollow">dabl</a>–数据分析基线库</p>



<pre class="hljs"><span class="hljs-keyword">import</span> eli5
eli5.show_weights(model)</pre>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/09afe61e5389860cf9dbb08c21455ee7.png" alt="scikit-learn extensions " class="wp-image-34952" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230204025453im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/scikit-learn-extensions-5-1.png?ssl=1"/></figure>







<h3>dabl为常见的机器学习任务提供了样板代码。它仍在积极开发中，所以不推荐用于生产系统。</h3>



<p>Skorch是PyTorch的Scikit-learn包装器。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> dabl
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split
<span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_digits
X, y = load_digits(return_X_y=<span class="hljs-keyword">True</span>)
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="hljs-number">1</span>)
sc = dabl.SimpleClassifier().fit(X_train, y_train)
print(<span class="hljs-string">"Accuracy score"</span>, sc.score(X_test, y_test))</pre>







<p>它允许你在Scikit-learn中使用PyTorch。它支持多种数据类型，如PyTorch张量、NumPy数组和Python字典。</p>



<p>最后的想法</p>



<pre class="hljs"><span class="hljs-keyword">from</span> skorch <span class="hljs-keyword">import</span> NeuralNetClassifier
net = NeuralNetClassifier(
    MyModule,
    max_epochs=<span class="hljs-number">10</span>,
    lr=<span class="hljs-number">0.1</span>,
    iterator_train__shuffle=<span class="hljs-keyword">True</span>,
)
net.fit(X, y)
</pre>



<h2 id="h-final-thoughts">在本文中，我们探索了一些扩展Scikit-learn生态系统的流行工具和库。</h2>



<p>如您所见，这些工具可用于:</p>



<p>处理和转换数据，</p>



<ul>
<li>实现自动化机器学习，</li>



<li>执行自动特征选择，</li>



<li>运行机器学习实验，</li>



<li>为您的问题选择最佳的模型和管道，</li>



<li>为生产导出模型…</li>



<li>…还有更多！</li>
</ul>



<p>在您的Scikit-learn工作流程中试用这些包，您可能会惊讶于它们有多么方便。</p>



<p>Try out these packages in your Scikit-learn workflow, and you might be surprised how convenient they are.</p>
        </div>
        
    </div>    
</body>
</html>