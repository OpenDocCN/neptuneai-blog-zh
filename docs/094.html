<html>
<head>
<title>How to Choose a Learning Rate Scheduler for Neural Networks </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何选择神经网络的学习速率调度器</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/how-to-choose-a-learning-rate-scheduler#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/how-to-choose-a-learning-rate-scheduler#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p>研究人员普遍认为神经网络模型很难训练。最大的问题之一是需要指定和优化大量的超参数。隐藏层的数量、激活函数、优化器、学习率、正则化——不胜枚举。</p>



<p>调整这些超参数可以极大地改善神经网络模型。对于作为数据科学家的我们来说，构建神经网络模型是为了解决一个优化问题。我们希望通过基于梯度的方法，例如梯度下降，找到目标函数的最小值(全局的，或者有时是局部的)。</p>



<p>在所有梯度下降超参数中，学习率(进度)是获得良好模型性能的最关键参数之一。在本文中，<strong>我们将探讨学习率，并解释为什么在模型训练中安排学习率至关重要。</strong></p>



<p>从这里开始，我们将看到如何通过在Keras中实现和利用各种调度器来选择学习率调度。然后，我们将在Neptune中创建实验来比较这些调度程序的性能。</p>



<h2 id="definition">神经网络中的学习率是多少？</h2>



<p>什么是学习率，它对神经网络有什么影响？学习率(或步长)被解释为在<a href="/web/20230228190120/https://neptune.ai/blog/backpropagation-algorithm-in-neural-networks-guide" target="_blank" rel="noreferrer noopener">反向传播</a>训练过程中模型权重的变化/更新幅度。作为一个可配置的超参数，学习率通常被指定为小于1.0的正值。</p>



<p>在反向传播中，模型权重被更新以减少损失函数的误差估计。我们不是使用全部数量来改变权重，而是将其乘以某个学习率值。例如，将学习率设置为0.5将意味着用0.5 *估计权重误差(即，梯度或总误差相对于权重的变化)来更新(通常减去)权重。</p>



<h3>学习速度的影响</h3>



<p>学习率控制优化器达到损失函数最小值的步长。这对我们的优化算法有什么影响？看看这些图表:</p>





<ul>
<li>学习率大(右边)，算法学习快，但也可能导致算法在极小值附近振荡，甚至跳过极小值。更糟糕的是，高学习率等于大的权重更新，这可能导致权重溢出；</li>



<li>相反，在学习率很小的情况下(左侧)，对权重的更新很小，这将引导优化器逐渐接近最小值。然而，优化器可能需要太长时间来收敛或陷入平稳状态或不期望的局部最小值；</li>



<li>好的学习率是覆盖率和超调(中间)之间的权衡。它不会太小以至于我们的算法可以快速收敛，也不会太大以至于我们的算法不会在没有达到最小值的情况下来回跳跃。</li>
</ul>



<p>虽然找到一个合适的学习率的理论原理很简单(不要太大，也不要太小)，但是说起来容易做起来难！为了解决这个问题，引入了学习率表。</p>



<h2 id="implementation">学习费率表</h2>



<p>学习率时间表是一个预定义的框架，随着训练的进行，它在各时期或迭代之间调整学习率。学习速率计划的两种最常见的技术是，</p>



<ul>
<li>学习率不变:顾名思义，我们初始化一个学习率，训练时不改变；</li>



<li>学习率衰减:我们选择一个初始的学习率，然后按照一个时间表逐渐降低它。</li>
</ul>



<p>知道了什么是学习率计划，你一定想知道为什么我们首先需要降低学习率？在神经网络中，我们的模型权重更新为:</p>





<p>其中eta是学习率，偏导数是梯度。</p>



<p>对于训练过程来说，这是好的。在训练的早期，为了达到足够好的一组重量，学习率被设置得很大。随着时间的推移，通过利用小的学习率，这些权重被微调以达到更高的准确度。</p>



<p><em>注意:你可能会读到一些文章，其中学习率时间表仅被定义为(学习率)衰减。尽管这两个术语(学习率计划和衰减)有时可以互换使用，但在本文中，我们将实现恒定学习率的场景作为性能基准测试的基线模型。</em></p>



<h2 id="h-analysis-dataset-and-experiment-config-in-neptune">Neptune中的分析数据集和实验配置</h2>



<p>出于演示的目的，我们将使用Keras中流行的<a href="https://web.archive.org/web/20230228190120/https://www.tensorflow.org/datasets/catalog/fashion_mnist" target="_blank" rel="noreferrer noopener nofollow"> Fashion-MINIST </a>数据。该数据集由70，000幅图像组成(训练集和测试集分别为60，000幅和10，000幅)。这些图像为28×28像素，与10个类别相关联。</p>



<p>为了跟踪和比较不同学习率调度器的模型性能，我们将在Neptune中进行实验。海王星监控所有与模型相关的东西。关于如何用Python设置和配置Neptune项目的详细分步说明，请参考本文档。</p>



<p>在本练习中，我们将创建一个Neptune项目，并将其标记为"<em>learningrateschedule</em>？。在<a href="https://web.archive.org/web/20230228190120/https://docs.neptune.ai/getting-started/installation#authentication-neptune-api-token" target="_blank" rel="noreferrer noopener">获得您的Neptune </a> API令牌后，您可以使用下面的代码将Python连接到我们的项目:</p>



<pre class="hljs">
project = neptune.init(api_token=os.getenv(<span class="hljs-string">'NEPTUNE_API_TOKEN'</span>),
                       project=<span class="hljs-string">'YourUserName/YourProjectName'</span>)
project.stop()</pre>



<p>接下来，我们将使用Keras中可用的一些实用函数加载数据集。</p>



<p>为了减少本地机器上的运行时间，我们的模型将针对20，000张图像而不是整个60，000张图像进行训练。因此，我们将使用下面的代码随机选择20，000条数据记录。</p>



<p>除此之外，我们还将定义几个辅助函数来保存和绘制训练过程中的学习率:</p>



<pre class="hljs">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset_random_seeds</span><span class="hljs-params">(CUR_SEED=<span class="hljs-number">9125</span>)</span>:</span>
   os.environ[<span class="hljs-string">'PYTHONHASHSEED'</span>]=str(CUR_SEED)
   tf.random.set_seed(CUR_SEED)
   np.random.seed(CUR_SEED)
   random.seed(CUR_SEED)

reset_random_seeds()


fashion_mnist = keras.datasets.fashion_mnist
(X_train_full, y_train_full), (X_test_full, y_test_full) = fashion_mnist.load_data()

reset_random_seeds()
trainIdx = random.sample(range(<span class="hljs-number">60000</span>), <span class="hljs-number">20000</span>)

x_train, y_train = X_train_full[trainIdx]/<span class="hljs-number">255.0</span>, y_train_full[trainIdx]
x_test, y_test = X_test_full/<span class="hljs-number">255.0</span>, y_test_full


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_lr_metric</span><span class="hljs-params">(optimizer)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lr</span><span class="hljs-params">(y_true, y_pred)</span>:</span>
        curLR = optimizer._decayed_lr(tf.float32)
        <span class="hljs-keyword">return</span> curLR
    <span class="hljs-keyword">return</span> lr


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plotLR</span><span class="hljs-params">(history)</span>:</span>
    learning_rate = history.history[<span class="hljs-string">'lr'</span>]
    epochs = range(<span class="hljs-number">1</span>, len(learning_rate) + <span class="hljs-number">1</span>)
    fig = plt.figure()
    plt.plot(epochs, learning_rate)
    plt.title(<span class="hljs-string">'Learning rate'</span>)
    plt.xlabel(<span class="hljs-string">'Epochs'</span>)
    plt.ylabel(<span class="hljs-string">'Learning rate'</span>)
    <span class="hljs-keyword">return</span>(fig)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plotPerformance</span><span class="hljs-params">(history, CURRENT_LR_SCHEDULER=CURRENT_LR_SCHEDULER)</span>:</span>
    
    fig = plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>))
    fig = plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>) 

    plt.plot(history.history[<span class="hljs-string">'loss'</span>])
    plt.plot(history.history[<span class="hljs-string">'val_loss'</span>])
    plt.legend([<span class="hljs-string">'Train Loss'</span>, <span class="hljs-string">'Test Loss'</span>])
    plt.title(f<span class="hljs-string">'Loss Curves ({CURRENT_LR_SCHEDULER})'</span>)
    plt.xlabel(<span class="hljs-string">'Epoch'</span>)
    plt.ylabel(<span class="hljs-string">'Loss on the Validation Set'</span>)

    
    fig = plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>) 

    plt.plot(history.history[<span class="hljs-string">'accuracy'</span>])
    plt.plot(history.history[<span class="hljs-string">'val_accuracy'</span>])
    plt.legend([<span class="hljs-string">'Train Accuracy'</span>, <span class="hljs-string">'Test Accuracy'</span>])
    plt.title(f<span class="hljs-string">'Accuracy Curves ({CURRENT_LR_SCHEDULER})'</span>)
    plt.xlabel(<span class="hljs-string">'Epoch'</span>)
    plt.ylabel(<span class="hljs-string">'Accuracy on the Validation Set'</span>)
    <span class="hljs-keyword">return</span> fig</pre>



<p>这里有几个注意事项:</p>



<ul>
<li>当前数据集通过除以255进行规范化；因此，它被重新调整到0-1的范围内；</li>



<li>我们定义了一个函数get_lr_metric()来保存和打印学习率，作为Keras verbose的一部分。</li>
</ul>



<p>此外，让我们还创建一个帮助器函数，在整个实验过程中，将学习率和模型性能图表记录到Neptune:</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_Neptune</span><span class="hljs-params">(history, decayTitle, npt_exp)</span>:</span>
        
        npt_exp[f<span class="hljs-string">'Learning Rate Change ({decayTitle})'</span>].upload(neptune.types.File.as_image(plotLR(history)))
        
        npt_exp[f<span class="hljs-string">'Training Performance Curves ({decayTitle})'</span>].upload(neptune.types.File.as_image(plotPerformance(history).get_figure()))</pre>



<h2 id="h-neural-network-model">神经网络模型</h2>



<p>有了数据集和辅助函数，我们现在可以构建一个神经网络模型作为图像分类器。为简单起见，我们当前的模型包含两个隐藏层和一个输出层，输出层具有用于多类分类的<em>‘soft max’</em>激活功能:</p>



<pre class="hljs">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">runModel</span><span class="hljs-params">()</span>:</span>
    model = Sequential()
    model.add(Flatten(input_shape=[<span class="hljs-number">28</span>, <span class="hljs-number">28</span>]))
    model.add(Dense(<span class="hljs-number">512</span>, activation=<span class="hljs-string">'relu'</span>))
    model.add(Dense(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>))
    model.add(Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>))
    <span class="hljs-keyword">return</span> model

model = runModel()
model.summary()</pre>



<p>这是模型结构，这是一个相当简单的网络。</p>





<h2 id="h-baseline-model-with-a-constant-learning-rate">学习率不变的基线模型</h2>



<p>如上所述，恒定调度是所有学习率调度器中最简单的方案。为了设置性能基线，我们将在所有时期使用一致的学习率0.01来训练模型:</p>



<pre class="hljs">
npt_exp = neptune.init(
        api_token=os.getenv(<span class="hljs-string">'NEPTUNE_API_TOKEN'</span>),
        project=<span class="hljs-string">'YourUserName/YourProjectName'</span>,
        name=<span class="hljs-string">'ConstantLR'</span>,
        description=<span class="hljs-string">'constant-lr'</span>,
        tags=[<span class="hljs-string">'LearingRate'</span>, <span class="hljs-string">'constant'</span>, <span class="hljs-string">'baseline'</span>, <span class="hljs-string">'neptune'</span>])

neptune_cbk = NeptuneCallback(run=npt_exp, base_namespace=<span class="hljs-string">"metrics"</span>)


initial_learning_rate = <span class="hljs-number">0.01</span>
epochs = <span class="hljs-number">100</span>
sgd = keras.optimizers.SGD(learning_rate=initial_learning_rate)
lr_metric = get_lr_metric(sgd)

model.compile(optimizer = sgd,
              loss=<span class="hljs-string">'sparse_categorical_crossentropy'</span>,
              metrics=[<span class="hljs-string">'accuracy'</span>, lr_metric])

reset_random_seeds()

trainHistory_constantLR = model.fit(
    x_train, y_train,
    epochs=epochs,
    validation_data=(x_test, y_test),
    batch_size=<span class="hljs-number">64</span>,
    callbacks = [neptune_cbk]
)


npt_exp[<span class="hljs-string">'Learning Rate Change (Constant)'</span>].upload(neptune.types.File.as_image(plotLR(trainHistory_constantLR)))


npt_exp[<span class="hljs-string">'Training Performance Curves (Constant)'</span>].upload(neptune.types.File.as_image(plotPerformance(trainHistory_constantLR).get_figure()))

npt_exp.stop()  </pre>



<p>在此，我们:</p>



<ul>
<li>在我们的项目下创建了一个Neptune实验来跟踪基本模型的性能；</li>



<li>使用`<em> learning_rate </em>`参数指定学习率。在Keras的标准SGD优化器中；</li>



<li>增加了<em> lr_metric </em>作为用户定义的指标进行监控，使学习率信息能够在培训中逐字显示；</li>



<li>在Neptune中记录学习率和性能图表(损失和准确性曲线)。</li>
</ul>



<p>查看训练进度，我们可以确认当前学习率被固定为0.01而没有改变，</p>





<p>在我们的海王星实验中，我们会发现下面的性能图表，</p>







<p>随着学习的展开，训练损失在减少，准确率在增加；尽管如此，当涉及到验证集时，模型性能不会有太大的变化。这将是我们稍后与衰减调度程序进行基准测试的基线模型。</p>



<h2 id="h-issues-with-the-build-in-decay-schedule-in-keras">Keras中内置<em>衰变</em>时间表的问题</h2>



<p>Keras提供了一个内置的标准衰减策略，它可以在优化器的“<em>衰减</em>”参数中指定，如下所示:</p>



<pre class="hljs">initial_learning_rate = <span class="hljs-number">0.1</span>
epochs = <span class="hljs-number">100</span>

sgd = keras.optimizers.SGD(learning_rate=initial_learning_rate, decay=<span class="hljs-number">0.01</span>)

model.compile(optimizer = sgd,
                  loss=<span class="hljs-string">'sparse_categorical_crossentropy'</span>,
                  metrics=[<span class="hljs-string">'accuracy'</span>])

trainHistory_constantLR = model.fit(
        x_train, y_train,
        epochs=epochs,
        validation_split=<span class="hljs-number">0.2</span>,
        batch_size=<span class="hljs-number">64</span>
    )</pre>



<p>这个衰减策略遵循一个基于时间的衰减，我们将在下一节讨论它，但是现在，让我们熟悉一下基本公式，</p>





<p>假设我们的初始学习率= 0.01，衰减= 0.001，我们会期望学习率变成，</p>



<ul>
<li>0.1 * (1/(1+0.01*1)) =第一个时期后的0.099</li>



<li>0.1 * (1/(1+0.01*20)) = 0.083并且在第20个时期之后</li>
</ul>



<p>然而，查看Keras训练进度，我们注意到不同的值，其中在第一个时期之后，学习率已经从0.1降低到0.0286，</p>





<p>迷惑？</p>



<p>嗯，这是一个误解，Keras更新的学习率在每个时代结束；相反，学习率更新是分批进行的，这意味着它是在Keras中的每批之后的<strong>执行的。公式是，</strong></p>





<p>，其中参数步长也称为迭代。</p>



<p>如果我们回到前面的例子，因为我们有总的训练数据= 20000幅图像，并且验证率= 0.2，所以训练集= 20000 * 0.2 = 16000。那么将批量大小设置为64意味着:</p>



<ul>
<li>16000/64 =需要250步或迭代来完成一个时期；</li>



<li>在每个时期之后，学习率被更新250次，这等于，</li>
</ul>



<p class="has-text-align-center"><em><strong>0.1 *(1/(1+0.01 * 250))= 0.0286！</strong>T3】</em></p>



<p>因此，当在Keras中使用标准衰减实现时，请记住这是一个<em>批处理</em>而不是<em>纪元</em>更新。为了避免这个潜在的问题，Keras还允许数据科学家定义定制的学习率调度器。</p>



<p>在本文的其余部分，我们将遵循这条路线，使用Keras中的<a href="https://web.archive.org/web/20230228190120/https://keras.io/api/callbacks/learning_rate_scheduler/" target="_blank" rel="noreferrer noopener nofollow"> Callback() </a>功能实现我们自己的调度程序。</p>



<h2 id="h-learning-rate-schedulers-with-keras-callback">带Keras回调的学习率计划程序</h2>



<p>学习率衰减的基本机制是随着时期的增加而降低学习率。所以，我们基本上想把我们的学习率指定为一些纪元的递减函数。</p>



<p>在所有潜在的候选者中，线性函数是最直接的一个，因此学习率随着时期线性降低。由于其简单性，线性衰减通常被认为是第一个尝试。</p>



<h3>线性衰减方案</h3>



<p>利用这种方案，学习率将在训练时期结束时衰减到零。要实现线性衰减:</p>



<pre class="hljs">initial_learning_rate = <span class="hljs-number">0.5</span>
epochs = <span class="hljs-number">100</span>
decay = initial_learning_rate/epochs


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lr_polynomial_decay</span>:</span>
	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, epochs=<span class="hljs-number">100</span>, initial_learning_rate=<span class="hljs-number">0.01</span>, power=<span class="hljs-number">1.0</span>)</span>:</span>
		
		
		self.epochs = epochs
		self.initial_learning_rate = initial_learning_rate
		self.power = power

	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span><span class="hljs-params">(self, epoch)</span>:</span>
		
		decay = (<span class="hljs-number">1</span> - (epoch / float(self.epochs))) ** self.power
		updated_eta = self.initial_learning_rate * decay
		
		<span class="hljs-keyword">return</span> float(updated_eta)</pre>



<p>这里，我们定义了一个类<strong> lr_polynomial_decay </strong>，其中arg。`<em>力量</em>`控制衰变的速度；也就是说，较小的功率使学习率衰减得更慢，而较大的功率使学习率衰减得更快。</p>



<p>将“<em>功率</em>”设置为1会产生线性衰减，其曲线如下所示。</p>


<div class="wp-block-image">
<figure class="aligncenter"><img decoding="async" src="../Images/8ab89fd226394d0d830d3f0dd97135cf.png" alt="" data-original-src="https://web.archive.org/web/20230228190120im_/https://lh6.googleusercontent.com/1Kr2Mxq-3WNOO3w7ProHys2-TZvHjbwGddghsRoZefqovsWRAQKbKSZaZp48WqsE1FEEpeRNzKk-wcLshFBzdISybajT6K4V48Et0vFvHzKGGF1Ypm5PqycgtWTQsdHq1NWFCdys=s0"/><figcaption class="wp-element-caption"><em>Linear learning rate decay</em></figcaption></figure></div>


<p>为了用这个定制的线性衰减来训练我们的模型，我们所需要的就是在<a href="https://web.archive.org/web/20230228190120/https://keras.io/api/callbacks/learning_rate_scheduler/" target="_blank" rel="noreferrer noopener nofollow">leargatescheduler</a>函数中指定它:</p>



<pre class="hljs">npt_exp_4 = neptune.init(
        api_token=os.getenv(<span class="hljs-string">'NEPTUNE_API_TOKEN'</span>),
        project=<span class="hljs-string">'YourUserName/YourProjectName'</span>,
        name=f<span class="hljs-string">'{POLY_POWER}LRDecay'</span>,
        description=f<span class="hljs-string">'{POLY_POWER}-lr-decay'</span>,
        tags=[<span class="hljs-string">'LearningRate'</span>, POLY_POWER, <span class="hljs-string">'decay'</span>, <span class="hljs-string">'neptune'</span>])

POLY_POWER == <span class="hljs-string">'linear'</span>
<span class="hljs-keyword">if</span> POLY_POWER == <span class="hljs-string">'linear'</span>:
    curPower = <span class="hljs-number">1.0</span>

curScheduler = lr_polynomial_decay(epochs=epochs, initial_learning_rate=initial_learning_rate, power=curPower)

model = runModel()

sgd = keras.optimizers.SGD(learning_rate=initial_learning_rate)
model.compile(
              optimizer = sgd,
              loss=<span class="hljs-string">'sparse_categorical_crossentropy'</span>,
              metrics=[<span class="hljs-string">'accuracy'</span>])

neptune_cbk = NeptuneCallback(run=npt_exp_4, base_namespace=<span class="hljs-string">"metrics"</span>)

reset_random_seeds()

trainHistory_polyDecay = model.fit(
    x_train, y_train,
    epochs=epochs,
    batch_size=<span class="hljs-number">64</span>,
    validation_split=<span class="hljs-number">0.2</span>,
    callbacks=[neptune_cbk, LearningRateScheduler(curScheduler, verbose=<span class="hljs-number">1</span>)])

<span class="hljs-keyword">if</span> POLY_POWER == <span class="hljs-string">'linear'</span>:
    trainHistory_linearDecay = trainHistory_polyDecay
    plot_Neptune(history=trainHistory_linearDecay, decayTitle=<span class="hljs-string">'Linear Decay'</span>, npt_exp=npt_exp_4)
npt_exp_4.stop()</pre>



<p>运行这个模型，我们可以在Neptune项目中看到下面的性能图表，</p>







<p>根据验证集上的损失和准确性曲线，我们观察到，</p>



<ul>
<li>这两个指标在整个培训过程中都是波动的；</li>



<li>在大约40个时期之后，模型过度拟合发生，其中训练损失继续减少，而验证损失开始增加(并且准确度几乎是平坦的)。</li>
</ul>



<p>这种模式表明，随着训练的进行，我们的模型正在偏离，这很可能是因为学习率太高。</p>



<p>我们应该将学习率降低为纪元的线性函数吗？也许不是。如果有一个策略，学习率在训练开始时下降得更快，然后在训练结束时逐渐变平到一个小值，效果会更好。</p>



<p>这是非线性衰减的基本概念，其中最常用的有时基衰减和指数衰减。</p>



<h3>基于时间的衰减和指数衰减</h3>



<p>基于时间的衰减公式定义为:</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lr_time_based_decay</span><span class="hljs-params">(epoch, lr)</span>:</span>
        <span class="hljs-keyword">return</span> lr * <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + decay * epoch)</pre>



<p>其中“衰变”是一个参数，通常计算如下:</p>



<pre class="hljs">decay = initial_learning_rate/epochs</pre>



<p>让我们指定以下参数:</p>



<pre class="hljs">initial_learning_rate = <span class="hljs-number">0.5</span>
epochs = <span class="hljs-number">100</span>
decay = initial_learning_rate/epochs</pre>



<p>这个图表显示了生成的学习率曲线，</p>


<div class="wp-block-image">
<figure class="aligncenter"><img decoding="async" src="../Images/5e7aeeb5394a566967a885986f1ea782.png" alt="" data-original-src="https://web.archive.org/web/20230228190120im_/https://lh4.googleusercontent.com/_0fBDtfNoqbxg0bK-FGQd8Mh8CJIZAQwEYNwlZ5LW25M1ZDi9oaROTxr5rkCE8Mrxzuaadtf1i0qVutP_suefJeS76Aj1ldORfc46aRRAZ_Aj-wbENOuMsD4FQeSS3qphDCAgxHR=s0"/><figcaption class="wp-element-caption"><em>Time-based learning rate decay</em></figcaption></figure></div>


<p>与线性函数相比，基于时间的衰减导致学习率在训练开始时下降得更快，而在之后下降得更慢。和以前一样，让我们将这个调度器传递给<strong> LearningRateScheduler </strong>回调，并将性能图表记录到Neptune:</p>



<pre class="hljs">npt_exp_1 = neptune.init(
        api_token=os.getenv(<span class="hljs-string">'NEPTUNE_API_TOKEN'</span>),
        project=<span class="hljs-string">'YourUserName/YourProjectName'</span>,
        name=<span class="hljs-string">'TimeBasedLRDecay'</span>,
        description=<span class="hljs-string">'time-based-lr-decay'</span>,
        tags=[<span class="hljs-string">'LearningRate'</span>, <span class="hljs-string">'timebased'</span>, <span class="hljs-string">'decay'</span>, <span class="hljs-string">'neptune'</span>])


neptune_cbk = NeptuneCallback(run=npt_exp_1, base_namespace=<span class="hljs-string">"metrics"</span>)

trainHistory_timeBasedDecay = model.fit(...                callbacks=[neptune_cbk, LearningRateScheduler(lr_time_based_decay, verbose=<span class="hljs-number">1</span>)])


npt_exp_1[<span class="hljs-string">'Learning Rate Change (Time-Based Decay)'</span>].upload(neptune.types.File.as_image(plotLR(trainHistory_timeBasedDecay)))


npt_exp_1[<span class="hljs-string">'Training Performance Curves (Time-Based Decay)'</span>].upload(neptune.types.File.as_image(plotPerformance(trainHistory_timeBasedDecay).get_figure()))

npt_exp_1.stop()</pre>



<p>这是这个模型的性能，</p>







<p>正如我们所看到的，这个模型比线性衰减模型更适合验证集。一些观察，</p>



<ul>
<li>学习几乎在38个时期左右停止，因为我们的学习率降低到接近于零的值；</li>



<li>与线性场景类似，训练开始时会有一些较大的波动。</li>
</ul>



<p>现在，有办法消除这些波动吗？让我们转向指数衰减，它被定义为历元数的指数函数:</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lr_exp_decay</span><span class="hljs-params">(epoch)</span>:</span>
    k = <span class="hljs-number">0.1</span>
    <span class="hljs-keyword">return</span> initial_learning_rate * math.exp(-k*epoch)</pre>



<p>同样，指定initial_learning_rate = 0.5和epochs = 100将产生以下衰减曲线(相对于线性和基于时间的衰减)，</p>


<div class="wp-block-image">
<figure class="aligncenter"><img decoding="async" src="../Images/24c0384c36a1c7f29db9c08314d53ed8.png" alt="" data-original-src="https://web.archive.org/web/20230228190120im_/https://lh3.googleusercontent.com/oSQFySBCKlSqZ992x3CyCPhUsf2fEhhdsDOFfGbQeHR6olqp-lz1Jij_GuA5rCdPQ-S9zAZZLBs1ifOJ4k7CddHhXgtSOsqYoHZ6jMRcO83hs9pCA0DQiDzF7YrmgWhnoKfbSVP-=s0"/><figcaption class="wp-element-caption"><em>Learning rate decay comparison</em></figcaption></figure></div>


<p>指数方案在开始时提供了更平滑的衰减路径，这将导致更平滑的训练曲线。让我们运行这个模型，看看是否是这样:</p>



<pre class="hljs">npt_exp_3 = neptune.init(
        api_token=os.getenv(<span class="hljs-string">'NEPTUNE_API_TOKEN'</span>),
        project=<span class="hljs-string">'YourUserName/YourProjectName'</span>,
        name=<span class="hljs-string">'ExponentialLRDecay'</span>,
        description=<span class="hljs-string">'exponential-lr-decay'</span>,
        tags=[<span class="hljs-string">'LearningRate'</span>, <span class="hljs-string">'exponential'</span>, <span class="hljs-string">'decay'</span>, <span class="hljs-string">'neptune'</span>])

neptune_cbk = NeptuneCallback(run=npt_exp_3, base_namespace=<span class="hljs-string">"metrics"</span>)

trainHistory_expDecay = model.fit(...                callbacks=[neptune_cbk, LearningRateScheduler(lr_exp_decay, verbose=<span class="hljs-number">1</span>)])


npt_exp_3[<span class="hljs-string">'Learning Rate Change (Exponential Decay)'</span>].upload(neptune.types.File.as_image(plotLR(trainHistory_expDecay)))


npt_exp_3[<span class="hljs-string">'Training Performance Curves (Exponential Decay)'</span>].upload(neptune.types.File.as_image(plotPerformance(trainHistory_expDecay).get_figure()))

npt_exp_3.stop()</pre>



<p>下面是与验证集的比较，</p>





<p>很容易看出，指数衰减的训练曲线(橙色线)比基于时间的衰减(蓝色线)平滑得多。总体而言，指数衰减略胜一筹。</p>



<p>到目前为止，我们只研究了连续衰减策略，那么离散衰减策略呢？接下来，我们将继续讨论一个流行的离散阶梯衰变，也就是基于阶梯的衰变。</p>



<h3>基于阶跃的衰减</h3>



<p>在该策略下，我们的学习率被安排为每N个时期减少一定量:</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lr_step_based_decay</span><span class="hljs-params">(epoch)</span>:</span>
    drop_rate = <span class="hljs-number">0.8</span>
    epochs_drop = <span class="hljs-number">10.0</span>
    <span class="hljs-keyword">return</span> initial_learning_rate * math.pow(drop_rate, math.floor(epoch/epochs_drop))</pre>



<p>其中‘丢弃率’指定学习率被修改的量，而‘时期丢弃’指定修改的频率。</p>



<p>同上，设置我们的initial_learning_rate = 0.5和epochs = 100生成这个看起来像步骤的学习曲线，</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="../Images/c4848be400ab6c7298a7dd2a4a780324.png" alt="" data-original-src="https://web.archive.org/web/20230228190120im_/https://lh5.googleusercontent.com/qEFCRccdwSGuct9MMShXdEeT4aewTEZof1T-QubyiG27hDxF6foczqTaIHxl1qN1jCL8f77BgiVAPiExblypXAAuTVsI3D0rORzZzNX2XtNNcztKHL6kiouW8n7sioQQEXIoSC3z=s0"/><figcaption class="wp-element-caption"><em>Step-based learning rate decay </em></figcaption></figure>



<p>将它传递给我们的模型:</p>



<pre class="hljs">npt_exp_2 = neptune.init(
        api_token=os.getenv(<span class="hljs-string">'NEPTUNE_API_TOKEN'</span>),
        project=<span class="hljs-string">'YourUserName/YourProjectName'</span>,
        name=<span class="hljs-string">'StepBasedLRDecay'</span>,
        description=<span class="hljs-string">'step-based-lr-decay'</span>,
        tags=[<span class="hljs-string">'LearningRate'</span>, <span class="hljs-string">'stepbased'</span>, <span class="hljs-string">'decay'</span>, <span class="hljs-string">'neptune'</span>])


neptune_cbk = NeptuneCallback(run=npt_exp_2, base_namespace=<span class="hljs-string">"metrics"</span>)

trainHistory_stepBasedDecay = model.fit(...,         callbacks=[neptune_cbk, LearningRateScheduler(lr_step_based_decay, verbose=<span class="hljs-number">1</span>)])


npt_exp_2[<span class="hljs-string">'Learning Rate Change (Step-Based Decay)'</span>].upload(neptune.types.File.as_image(plotLR(trainHistory_stepBasedDecay)))


npt_exp_2[<span class="hljs-string">'Training Performance Curves (Step-Based Decay)'</span>].upload(neptune.types.File.as_image(plotPerformance(trainHistory_stepBasedDecay).get_figure()))

npt_exp_2.stop() </pre>



<p>我们会有与线性衰减非常相似的性能图表，其中我们的模型过度拟合。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/582888551afc775d634bd22ded9d7be4.png" alt="StepBasedLRDecay-loss" class="wp-image-52453" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230228190120im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/StepBasedLRDecay-loss.png?ssl=1"/><figcaption class="wp-element-caption"><em>Step-based learning rate schedule performance chart | <a href="https://web.archive.org/web/20230228190120/https://app.neptune.ai/katyl/LearningRateSheduleV2/e/LEAR2-25/charts" target="_blank" rel="noreferrer noopener">See in Neptune</a></em></figcaption></figure>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/784422a936a493f538edfa7590317c09.png" alt="StepBasedLRDecay-accuracy" class="wp-image-52454" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230228190120im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/StepBasedLRDecay-accuracy.png?ssl=1"/><figcaption class="wp-element-caption"><em> <em>Step-based learning rate schedule performance chart | <a href="https://web.archive.org/web/20230228190120/https://app.neptune.ai/katyl/LearningRateSheduleV2/e/LEAR2-25/charts" target="_blank" rel="noreferrer noopener">See in Neptune</a></em> </em></figcaption></figure>



<h2 id="selection">模型性能基准</h2>



<p>随着各种衰变方案的实施，我们现在可以把东西放在一起比较模型的表现。</p>


<div class="wp-block-image">
<figure class="aligncenter"><img decoding="async" src="../Images/900bb52e6b675ed8f3559a2b8f8982b3.png" alt="" data-original-src="https://web.archive.org/web/20230228190120im_/https://lh4.googleusercontent.com/VjIXrwV3x6XTUGOBkRLjb1Hqqs97_u9EUjmHqkAIAPqBZtG2DoFTpgW9l8zG9XRxJpu_lCLlHJJqEsOHKk6ZG1o44CRtSiM89hqDEVan38UqW_DGPNvuZTtb--t0iIJ79HMBEs3j=s0"/><figcaption class="wp-element-caption"><em>Learning rate schedulers </em></figcaption></figure></div>


<p>基于我们的实验，总体来看，学习在大约60个时期停止；因此，为了便于可视化，我们将放大以关注前60个时期。和以前一样，我们将在Neptune中记录跟踪图:</p>



<pre class="hljs">
npt_exp_master = neptune.init(
        api_token=os.getenv(<span class="hljs-string">'NEPTUNE_API_TOKEN'</span>),
        project=<span class="hljs-string">'YourUserName/YourProjectName'</span>,
        name=<span class="hljs-string">'ModelComparison'</span>,
        description=<span class="hljs-string">'compare-lr-schedulers'</span>,
        tags=[<span class="hljs-string">'LearningRate'</span>, <span class="hljs-string">'schedulers'</span>, <span class="hljs-string">'comparison'</span>, <span class="hljs-string">'neptune'</span>])


masterComparePlot(<span class="hljs-string">'val_loss'</span>, ylab=<span class="hljs-string">'Loss on the Validation Set'</span>, plotTitle=<span class="hljs-string">'Compare Validation Loss'</span>,                  NeptuneImageTitle=<span class="hljs-string">'Compare Model Performance -- Loss'</span>, includeAdaptive=<span class="hljs-keyword">False</span>)


masterComparePlot(<span class="hljs-string">'val_accuracy'</span>, ylab=<span class="hljs-string">'Accuracy on the Validation Set'</span>, plotTitle=<span class="hljs-string">'Compare Validation Accuracy'</span>,                   NeptuneImageTitle=<span class="hljs-string">'Compare Model Performance -- Accuracy'</span>, includeAdaptive=<span class="hljs-keyword">False</span>)


masterComparePlot(<span class="hljs-string">'lr'</span>, ylab=<span class="hljs-string">'Learning Rate'</span>, plotTitle=<span class="hljs-string">'Compare Learning Rate Curves Generated from Different Schedulers'</span>,                  NeptuneImageTitle=<span class="hljs-string">'Compare Learning Rate Curves'</span>, includeAdaptive=<span class="hljs-keyword">False</span>, subset=<span class="hljs-keyword">False</span>)

npt_exp_master.stop()
</pre>


<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" src="../Images/80d41e7d154158e7878e16102cbca64a.png" alt="LearningRateShedule-loss" class="wp-image-52456" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230228190120im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/LearningRateShedule-loss.png?ssl=1"/><figcaption class="wp-element-caption"><em>Loss curves on the validation set with different schedulers | <a href="https://web.archive.org/web/20230228190120/https://app.neptune.ai/katyl/LearningRateSheduleV2/experiments?compare=EzA0YRlKaA&amp;split=cmp&amp;dash=charts&amp;viewId=standard-view&amp;chartFilter=" target="_blank" rel="noreferrer noopener">See in Neptune</a></em></figcaption></figure></div>

<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" src="../Images/c6357677f710eabfa820200324f8bde3.png" alt="LearningRateShedule accuracy" class="wp-image-52457" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20230228190120im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/LearningRateShedule-accuracy.png?ssl=1"/><figcaption class="wp-element-caption"><em>Accuracy curves on the validation set with different schedulers</em> | <em><a href="https://web.archive.org/web/20230228190120/https://app.neptune.ai/katyl/LearningRateSheduleV2/experiments?compare=EzA0YRlKaA&amp;split=cmp&amp;dash=charts&amp;viewId=standard-view&amp;chartFilter=" target="_blank" rel="noreferrer noopener">See in Neptune</a></em> </figcaption></figure></div>


<p>上述当前练习的性能图表表明，指数衰减的性能最好，其次是基于时间的衰减；线性和基于步进的衰减方案导致模型过拟合。</p>



<h2 id="h-adaptive-optimizers">自适应优化器</h2>



<p>除了带学习率调度器的SGD，第二个最有影响力的优化技术是自适应优化器，比如<a href="https://web.archive.org/web/20230228190120/https://ruder.io/optimizing-gradient-descent/index.html#adam" target="_blank" rel="noreferrer noopener nofollow"> AdaGrad，RMSprop，Adam </a>等等。这些优化器使用模型内部反馈来近似梯度；这意味着它们几乎是无参数的，并且与我们前面提到的与SGD相反的学习率调度器不兼容。</p>



<p>在所有自适应优化器中，<a href="https://web.archive.org/web/20230228190120/https://optimization.cbe.cornell.edu/index.php?title=Adam" target="_blank" rel="noreferrer noopener nofollow"> Adam </a>一直是机器学习实践者的最爱。虽然关于这个优化器的细节超出了本文的范围，但是值得一提的是，Adam为每个模型参数/权重分别更新了学习率。这意味着使用Adam，学习率可能首先在早期层增加，从而有助于提高深度神经网络的效率。</p>



<p>现在，为了更好地衡量，让我们用Keras默认的“Adam”优化器来训练我们的模型，作为最后一个实验:</p>



<pre class="hljs">npt_exp_5 = neptune.init(
        api_token=os.getenv(<span class="hljs-string">'NEPTUNE_API_TOKEN'</span>),
        project=<span class="hljs-string">'YourUserName/YourProjectName'</span>,
        name=<span class="hljs-string">'Adaptive'</span>,
        description=<span class="hljs-string">'adaptive-lr'</span>,
        tags=[<span class="hljs-string">'LearningRate'</span>, <span class="hljs-string">'adam'</span>, <span class="hljs-string">'neptune'</span>])


neptune_cbk = NeptuneCallback(run=npt_exp_5, base_namespace=<span class="hljs-string">"metrics"</span>)
model = runModel()


adam = keras.optimizers.Adam()
lr_metric = get_lr_metric(adam)

model.compile(optimizer=adam,                     loss=<span class="hljs-string">'sparse_categorical_crossentropy'</span>,                   metrics=[<span class="hljs-string">'accuracy'</span>, lr_metric])

reset_random_seeds()

trainHistory_adaptive = model.fit(
        x_train, y_train,
        epochs=<span class="hljs-number">100</span>,
        batch_size=<span class="hljs-number">64</span>,
        validation_split=<span class="hljs-number">0.2</span>,
        callbacks=[neptune_cbk])

plot_Neptune(history=trainHistory_adaptive, decayTitle=<span class="hljs-string">'Adam Optimizer'</span>, npt_exp=npt_exp_5)

npt_exp_5.stop()</pre>



<p>毫无疑问，这个“亚当”学习者让我们的模型很快发散，</p>







<p>尽管“Adam”是一个高效的学习者，但如果不进行超参数调整，“Adam”并不总是最佳选择。另一方面，SGD可以通过调整学习率或衰减调度程序显著提高性能。</p>



<h2 id="final-thoughts">最后的想法</h2>



<p>通过我们所有的实验，我们应该更好地理解学习进度有多重要；过度积极的衰减会导致优化器永远不会达到最小值，而缓慢的衰减会导致混乱的更新而没有显著的改善。</p>



<p>一些提示和要点包括:</p>



<ul>
<li>为了选择学习率时间表，<a href="https://web.archive.org/web/20230228190120/https://arxiv.org/pdf/1908.06477.pdf" target="_blank" rel="noreferrer noopener nofollow">通常的做法</a>是从一个不太小的值开始，例如0.5，然后指数地降低它以获得更小的值，例如0.01、0.001、0.0001；</li>



<li>虽然经常是深度学习应用程序中的默认优化器，但幕后的`<em>亚当</em> <strong> ` </strong>并不一定总是表现出色；它会导致模型<a href="https://web.archive.org/web/20230228190120/https://arxiv.org/pdf/1904.09237.pdf" target="_blank" rel="noreferrer noopener nofollow">发散</a>；</li>



<li>为了建立有效的模型，我们还应该考虑其他超参数，如动量、正则化参数(丢失、提前停止等)。).</li>
</ul>



<p>最后，值得一提的是，目前的结果是基于一个神经网络和数据集。当涉及到使用其他数据集的其他模型时，最佳学习率计划可能会有所不同。尽管如此，本文应该为您提供一个指南，告诉您如何系统地选择一个最适合您的特定模型和数据集的学习率调度器。</p>



<p>希望这篇文章对您有所帮助。我们的Neptune项目可以在这里访问<a href="https://web.archive.org/web/20230228190120/https://app.neptune.ai/katyl/LearningRateSheduleV2/experiments?compare=BwGgTOkdUgjPRcg&amp;split=bth&amp;dash=charts&amp;viewId=standard-view" target="_blank" rel="noreferrer noopener">，完整的脚本可以在我的Github repo </a><a href="https://web.archive.org/web/20230228190120/https://github.com/YiLi225/NeptuneBlogs/blob/main/LearningRateScheduler_v2.py" target="_blank" rel="noreferrer noopener nofollow">这里</a>获得。</p>
        </div>
        
    </div>    
</body>
</html>