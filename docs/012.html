<html>
<head>
<title>Knowledge Graphs With Machine Learning [Guide] </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>具有机器学习的知识图[指南]</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/web-scraping-and-knowledge-graphs-machine-learning#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/web-scraping-and-knowledge-graphs-machine-learning#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p>你需要在网上获取一些信息。比如关于尤塞恩博尔特的几段话。你可以从维基百科复制并粘贴信息，这不会有太多的工作。</p>



<p>但是，如果您需要获得关于尤塞恩·博尔特参加的所有比赛的信息，以及关于他和他的竞争对手的所有相关统计数据，该怎么办呢？如果你想对所有运动都这样做，而不仅仅是跑步，会怎么样？</p>



<p>机器学习工程师通常需要建立如上例的复杂数据集来训练他们的模型。网络搜集是收集必要数据的一种非常有用的方法，但也带来了一些挑战。</p>



<p>在这篇文章中，我将解释如何收集公开可用的数据，并从收集的数据中构建知识图，以及来自<a href="https://web.archive.org/web/20221206032313/https://www.datacamp.com/community/tutorials/web-scraping-python-nlp" target="_blank" rel="noreferrer noopener nofollow">自然语言处理</a> (NLP)的一些关键概念。</p>



<h2 id="h-what-is-web-scraping">什么是网页抓取？</h2>



<p>Web抓取(或web采集)是用于数据提取的数据抓取。<strong>一词通常指用机器人或网络爬虫</strong>收集数据。这是一种复制形式，从web上收集并复制特定数据，通常复制到本地数据库或电子表格中，以供以后使用或分析。</p>





<p>你可以用在线服务、API来做网络抓取，或者你可以写你自己的代码来做。</p>



<p>网络抓取有两个关键要素:</p>



<ul>
<li>爬虫:爬虫是一种算法，通过浏览互联网上的链接来浏览网页以搜索特定的数据。</li>



<li><strong>抓取器</strong>:抓取器从网站中提取数据。刮刀的<strong>设计可以有很大变化</strong>。这取决于<strong>项目的复杂程度和范围</strong>。最终，它必须快速准确地提取数据。</li>
</ul>



<p>现成库的一个很好的例子是Wikipedia scraper库。它为你做了很多繁重的工作。您向URL提供所需的数据，它从这些站点加载所有的HTML。scraper从这个HTML代码中获取您需要的数据，并以您选择的格式输出数据。这可以是excel电子表格或CSV，或者类似于<a href="https://web.archive.org/web/20221206032313/https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON" target="_blank" rel="noreferrer noopener nofollow"> JSON </a>的格式。</p>



<h2 id="h-knowledge-graph">知识图表</h2>



<p>网络上可用的内容数量已经令人难以置信，而且还在以越来越快的速度增长。数十亿个网站与万维网相连，<a href="/web/20221206032313/https://neptune.ai/blog/building-search-engine-with-pre-trained-transformers-guide" target="_blank" rel="noreferrer noopener"> <strong>搜索引擎</strong> </a>可以通过这些链接，以极高的精度和速度提供有用的信息。这部分归功于知识图表。</p>



<p>不同的组织有不同的知识图表。例如，<a href="https://web.archive.org/web/20221206032313/https://en.wikipedia.org/wiki/Google_Knowledge_Graph" target="_blank" rel="noreferrer noopener nofollow"> <strong>谷歌知识图</strong> </a> <strong> </strong>是一个知识库<strong>，谷歌及其服务利用从各种来源收集的信息来增强搜索引擎结果</strong>。为了更好的用户体验，以及存储和检索有用的信息，脸书或亚马逊的产品也使用了类似的技术。</p>



<p>知识图没有正式的定义。广义地说，KG是一种添加了约束的语义网络。它的范围、结构和特征，甚至它的用途在开发过程中还没有完全实现。</p>



<p>将知识图和机器学习(ML)结合在一起可以系统地提高系统的准确性，并扩展机器学习能力的范围。<strong>得益于知识图，从机器学习模型推断出的结果将具有更好的可解释性和可信度</strong>。</p>



<p>将知识图和ML结合在一起创造了一些有趣的机会。在我们可能没有足够数据的情况下，可以使用kg来扩充训练数据。最大似然模型的主要挑战之一是解释最大似然系统做出的预测。通过将解释映射到图中的适当节点并总结决策过程，知识图可以帮助克服这个问题。</p>







<p>另一种看待它的方式是，知识图存储从信息提取任务中产生的数据。KG的许多实现利用了一个叫做<strong>三元组</strong>的概念——一组三个项目(<strong>一个主语、一个谓语和一个宾语</strong>)，我们可以用它们来存储关于某件事情的信息。</p>



<p>还有另一种解释:知识图是一种数据科学工具，处理相互关联的实体<strong> ( </strong>组织、人员、事件、地点<strong> ) </strong>。<strong>实体是通过边连接的节点</strong>。kg具有实体对，可以遍历这些实体对来发现非结构化数据中有意义的连接。</p>





<p>节点A和节点B是两个不同的实体。这些节点由表示它们之间关系的边连接起来。这是我们能制造的最小公斤——也被称为三公斤。知识图表有各种形状和大小。</p>



<h2 id="h-web-scraping-computational-linguistics-nlp-algorithms-and-graph-theory-with-python-code">网络抓取、计算语言学、NLP算法和图论(带Python代码)</h2>



<p>唷，这是一个冗长的标题。无论如何，要从文本构建知识图，帮助我们的机器理解自然语言很重要。我们使用NLP技术来实现这一点，例如<strong>句子分割、依存解析、词性(POS)标注和实体识别</strong>。</p>



<p>构建KG的第一步是收集您的资源——让我们在网上搜索一些信息。维基百科将是我们的来源(经常检查数据来源，网上很多信息都是假的)。</p>



<p>对于这个博客，我们将使用<a href="https://web.archive.org/web/20221206032313/https://github.com/martin-majlis/Wikipedia-API/" target="_blank" rel="noreferrer noopener nofollow">维基百科API </a>，一个直接的Python包装器。<a href="/web/20221206032313/https://neptune.ai/" target="_blank" rel="noreferrer noopener"> Neptune </a>在一个地方管理模型构建元数据。记录、存储、显示、组织、比较和查询您所有的MLOps元数据。</p>



<p><a href="/web/20221206032313/https://neptune.ai/experiment-tracking" target="_blank" rel="noreferrer noopener">实验跟踪</a>以及为运行大量实验的研究和生产团队构建的模型注册表。</p>



<h3>安装和设置</h3>



<h4>安装依赖项并抓取数据</h4>



<pre class="hljs">!pip install wikipedia-api neptune-client neptune-notebooks pandas spacy networkx scipy</pre>



<section id="blog-intext-cta-block_edfbee3dee664b1a8819e458107bd629" class="block-blog-intext-cta  c-box c-box--default c-box--dark c-box--no-hover c-box--standard ">

            
    
            <p>按照以下链接在您的笔记本上安装和设置Neptune:rn-<a href="https://web.archive.org/web/20221206032313/https://docs.neptune.ai/getting-started/installation#install-neptune-client-for-python" target="_blank" rel="noopener">Neptune</a><br/>–<a href="https://web.archive.org/web/20221206032313/https://docs.neptune.ai/integrations-and-supported-tools/ide-and-notebooks/jupyter-lab-and-jupyter-notebook/install-neptune-notebooks-jupyter-extension-3-min#about-neptune-notebooks" target="_blank" rel="noopener">Neptune Jupyter扩展指南</a></p>
    
    </section>



<p>下面的函数在维基百科中搜索给定的主题，并从目标页面及其内部链接中提取信息。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> wikipediaapi  
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> concurrent.futures
<span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm</pre>



<p>below函数允许您根据作为函数输入提供的主题获取文章。</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scrape_wikipedia</span><span class="hljs-params">(name_topic, verbose=True)</span>:</span>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">link_to_wikipedia</span><span class="hljs-params">(link)</span>:</span>
       <span class="hljs-keyword">try</span>:
           page = api_wikipedia.page(link)
           <span class="hljs-keyword">if</span> page.exists():
               <span class="hljs-keyword">return</span> {<span class="hljs-string">'page'</span>: link, <span class="hljs-string">'text'</span>: page.text, <span class="hljs-string">'link'</span>: page.fullurl, <span class="hljs-string">'categories'</span>: list(page.categories.keys())}
       <span class="hljs-keyword">except</span>:
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>

   api_wikipedia = wikipediaapi.Wikipedia(language=<span class="hljs-string">'en'</span>, extract_format=wikipediaapi.ExtractFormat.WIKI)
   name_of_page = api_wikipedia.page(name_topic)
   <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name_of_page.exists():
       print(<span class="hljs-string">'Page {} is not present'</span>.format(name_of_page))
       <span class="hljs-keyword">return</span>

   links_to_page = list(name_of_page.links.keys())
   procceed = tqdm(desc=<span class="hljs-string">'Scraped links'</span>, unit=<span class="hljs-string">''</span>, total=len(links_to_page)) <span class="hljs-keyword">if</span> verbose <span class="hljs-keyword">else</span> <span class="hljs-keyword">None</span>
   origin = [{<span class="hljs-string">'page'</span>: name_topic, <span class="hljs-string">'text'</span>: name_of_page.text, <span class="hljs-string">'link'</span>: name_of_page.fullurl, <span class="hljs-string">'categories'</span>: list(name_of_page.categories.keys())}]

   <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> executor:
       links_future = {executor.submit(link_to_wikipedia, link): link <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links_to_page}
       <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> concurrent.futures.as_completed(links_future):
           info = future.result()
           origin.append(info) <span class="hljs-keyword">if</span> info <span class="hljs-keyword">else</span> <span class="hljs-keyword">None</span>
           procceed.update(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> verbose <span class="hljs-keyword">else</span> <span class="hljs-keyword">None</span>
   procceed.close() <span class="hljs-keyword">if</span> verbose <span class="hljs-keyword">else</span> <span class="hljs-keyword">None</span>

   namespaces = (<span class="hljs-string">'Wikipedia'</span>, <span class="hljs-string">'Special'</span>, <span class="hljs-string">'Talk'</span>, <span class="hljs-string">'LyricWiki'</span>, <span class="hljs-string">'File'</span>, <span class="hljs-string">'MediaWiki'</span>,
                 <span class="hljs-string">'Template'</span>, <span class="hljs-string">'Help'</span>, <span class="hljs-string">'User'</span>, <span class="hljs-string">'Category talk'</span>, <span class="hljs-string">'Portal talk'</span>)
   origin = pds.DataFrame(origin)
   origin = origin[(len(origin[<span class="hljs-string">'text'</span>]) &gt; <span class="hljs-number">20</span>)
                     &amp; ~(origin[<span class="hljs-string">'page'</span>].str.startswith(namespaces, na=<span class="hljs-keyword">True</span>))]
   origin[<span class="hljs-string">'categories'</span>] = origin.categories.apply(<span class="hljs-keyword">lambda</span> a: [b[<span class="hljs-number">9</span>:] <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> a])

   origin[<span class="hljs-string">'topic'</span>] = name_topic
   print(<span class="hljs-string">'Scraped pages'</span>, len(origin))

   <span class="hljs-keyword">return</span> origin</pre>



<p>让我们测试主题为“新冠肺炎”的函数。</p>



<pre class="hljs">wiki_data = wiki_scrape(<span class="hljs-string">'COVID 19'</span>)
</pre>



<pre class="hljs">o/p: Links Scraped: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">1965</span>/<span class="hljs-number">1965</span> [<span class="hljs-number">04</span>:<span class="hljs-number">30</span>&lt;<span class="hljs-number">00</span>:<span class="hljs-number">00</span>,  <span class="hljs-number">7.25</span>/s]ages scraped: <span class="hljs-number">1749</span>
</pre>



<p>将数据保存到csv:</p>



<pre class="hljs">data_wikipedia.to_csv(<span class="hljs-string">'scraped_data.csv'</span>)</pre>



<p>导入库:</p>



<pre class="hljs"><span class="hljs-keyword">import</span> spacy
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> spacy <span class="hljs-keyword">import</span> displacy


nlp = spacy.load(<span class="hljs-string">'en_core_web_sm'</span>)

<span class="hljs-keyword">from</span> spacy.tokens <span class="hljs-keyword">import</span> Span
<span class="hljs-keyword">from</span> spacy.matcher <span class="hljs-keyword">import</span> Matcher

<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plot
<span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm
<span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> ntx
<span class="hljs-keyword">import</span> neptune.new <span class="hljs-keyword">as</span> neptune

%matplotlib inline</pre>



<pre class="hljs">run = neptune.init(api_token=<span class="hljs-string">"your API key"</span>,
                   project=<span class="hljs-string">"aravindcr/KnowledgeGraphs"</span>)</pre>



<p>上传数据到海王星:</p>



<pre class="hljs">run[<span class="hljs-string">"data"</span>].upload(<span class="hljs-string">"scraped_data.csv"</span>)</pre>



<p>在这里下载数据<a href="https://web.archive.org/web/20221206032313/https://github.com/AravindR7/Web_Scraping_Knowledge_Graphs/blob/main/scraped_data.zip" target="_blank" rel="noreferrer noopener nofollow">。在</a><a href="https://web.archive.org/web/20221206032313/https://app.neptune.ai/aravindcr/KnowledgeGraphs/e/KNOW-9/all?path=&amp;attribute=data">号海王</a>号上也有:</p>



<pre class="hljs">data = pd.read_csv(<span class="hljs-string">'scraped_data.csv'</span>)
</pre>



<p>查看第10行的数据:</p>



<pre class="hljs">data[<span class="hljs-string">'text'</span>][<span class="hljs-number">10</span>]
</pre>



<p>输出:</p>



<pre class="hljs">The AbC<span class="hljs-number">-19</span> rapid antibody test <span class="hljs-keyword">is</span> an immunological test <span class="hljs-keyword">for</span> COVID<span class="hljs-number">-19</span> exposure
developed by the UK Rapid Test Consortium <span class="hljs-keyword">and</span> manufactured by Abingdon
Health. It uses a lateral flow test to determine whether a person has IgG
antibodies to the SARS-CoV<span class="hljs-number">-2</span> virus that causes COVID<span class="hljs-number">-19.</span> The test uses a single
drop of blood obtained <span class="hljs-keyword">from</span> a finger prick <span class="hljs-keyword">and</span> yields results <span class="hljs-keyword">in</span> <span class="hljs-number">20</span> minutes.</pre>



<h3>句子分割</h3>



<p>构建知识图的第一步是将文本文档或文章分割成句子。然后我们把例子限制在只有一个主语和一个宾语的简单句上。</p>



<pre class="hljs">
docu = nlp(<span class="hljs-string">'''The AbC-19 rapid antibody test is an immunological test for COVID-19 exposure developed by
the UK Rapid Test Consortium and manufactured by Abingdon Health. It uses a lateral flow test to determine
whether a person has IgG antibodies to the SARS-CoV-2 virus that causes COVID-19. The test uses a single
drop of blood obtained from a finger prick and yields results in 20 minutes.nnSee alsonCOVID-19 rapid
antigen test'''</span>)

<span class="hljs-keyword">for</span> tokn <span class="hljs-keyword">in</span> docu:
   print(tokn.text, <span class="hljs-string">"---"</span>, tokn.dep_)</pre>



<p>下载如下所示的预训练空间模型:</p>



<pre class="hljs">python -m spacy download en</pre>



<p>SpaCy管道分配单词向量、上下文特定的标记向量、词性标记、依存解析和命名实体。通过扩展SpaCy的注释管道，您可以解析共同引用(在下面的代码中解释)。</p>



<p>知识图可以从词性和依存句法分析中自动构建。使用NLP库空间，从语法模式中提取实体对是快速的，并且可扩展到大量文本。</p>



<p>下面的函数<strong>将实体对定义为由根动词</strong>连接的具有主客体依赖关系的实体/名词块。可以使用其他近似方法来产生不同类型的连接。这种联系可以称为主谓宾三元组。</p>



<p>主要意思是浏览一个句子，提取主语和宾语，以及它们何时出现。下面的函数包含了上面提到的一些步骤。</p>



<h3>实体提取</h3>



<p>您可以借助词性(<strong> POS </strong>)标签从句子中提取单个单词实体。名词和专有名词将是实体。</p>



<p>然而，当一个实体包含多个单词时，仅靠POS标签是不够的。我们需要分析句子的依存关系树。构建知识图，最重要的是它们之间的节点和边。</p>



<p>这些节点将是出现在维基百科句子中的实体。边是连接这些实体的关系。我们将以无人监督的方式提取这些元素，也就是说，我们将使用句子的语法。</p>



<p>这个想法是通过一个句子，当主语和宾语被重构时，提取它们。</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract_entities</span><span class="hljs-params">(sents)</span>:</span>
   
   enti_one = <span class="hljs-string">""</span>
   enti_two = <span class="hljs-string">""</span>

   dep_prev_token = <span class="hljs-string">""</span> 

   txt_prev_token = <span class="hljs-string">""</span> 

   prefix = <span class="hljs-string">""</span>
   modifier = <span class="hljs-string">""</span>



   <span class="hljs-keyword">for</span> tokn <span class="hljs-keyword">in</span> nlp(sents):
       
       

       <span class="hljs-keyword">if</span> tokn.dep_ != <span class="hljs-string">"punct"</span>:
           
           <span class="hljs-keyword">if</span> tokn.dep_ == <span class="hljs-string">"compound"</span>:
               prefix = tokn.text
               
               <span class="hljs-keyword">if</span> dep_prev_token == <span class="hljs-string">"compound"</span>:
                   prefix = txt_prev_token + <span class="hljs-string">" "</span>+ tokn.text

           
           <span class="hljs-keyword">if</span> tokn.dep_.endswith(<span class="hljs-string">"mod"</span>) == <span class="hljs-keyword">True</span>:
               modifier = tokn.text
               
               <span class="hljs-keyword">if</span> dep_prev_token == <span class="hljs-string">"compound"</span>:
                   modifier = txt_prev_token + <span class="hljs-string">" "</span>+ tokn.text

           
           <span class="hljs-keyword">if</span> tokn.dep_.find(<span class="hljs-string">"subj"</span>) == <span class="hljs-keyword">True</span>:
               enti_one = modifier +<span class="hljs-string">" "</span>+ prefix + <span class="hljs-string">" "</span>+ tokn.text
               prefix = <span class="hljs-string">""</span>
               modifier = <span class="hljs-string">""</span>
               dep_prev_token = <span class="hljs-string">""</span>
               txt_prev_token = <span class="hljs-string">""</span>

           
           <span class="hljs-keyword">if</span> tokn.dep_.find(<span class="hljs-string">"obj"</span>) == <span class="hljs-keyword">True</span>:
               enti_two = modifier +<span class="hljs-string">" "</span>+ prefix +<span class="hljs-string">" "</span>+ tokn.text

           
           
           dep_prev_token = tokn.dep_
           txt_prev_token = tokn.text

   <span class="hljs-keyword">return</span> [enti_one.strip(), enti_two.strip()]</pre>



<pre class="hljs">extract_entities(<span class="hljs-string">"The AbC-19 rapid antibody test is an immunological test for COVID-19 exposure developed by the UK Rapid Test"</span>)</pre>



<pre class="hljs">[<span class="hljs-string">'AbC-19 rapid antibody test'</span>, <span class="hljs-string">'COVID-19 UK Rapid Test'</span>]</pre>



<p>现在让我们使用函数来提取800个句子的实体对。</p>



<pre class="hljs">pairs_of_entities = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(data[<span class="hljs-string">'text'</span>][:<span class="hljs-number">800</span>]):
   pairs_of_entities.append(extract_entities(i))
</pre>



<p>句子中的主语和宾语对:</p>



<pre class="hljs">pairs_of_entities[<span class="hljs-number">36</span>:<span class="hljs-number">42</span>]
</pre>



<p>输出:</p>



<pre class="hljs">[[<span class="hljs-string">'where aluminium powder'</span>, <span class="hljs-string">'such explosives manufacturing'</span>],
 [<span class="hljs-string">'310  people'</span>, <span class="hljs-string">'Cancer Research UK'</span>],
 [<span class="hljs-string">'Structural External links'</span>, <span class="hljs-string">'2 PDBe KB'</span>],
 [<span class="hljs-string">'which'</span>, <span class="hljs-string">'1 Medical Subject Headings'</span>],
 [<span class="hljs-string">'Structural External links'</span>, <span class="hljs-string">'2 PDBe KB'</span>],
 [<span class="hljs-string">'users'</span>, <span class="hljs-string">'permanently  taste'</span>]]
</pre>



<h3>关系抽取</h3>



<p>有了实体提取，一半的工作就完成了。为了构建知识图，我们需要连接节点(实体)。这些边是节点对之间的关系。下面的函数能够从这些句子中捕获这样的谓词。我用的是spaCy的基于规则的匹配。函数中定义的模式试图找到<strong>词根</strong>或句子中的主要动词。</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">obtain_relation</span><span class="hljs-params">(sent)</span>:</span>

   doc = nlp(sent)

   matcher = Matcher(nlp.vocab)

   pattern = [{<span class="hljs-string">'DEP'</span>:<span class="hljs-string">'ROOT'</span>},
           {<span class="hljs-string">'DEP'</span>:<span class="hljs-string">'prep'</span>,<span class="hljs-string">'OP'</span>:<span class="hljs-string">"?"</span>},
           {<span class="hljs-string">'DEP'</span>:<span class="hljs-string">'agent'</span>,<span class="hljs-string">'OP'</span>:<span class="hljs-string">"?"</span>},
           {<span class="hljs-string">'POS'</span>:<span class="hljs-string">'ADJ'</span>,<span class="hljs-string">'OP'</span>:<span class="hljs-string">"?"</span>}]

   matcher.add(<span class="hljs-string">"matching_1"</span>, <span class="hljs-keyword">None</span>, pattern)

   matcher = matcher(doc)
   h = len(matcher) - <span class="hljs-number">1</span>

   span = doc[matcher[h][<span class="hljs-number">1</span>]:matcher[h][<span class="hljs-number">2</span>]]

   <span class="hljs-keyword">return</span> (span.text</pre>



<p>上面写的模式试图在句子中找到词根。一旦它被识别出来，它就会检查它后面是否跟有介词或代理词。如果答案是肯定的，那么它将被添加到词根中。</p>



<pre class="hljs">relations = [obtain_relation(j) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> tqdm(data[<span class="hljs-string">'text'</span>][:<span class="hljs-number">800</span>])]</pre>



<p>提取的最常见关系:</p>



<pre class="hljs">pd.Series(relations).value_counts()[:<span class="hljs-number">50</span>]
</pre>



<h2 id="h-lets-build-a-knowledge-graph">让我们建立一个知识图表</h2>



<p>现在我们终于可以从提取的实体中创建一个知识图了</p>



<p>让我们使用<a href="https://web.archive.org/web/20221206032313/https://networkx.org/documentation/stable/tutorial.html" target="_blank" rel="noreferrer noopener nofollow"> <strong> <em> networkX </em> </strong> </a>库来绘制网络。我们将创建一个节点大小与度中心性成比例的有向多图网络。换句话说，任何连接的节点对之间的关系都不是双向的。它们只是从一个节点到另一个节点。</p>



<pre class="hljs">
source = [j[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> pairs_of_entities]


target = [k[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> pairs_of_entities]

data_kgf = pd.DataFrame({<span class="hljs-string">'source'</span>:source, <span class="hljs-string">'target'</span>:target, <span class="hljs-string">'edge'</span>:relations})
</pre>



<ul>
<li>我们使用networkx库从数据帧创建一个网络。</li>



<li>这里，节点将被表示为实体，而边表示节点之间的关系</li>
</ul>



<pre class="hljs">
graph = ntx.from_pandas_edgelist(data_kgf, <span class="hljs-string">"source"</span>, <span class="hljs-string">"target"</span>,
                         edge_attr=<span class="hljs-keyword">True</span>, create_using=ntx.MultiDiGraph())</pre>



<pre class="hljs">
plot.figure(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">14</span>))
posn = ntx.spring_layout(graph)
ntx.draw(graph, with_labels=<span class="hljs-keyword">True</span>, node_color=<span class="hljs-string">'green'</span>, edge_cmap=plot.cm.Blues, pos = posn)
plot.show()</pre>





<ul>
<li>从上面的图表中，不清楚在图表中捕捉到了什么关系</li>



<li>让我们用一些关系来形象化图表。我在这里选择:</li>
</ul>



<pre class="hljs">graph = ntx.from_pandas_edgelist(data_kgf[data_kgf[<span class="hljs-string">'edge'</span>]==<span class="hljs-string">"Information from"</span>], <span class="hljs-string">"source"</span>, <span class="hljs-string">"target"</span>,
                         edge_attr=<span class="hljs-keyword">True</span>, create_using=ntx.MultiDiGraph())

plot.figure(figsize=(<span class="hljs-number">14</span>,<span class="hljs-number">14</span>))
pos = ntx.spring_layout(graph, k = <span class="hljs-number">0.5</span>) 
ntx.draw(graph, with_labels=<span class="hljs-keyword">True</span>, node_color=<span class="hljs-string">'green'</span>, node_size=<span class="hljs-number">1400</span>, edge_cmap=plot.cm.Blues, pos = posn)
plot.show()
</pre>





<ul>
<li>另一个用关系名“链接”过滤的图可以在这里找到<a href="https://web.archive.org/web/20221206032313/https://app.neptune.ai/aravindcr/KnowledgeGraphs/e/KNOW-9/all?path=graphs&amp;attribute=filtered_relations2">。</a></li>
</ul>



<h3>记录元数据</h3>



<p>我已经把上面的networkx图登录到<a href="https://web.archive.org/web/20221206032313/https://docs.neptune.ai/you-should-know/logging-metadata" target="_blank" rel="noreferrer noopener">海王星</a>了。你可以找到那个特定的<a href="https://web.archive.org/web/20221206032313/https://app.neptune.ai/aravindcr/KnowledgeGraphs/e/KNOW-9/all?path=graphs" target="_blank" rel="noreferrer noopener">路径</a>。根据获得的输出，将您的图像记录到不同的路径。</p>



<pre class="hljs">run[<span class="hljs-string">'graphs/all_in_graph'</span>].upload(<span class="hljs-string">'graph.png'</span>)
run[<span class="hljs-string">'graphs/filtered_relations'</span>].upload(<span class="hljs-string">'info.png'</span>)
run[<span class="hljs-string">'graphs/filtered_relations2'</span>].upload(<span class="hljs-string">'links.png'</span>)</pre>



<p>所有的图表都可以在这里找到<a href="https://web.archive.org/web/20221206032313/https://app.neptune.ai/aravindcr/KnowledgeGraphs/e/KNOW-9/all?path=graphs" target="_blank" rel="noreferrer noopener">。</a></p>



<h2 id="h-coreference-resolution">共指消解</h2>



<p>要获得更精确的图形，还可以使用共指解析。</p>



<p>共指消解是内视感知的NLP等价物，用于信息检索系统、对话代理和虚拟助手，如Alexa。这是一项对文本中提及相同潜在实体的内容进行聚类的任务。</p>





<p><strong> <em>【我】【我的】</em> </strong> <strong>，和</strong> <strong> <em>【她】</em> </strong> <strong>属于同一个集群，和</strong> <strong> <em>【乔】</em> </strong> <strong>和</strong> <strong> <em>【他】</em> </strong> <strong>属于同一个集群。</strong></p>



<p>解决共同引用的算法通常寻找与引用表达式兼容的最近的前面提及。也可以训练神经网络，而不是使用基于规则的依存解析树，神经网络将单词嵌入和提及之间的距离作为特征来考虑。</p>



<p>通过规范化文本、删除冗余和指定实体代词，这显著改进了实体对提取。</p>



<p>如果您的用例是特定于领域的，那么训练一个<a href="https://web.archive.org/web/20221206032313/https://spacy.io/usage/training#ner" target="_blank" rel="noreferrer noopener nofollow">定制实体识别模型</a>是值得的。</p>



<p>知识图表可以自动构建并探索，以揭示关于该领域的新见解。</p>



<p>笔记本上传到<a href="https://web.archive.org/web/20221206032313/https://app.neptune.ai/aravindcr/KnowledgeGraphs/n/00f8da9b-76d9-4740-a06f-30b8356eea32/35fe83d7-323b-4f6e-bfe3-eb994d9f8ca2" target="_blank" rel="noreferrer noopener">海王星</a>。</p>



<p><a href="https://web.archive.org/web/20221206032313/https://github.com/AravindR7/Web_Scraping_Knowledge_Graphs/blob/main/Web_Scraping_Knowledge_Graphs_ML.ipynb" target="_blank" rel="noreferrer noopener nofollow"> GitHub </a>上的笔记本。</p>



<h2 id="h-knowledge-graphs-at-scale">大规模知识图表</h2>



<p>为了有效地将1749页的整个语料库用于我们的主题，使用在<strong> <em> wiki_scrape </em> </strong>函数中创建的列来为每个节点添加属性。然后你可以跟踪每个节点的页面和类别。您可以使用多重和并行处理来减少执行时间。</p>



<p>kg的一些使用案例包括:</p>







<h2 id="h-challenges-ahead">未来的挑战</h2>



<h3>实体歧义消除和身份管理</h3>



<p>在其最简单的形式中，挑战是为一个实体的发言或提及分配一个唯一的规范化身份和类型。</p>



<p>自动提取的很多实体都有非常相似的表面形态，比如同名或相近的人，或者同名或相近的电影、歌曲、书籍。两个名称相似的产品可能指的是不同的列表。没有正确的链接和歧义消除，实体将与错误的事实不正确地关联，并导致下游不正确的推理。</p>



<h3>类型成员和解析</h3>



<p>今天，大多数知识图系统允许每个实体有多种类型，不同的环境有不同的类型。古巴可以是一个国家，也可以指古巴政府。在某些情况下，知识图系统将类型分配推迟到运行时。每个实体描述其属性，应用程序根据用户任务使用特定的类型和属性集合。</p>







<h3>管理不断变化的知识</h3>



<p>一个有效的实体链接系统需要基于其不断变化的输入数据有机地增长。例如，公司可能会合并或拆分，新的科学发现可能会将单个现有实体拆分为多个实体。</p>



<p>当一家公司收购另一家公司时，收购公司是否会改变身份？身份是随着姓名权的获得而产生的吗？例如，在医疗保健行业构建的kg的情况下，患者数据会随着时间的推移而改变。</p>



<h3>从多个结构化和非结构化来源中提取知识</h3>



<p>结构化知识(包括实体、它们的类型、属性和关系)的提取仍然是一个全面的挑战。大规模增长的图表需要手动方法以及从开放领域的非结构化数据中进行无监督和半监督的知识提取。</p>



<h3>管理大规模运营</h3>



<p>管理规模是直接影响与性能和工作负载相关的几项运营的根本挑战。它还会影响其他操作，例如管理大规模知识图的快速增量更新，从而间接证明自己。</p>



<p><em>注:有关不同科技巨头如何在其产品和相关挑战中实施<a href="https://web.archive.org/web/20221206032313/https://queue.acm.org/detail.cfm?id=3332266" target="_blank" rel="noreferrer noopener nofollow">行业规模知识图的更多细节，请查看本文</a>。</em></p>



<h2 id="h-natural-language-processing">自然语言处理</h2>



<p>自然语言处理(Natural Language Processing)是计算机科学的一个分支，旨在让计算机能够处理和理解人类语言。从技术上来说，NLP的主要<strong>任务将是给计算机编程，以分析和处理大量的自然语言数据</strong>。</p>



<p>各种学科都学习语言。每个学科都有自己的问题和解决问题的方法。</p>



<h3>语言中的歧义</h3>



<p><strong>NLP中使用的歧义</strong>可以指的是以一种以上的方式被理解的<strong>能力</strong>。自然语言是模糊的。NLP有以下模糊之处:</p>



<ul>
<li><strong>词汇歧义</strong>是单个单词的歧义。例如，单词<strong> well </strong>可以是副词、名词或动词。</li>



<li><strong>句法歧义</strong>是在一个句子或单词序列中存在两种或两种以上可能的意思。例如“鸡肉可以食用了”。这句话要么表示鸡已经熟了，现在可以吃了，要么表示鸡已经可以喂了。</li>



<li><strong>回指歧义</strong>是指在文本中向后指称(或另一个语境中的实体)。一个短语或单词指的是前面提到的东西，但是有不止一种可能性。例如，“玛格丽特邀请苏珊来访，她给了她一顿美餐。”(她=玛格丽特；她=苏珊)。“玛格丽特邀请苏珊来访，但她告诉她她必须去工作”(她=苏珊；她=玛格丽特。)</li>



<li><strong>语用歧义</strong>可以定义为有多种解释的词语。当一个句子中的词语意义不明确时，就会产生语用歧义；它以不同的意义结束。</li>
</ul>



<h3>自然语言处理中的文本相似性度量</h3>



<p>文本相似性用于确定两个文本文档在上下文或含义方面有多相似。有各种相似性度量，例如:</p>



<ul>
<li><strong>余弦相似度，</strong></li>



<li><strong>欧几里德距离，</strong></li>



<li><strong> Jaccard相似度。</strong></li>
</ul>



<p>所有这些指标都有自己的规格来衡量两个查询之间的相似性。</p>



<h4>余弦相似性</h4>



<p><a href="https://web.archive.org/web/20221206032313/https://en.wikipedia.org/wiki/Cosine_similarity" target="_blank" rel="noreferrer noopener nofollow">余弦相似度</a>是在NLP中测量两个文档之间的文本相似度的度量，不管它们的大小如何。<strong>一个词用向量的形式来表示。文本文档用n维向量空间表示。</strong></p>



<p>余弦相似性度量两个n维向量在多维空间中投影的夹角余弦。两个文档的余弦相似度将从<strong> 0到1 </strong>的范围<strong>变化</strong>。如果余弦相似性得分是1，这意味着2个向量具有相同的方向。越接近0的值表示2个文档的相似度越低。</p>



<p><strong> <em> </em> </strong>两个非零向量的余弦相似度的数学方程为:</p>





<p>余弦相似度是比<a href="https://web.archive.org/web/20221206032313/https://en.wikipedia.org/wiki/Euclidean_distance#:~:text=In%20mathematics%2C%20the%20Euclidean%20distance,being%20called%20the%20Pythagorean%20distance." target="_blank" rel="noreferrer noopener nofollow"> <strong>欧几里德距离</strong> </a>更好的度量，因为如果两个文本文档相距欧几里德距离很远，它们在上下文方面仍然有可能彼此接近。</p>



<h4>雅克卡相似性</h4>



<p>Jaccard相似性也称为Jaccard指数和Union上的交集。</p>



<p><a href="https://web.archive.org/web/20221206032313/https://en.wikipedia.org/wiki/Jaccard_index" target="_blank" rel="noreferrer noopener nofollow"> Jaccard相似度</a>用于确定两个文本文档之间的相似度，即<strong>所有单词中存在多少个常用单词。</strong></p>



<p>Jaccard相似性被定义为两个文档的交集除以两个文档的并集，这两个文档是指总单词数中的共同单词数。</p>



<p>Jaccard相似性的数学表示为:</p>





<p>Jaccard相似性得分在<strong> 0到1 </strong>的<strong>范围</strong>内。如果两个文档相同，Jaccard相似度为1。如果两个文档之间没有共同的单词，则Jaccard相似性得分为零。</p>



<h4>Python代码查找Jaccard相似性</h4>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jaccard_similarity</span><span class="hljs-params">(doc1, doc2)</span>:</span>

 
 words_doc1 = set(doc1.lower().split())
 words_doc2 = set(doc2.lower().split())

 
 intersection = words_doc1.intersection(words_doc2)

 
 union = words_doc1.union(words_doc2)

 
 
 <span class="hljs-keyword">return</span> float(len(intersection)) / len(union)</pre>



<pre class="hljs">docu_1 = <span class="hljs-string">"Work from home is the new normal in digital world"</span>
docu_2 = <span class="hljs-string">"Work from home is normal"</span>

jaccard_similarity(docu_1, docu_2)</pre>



<p><strong>输出:0.5 </strong></p>



<p><strong> doc_1 </strong>和<strong> doc_2 </strong>之间的Jaccard相似度为<strong> 0.5 </strong></p>



<p><strong>以上三种方法都有一个相同的假设:</strong>文档(或句子)如果有常用词就是相似的。这个想法很直白。它适合一些基本情况，如比较前两个句子。</p>



<p>然而，通过比较第一个和第三个句子(例如，尝试使用传达相同意思的不同句子，并使用上面的Python函数来比较相似性)，分数可以相对较低，即使两者描述了相同的新闻。</p>



<p>另一个<strong>限制是上述方法不处理同义词</strong>。例如,“buy”和“purchase”应该有相同的意思(在某些情况下),但是上述方法会对这两个词进行不同的处理。</p>



<p>那么解决方法是什么呢？你可以使用单词嵌入(Word2vec，GloVe，FastText)。</p>



<p>对于NLP的一些基本概念和用例，我将附上一些我在Medium上写的文章，以及一篇在<a href="/web/20221206032313/https://neptune.ai/blog" target="_blank" rel="noreferrer noopener"> Neptune的博客</a>上写的文章，以供参考:</p>







<h2 id="h-conclusion">结论</h2>



<p>我希望你在这里学到了一些新的东西，这篇文章帮助你理解了web抓取、知识图和一些有用的NLP概念。</p>



<p>感谢阅读，继续学习！</p>



<p><strong>参考文献:</strong></p>




        </div>
        
    </div>    
</body>
</html>