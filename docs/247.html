<html>
<head>
<title>Lossless Data Compression Using Arithmetic Encoding in Python and Its Applications in Deep Learning </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python算术编码无损数据压缩及其在深度学习中的应用</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/lossless-data-compression-using-arithmetic-encoding-in-python-and-its-applications-in-deep-learning#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/lossless-data-compression-using-arithmetic-encoding-in-python-and-its-applications-in-deep-learning#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p>数据<a href="https://web.archive.org/web/20221206010842/https://dzone.com/articles/crunch-time-10-best-compression-algorithms" target="_blank" rel="noreferrer noopener nofollow">压缩算法</a>使用比原始表示更少的比特数来表示长的符号序列。数据压缩算法有两类:<a href="https://web.archive.org/web/20221206010842/http://sun.aei.polsl.pl/~sdeor/pub/deo03.pdf" target="_blank" rel="noreferrer noopener nofollow">有损和无损</a>。</p>



<p>在本教程中，我们将讨论一种称为算术编码(AE)的无损算法。您将通过一个展示消息编码和解码步骤的示例来了解AE是如何工作的。</p>



<p>我们还将构建一个可以编码和解码文本消息的Python实现。这个GitHub项目的实现是可用的。</p>



<p>以下是我们将在本教程中涉及的所有内容:</p>



<ul><li>算术编码概述</li><li>频率和概率表</li><li>编码</li><li>解码</li><li>十进制模块</li><li>Python实现</li><li>无损压缩在深度学习中的应用</li></ul>



<p>开始吧！</p>



<p id="separator-block_5fca7344d7e18" class="block-separator block-separator--5">无损算法概述(算术编码)</p>



<h2 id="h-overview-of-the-lossless-algorithm-arithmetic-encoding">在数据压缩中，有损算法在压缩数据的同时会丢失一些细节。它们减少了用于表示消息的位数，即使这会降低重建数据的质量。</h2>



<p>无损算法无损重建原始数据。因此，与有损算法相比，它们使用的位数更多。</p>



<p><a href="https://web.archive.org/web/20221206010842/https://www.cs.cmu.edu/~aarti/Class/10704/Intro_Arith_coding.pdf" target="_blank" rel="noreferrer noopener nofollow">算术编码</a> (AE)是一种无损算法，使用少量比特来压缩数据。</p>



<p>这是一种基于熵的算法，在1987年的一篇论文中首次提出(威滕、伊恩·h、拉德福德·m·尼尔和约翰·g·克利里。"用于数据压缩的算术编码."<em>美国计算机学会的通讯</em> 30.6 (1987): 520-540)。</p>



<p>AE算法减少位数的一个原因是AE使用0.0到1.0之间的单个数字对整个消息进行编码。消息中的每个符号在0-1间隔中取一个子间隔，对应于它的概率。</p>



<p>为了计算每个符号的概率，应该给出一个频率表作为算法的输入。该表将每个字符映射到其频率。</p>



<p>符号越频繁，分配给它的比特数越少。结果，减少了表示整个消息的总位数。这与在<a href="https://web.archive.org/web/20221206010842/http://home.cse.ust.hk/faculty/golin/COMP271Sp03/Notes/MyL17.pdf" target="_blank" rel="noreferrer noopener nofollow">霍夫曼编码</a>中对消息中的所有符号使用固定数量的比特相比较。</p>



<p>频率表</p>



<p id="separator-block_5fca735fd7e19" class="block-separator block-separator--5">要使用AE对信息进行编码(=压缩)，您需要以下输入:</p>



<h2 id="h-frequency-table">要编码的消息。</h2>



<p>信息中所有可能符号的频率表。</p>



<ol><li>频率表通常通过分析不同的消息并根据每个符号重复的次数得出结论来计算。</li><li>例如:假设待编码的消息仅由3个符号<strong> a </strong>、<strong> b </strong>和<strong> c </strong>组成。通过分析一些以前的消息(例如babb、cbab和bb)，我们得到3个符号的频率:</li></ol>



<p>a=2</p>



<p>b=7</p>



<ol><li>c=1</li><li>根据频率表，如何使用AE对类似于<strong> abc </strong>的消息进行编码？在开始编码之前，你需要从频率表中计算出一个概率表。</li><li>概率表</li></ol>



<p>使用频率表，我们可以计算每个符号出现的概率。概率计算如下:</p>



<p id="separator-block_5fca7369d7e1a" class="block-separator block-separator--5">符号的频率/所有符号的频率之和</p>



<h2 id="h-probability-table">根据频率表，以下是我们3个符号的概率:</h2>



<p>p(a)=2/10=0.2</p>



<p>p(b)=7/10=0.7</p>



<p>p(c)=1/10=0.1</p>



<ol><li>给定消息和概率表，AE可以开始编码过程。</li><li>编码</li><li>AE中的编码工作原理是表示一条线上所有符号的累积概率，范围从0.0到1.0。在那一行，每个符号使用一个子范围。</li></ol>



<p>给定任何符号C，它从值开始，到使用以下公式计算的值结束:</p>



<p id="separator-block_5fca736fd7e1b" class="block-separator block-separator--5"><strong> <em> S+(P(C))*R </em> </strong></p>



<h2 id="h-encoding">其中:</h2>



<p>s:所有先前概率的累积和。</p>



<p>P(C):符号C的概率。</p>



<p class="has-text-align-center">r:线的范围，通过从线的末端减去起点来计算。</p>



<p>一开始，这条线从0.0开始，到1.0结束，因此R=1.0。</p>



<ul><li>让我们计算3个符号<strong> a </strong>、<strong> b </strong>、<strong> c </strong>的起始值和结束值。</li><li>对于第一个符号，<strong> a </strong>，从0.0开始到0.0+(0.2)*1.0=0.2。起始值为0.0，因为它是第一个符号。范围是(0.0:0.2)。</li><li>对于第二个符号，<strong> b </strong>，从0.2开始到0.2+(0.7)*1.0=0.9。范围是(0.2:0.9)。</li></ul>



<p>第三个符号，<strong> c，</strong>从0.9开始到0.9+(0.1)*1.0=1.0。范围是(0.9:1.0)。</p>



<p>给定所有符号的范围，最好用图形表示它们，如下图所示:</p>



<ol><li>以下是一些注意事项:</li><li>第一个符号从线的相同起点(0.0)开始，最后一个符号在线的终点(1.0)结束。</li><li>符号C覆盖了与其概率相对应的范围的百分比。例如，符号b覆盖了70%的线，因为它的概率是0.7。</li></ol>



<p> </p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/13bb53547086a1bca9ba6a13a45aeddf.png" alt="lossless data compression graph " class="wp-image-32553" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-1.jpg?ssl=1"/></figure>



<p><strong>限制间隔</strong></p>



<ol><li>AE的工作原理是限制行间隔，行间隔从0.0到1.0，通过一些等于消息中符号数的阶段。在这个例子中，消息中只有3个符号，所以只有3个阶段。</li><li>在每个阶段，根据当前符号的子间隔来限制线的间隔。</li></ol>



<p id="separator-block_5fca738ed7e1c" class="block-separator block-separator--5">处理完所有符号后，AE返回一个编码整个消息的单个double值。</p>



<h3>现在，是时候查看要编码的消息，<strong> abc </strong>，并处理第一个符号<strong> a </strong>以限制行间隔。基于上图，符号<strong> a </strong>覆盖了从0.0到0.2的区间。此间隔成为线条的间隔。换句话说，线间距从0.0:1.0变为0.0:0.2，如下图所示。注意，符号<strong> a </strong>从0.0开始，最后一个符号<strong>c</strong>结束于0.2。</h3>



<p>为了计算每个符号的间隔，我们将使用已经提到的公式:</p>



<p><strong> <em> S+(P(C))*R </em> </strong></p>



<p>因为线的范围变了，R变成0.2-0.0=0.2。让我们计算每个符号的起始值和结束值:</p>



<p>对于第一个符号，<strong> a </strong>，从0.0开始到0.0+(0.2)*0.2=0.04。起始值为0.0，因为它是第一个符号。范围是(0.0:0.04)。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/cd01611ef158488150ce09de00cfdb5e.png" alt="lossless data compression graph " class="wp-image-32555" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-2.jpg?ssl=1"/></figure>



<p>对于第二个符号<strong> b </strong>，从0.04开始到0.04+(0.7)*0.2=0.18。范围是(0.04:0.18)。</p>



<p class="has-text-align-center">第三个符号<strong> c </strong>从0.18开始到0.18+(0.1)*0.2=0.2。范围是(0.18:0.2)。</p>



<p>在第一阶段结束时，下图显示了每个符号间隔的起始值和结束值。</p>



<ol><li>请注意，每个符号都占据了等于其概率的线的一部分。例如，符号<strong> b </strong>的概率是0.7，因此它占据了线的间隔的70%。</li><li>下图总结了AE在这一点上的进展。让我们开始第二阶段，这只是重复我们在第一阶段所做的。</li><li>消息中的下一个符号是<strong> b </strong>。根据最新的行间隔(0.0到0.2)，符号<strong> b </strong>从0.04到0.18开始。在这个阶段，线的区间将进一步限制为b的区间，如下图所示:</li></ol>



<p>因为线的间隔变为(0.04:0.18)，所以R也改变。它的新值是0.18-0.04=0.14。让我们计算每个符号的起始值和结束值:</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/979910b8cf563781ce258b1e663815fa.png" alt="" class="wp-image-32556" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-3.jpg?ssl=1"/></figure>



<p>对于第一个符号，<strong> a </strong>，从0.04开始到0.04+(0.2)*0.14=0.068。范围是(0.04:0.068)。</p>



<p>对于第二个符号，<strong> b </strong>，从0.068开始到0.068+(0.7)*0.14=0.166。范围是(0.068:0.166)。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/df39aa9a746b9ee862b9141539cd7ced.png" alt="" class="wp-image-32557" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-4.jpg?ssl=1"/></figure>



<p>第三个符号，<strong> c，</strong>从0.166开始到0.166+(0.1)*0.14=0.18。范围是(0.166:0.18)。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/b55a930bd3637063edf46a87d957e283.png" alt="" class="wp-image-32558" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-5.jpg?ssl=1"/></figure>



<p>下图总结了3个符号的间隔。这标志着第二阶段的结束。</p>



<ol><li>为了总结到目前为止所取得的进展，下图连接了两个完成的阶段。让我们进入第三阶段。</li><li>消息中的第三个也是最后一个符号是<strong> c </strong>。根据最新阶段，该符号落在从<strong> 0.166 </strong>开始到<strong> 0.18 </strong>结束的范围内。<strong> c </strong>根据下一个数字，当前间隔将是生产线的下一个间隔。这条新线的r为0.18-0.166=0.014。</li><li>在那一行，类似于前两个阶段，这是3个符号的间隔:</li></ol>



<p>符号<strong> a </strong>从0.166开始到0.166+(0.2)*0.014=0.1688。范围是(0.166 :0.1688)。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/2bdaacd47b7ea7b66806efed5cd3446a.png" alt="" class="wp-image-32559" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-6.jpg?ssl=1"/></figure>



<p>符号<strong> b </strong>从0.1688开始到0.1688+(0.7)*0.014=0.1786。范围是(0.1688 :0.1786)。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/7e44d0b72a62edee7b0cbf85e2f13276.png" alt="" class="wp-image-32560" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-7.jpg?ssl=1"/></figure>



<p>符号<strong> c </strong>从0.1786开始到0.1786+(0.1)*0.014=0.18。范围是(0.1786:0.18)。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/31f6cdd15ebe4cc565e8282abd11f6da.png" alt="" class="wp-image-32561" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-8.jpg?ssl=1"/></figure>



<p>间隔反映在下图中。</p>



<ol><li>消息中没有更多符号。下图总结了从初始间隔(0.0:1.0)到最后一个间隔(0.166:0.18)的计算。</li><li>假设AE完成了编码过程，那么下一小节将计算对整个消息进行编码的单个数字。</li><li> </li></ol>



<p><strong>单值编码报文</strong></p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/5513b912795b8ea33604b2ebe2a3ffe7.png" alt="" class="wp-image-32562" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-9.jpg?ssl=1"/></figure>



<p>AE达到的最新区间从0.166开始到0.18。在此范围内，任何值都可以用来编码整个消息。例如，该值可以是<strong> 0.17 </strong>。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/a5675fb4b95629343957c95f28745258.png" alt="" class="wp-image-32563" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-10.jpg?ssl=1"/></figure>



<p>在本教程中，该值是间隔的平均值，即:</p>



<p id="separator-block_5fca73a3d7e1d" class="block-separator block-separator--5"><strong><em>(0.166+0.18)/2 = 0.173</em></strong></p>



<h3>因此，基于所使用的频率表，消息<strong> abc </strong>被编码为值<strong> 0.173 </strong>。当频率表改变时，对消息进行编码的值也会改变。</h3>



<p>这标志着编码过程的结束。现在我们来讨论解码过程。</p>



<p>解码</p>



<p class="has-text-align-center">解码的输入有:</p>



<p>对消息进行编码的单个值。</p>



<p>频率表。它应该与用于编码的相同。</p>



<p id="separator-block_5fca73c5d7e1e" class="block-separator block-separator--5">原始消息中的符号数。</p>



<h2 id="h-decoding">在我们的例子中，编码消息的值是<strong> 0.173 </strong>。频率表为<strong>【a = 2，b=7，c = 1】</strong>。消息中的符号数是3。</h2>



<p>解码的第一步是根据频率计算符号的概率，类似于我们之前所做的。</p>



<ol><li>概率表为<strong>【p(a)= 0.2，p(b)=0.7，p(c)= 0.1】</strong>。基于概率表，通过构造相同的间隔，解码过程类似于编码。</li><li>首先，根据下图创建一条从0.0开始到1.0结束的线。使用用于编码消息的相同等式来计算3个符号的间隔。</li><li><strong> <em> S+(P(C))*R </em> </strong></li></ol>



<p>值<strong> 0.173 </strong>落在第一个区间内(0.0:0.2)。因此，编码消息中的第一个符号是<strong> a </strong>。因此，线的间隔被限制为从0.0到0.2开始的间隔。</p>



<p>值<strong> 0.173 </strong>落在第二个区间内(0.04:0.18)。因此，编码消息中的第二个符号是<strong> b </strong>。在下图中，间隔将被限制在0.04到0.18之间。</p>



<p>值<strong> 0.173 </strong>落在第三个区间(0.166:0.18)内。这就是为什么消息中的下一个符号是<strong> c </strong>的原因。</p>



<p>记住原始消息中的符号数是<strong> 3 </strong>。解码3个符号后，解码过程完成。解码后的消息是<strong> abc </strong>。</p>



<p class="has-text-align-center">让我们看另一个例子。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/6e5eeecb2b9f93c6b50b3a3f636cd105.png" alt="" class="wp-image-32564" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-11.jpg?ssl=1"/></figure>



<p>实施例2</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/917401691940cf641d7333a522f44e23.png" alt="" class="wp-image-32565" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-12.jpg?ssl=1"/></figure>



<p>在这个例子中，我不会像以前那样详述步骤。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/1fe67367875aeaeefc9bf8d768ba64f6.png" alt="" class="wp-image-32566" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-13.jpg?ssl=1"/></figure>



<p>有4个符号可用于构建消息—<strong>a</strong>、<strong> b </strong>、<strong> c </strong>和<strong> d </strong>。这些符号的频率是:</p>



<p>a=2</p>



<p>b=3</p>



<p id="separator-block_5fca73d4d7e1f" class="block-separator block-separator--5">c=1</p>



<h2 id="h-example-2">d=4</h2>



<p>根据频率表，符号的概率如下:</p>



<p>p(a)=2/10=0.2</p>



<ol><li>p(b)=3/10=0.3</li><li>p(c)=1/10=0.1</li><li>p(d)=4/10=0.4</li><li>下图显示了符号的累积概率，其中每个符号的间隔等于其概率。</li></ol>



<p>现在，该对消息进行编码了，即<strong> bdab </strong>。</p>



<ol><li>在第一阶段，该消息中的第一个符号<strong> b </strong>被处理。间隔将被限制为从0.2到0.5开始的<strong> b </strong>的间隔。</li><li>在第二阶段，消息中的下一个符号是<strong> d </strong>。如下图所示，线的间隔将被限制为从0.38到0.5开始的<strong> d </strong>的间隔。</li><li>因为消息中的下一个符号是<strong> a </strong>，所以第三阶段的间隔被限制为从0.38开始，到0.404结束。</li><li>在第四个也是最后一个阶段，下一个符号是<strong> b </strong>，所以间隔被限制在0.3848到0.392之间。</li></ol>



<p>最后一个阶段结束时，区间从0.3848到0.392。为了对整个消息进行编码，可以使用间隔内的任何值。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/1f9e594dcd85305402bf060cdefe97b9.png" alt="" class="wp-image-32567" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-14.jpg?ssl=1"/></figure>



<p>本例中使用平均值，即0.3884。这标志着编码过程的结束。</p>



<p><em><strong>(0.3848+0.392)/2 = 0.3884</strong>T3】</em></p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/4a0f3ca5e6cf56aa399ad652971e0044.png" alt="" class="wp-image-32568" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-15.jpg?ssl=1"/></figure>



<p>给定以下3个输入，解码过程开始:</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/b98900acbe9de384f1188a1975459cd5.png" alt="" class="wp-image-32569" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-16.jpg?ssl=1"/></figure>



<p>对消息编码的值，<strong> 0.3884 </strong>。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/630c6507323646f651b258a6d28968fa.png" alt="" class="wp-image-32570" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-17.jpg?ssl=1"/></figure>



<p>频率表。</p>



<figure class="wp-block-image size-large"><img decoding="async" src="../Images/44758ae2a2173beed7df09900973b5e1.png" alt="" class="wp-image-32571" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206010842im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/lossless-data-compression-graph-18.jpg?ssl=1"/></figure>



<p>消息的长度，<strong> 4 </strong>。</p>



<p>解码器从准备概率表开始，类似于编码器。请注意，解码器构建了与上图相同的图形。</p>



<p class="has-text-align-center">解码过程是这样的:</p>



<p>通过检查从0.0到1.0的初始区间，值<strong> 0.3884 </strong>落在符号<strong> b </strong>的区间内。因此，消息中的第一个符号是<strong> b </strong>。</p>



<ol><li>在从0.2到0.5开始的下一个区间中，值<strong> 0.3884 </strong>落在从0.38到0.5开始的<strong> d </strong>的区间内。因此，第二个符号是<strong> d </strong>。</li><li>下一个区间被限制为值<strong> 0.3884 </strong>落在符号<strong> a </strong>的区间内的<strong> d </strong>的区间。因此，第三个符号是<strong> a </strong>。</li><li>在下一个间隔中，值<strong> 0.3884 </strong>落在符号<strong> b </strong>的间隔内，因此消息中的第四个也是最后一个符号是<strong> b </strong>。</li></ol>



<p>经过一些等于消息长度的阶段，即<strong> 4 </strong>，解码后的消息为<strong> bdab </strong>。</p>



<p>至此，算术编码背后的理论已经很清楚了。我们准备用Python实现这个算法。</p>



<ol><li>在开始之前，我们将讨论一个称为decimal的重要模块，它对于成功实现AE算法至关重要。</li><li> </li><li><strong>十进制模块</strong></li><li>AE技术将整个消息(无论其长度如何)编码成一个浮点数。</li></ol>



<p>在Python中，float数据类型被限制为有限数量的十进制数字。Python float不能精确地保存超过这个十进制位数的数字。使用structseq sys.float_info中的dig属性返回精确的位数，如下一个代码(<a href="https://web.archive.org/web/20221206010842/https://docs.python.org/2/library/sys.html#sys.float_info" target="_blank" rel="noreferrer noopener nofollow">文档参考</a>)所示。</p>



<p>例如，当创建一个值为123456789.12345678998的浮点变量时，实际存储的值是123456789.12345679，与原始值不同。</p>



<p>在AE中，这是一场灾难，因为每个数字都有所不同。为了让AE使用float类型，消息必须限制为几个符号。</p>



<p id="separator-block_5fca73f1d7e20" class="block-separator block-separator--5">在Python中，有一个称为decimal的模块，它使用用户定义的精度。您可以存储任意位数的数字(<a href="https://web.archive.org/web/20221206010842/https://docs.python.org/3/library/decimal.html" target="_blank" rel="noreferrer noopener nofollow">文档参考</a>)。</p>



<h2 id="h-decimal-module">小数值的默认精度是28，由getcontext()返回。prec属性。</h2>



<p>如果要存储的数字超过精度28，则该精度可以改变。下一行将精度设置为1500。</p>



<p>根据<a href="https://web.archive.org/web/20221206010842/https://docs.python.org/3/library/decimal.html#decimal.MAX_PREC" target="_blank" rel="noreferrer noopener nofollow">本页</a>，32位系统的最大精度为425000000。对于64位系统，它是99999999999999999。这足以编码巨大的信息。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> sys

print(sys.float_info.dig)</pre>



<p>下一小节创建一个十进制值。</p>



<pre class="hljs">print(float(<span class="hljs-number">123456789.12345678998</span>))</pre>



<p> </p>



<p><strong>创建一个小数值</strong></p>



<p>decimal模块有一个名为Decimal的类，它创建十进制值。下面是一个例子。这样，可以创建任意精度的数。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> getcontext

getcontext().prec 
</pre>



<p>请注意，精度只在进行算术运算时才重要。即使创建的十进制值的精度超过getcontext()中指定的精度。prec，十进制值将不受该精度的限制。只有在做算术运算的时候才会受到限制。</p>



<pre class="hljs">getcontext().prec = <span class="hljs-number">1500</span>
</pre>



<p>在接下来的代码中，我们创建了一个存储大数的十进制值。打印时，将返回该值，不会丢失任何数字。</p>



<pre class="hljs">print(decimal.MAX_PREC)
</pre>



<p>当应用算术运算时，比如在数字上加1，getcontext()中的精度。prec属性将生效，以限制小数位数。下一个代码的结果将是1234567910432815552，其中末尾的一些数字被剪裁。</p>



<p id="separator-block_5fca7449d7e21" class="block-separator block-separator--5">要解决此问题，您应该提高精度。</p>



<h3> </h3>



<p><strong>改变精度</strong></p>



<pre class="hljs"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal

a = Decimal(<span class="hljs-number">1.5</span>)
</pre>



<p>decimal模块允许您通过为get context()prec设置一个大于缺省值28的值来提高精度。在将精度设置为40之后，下一个代码的结果是12345679104328155517578125，其中没有剪裁的数字。</p>



<p>现在让我们构建算术编码算法的Python实现。</p>



<pre class="hljs">a = Decimal(‘<span class="hljs-number">123456789.12345679104328155517578125</span>’)</pre>



<p>Python实现</p>



<pre class="hljs">b = a + <span class="hljs-number">1</span>
print(b) 
</pre>



<p>我们将AE的实现构建为一个名为ArithmeticEncoding的类，位于一个名为pyae.py的模块中。</p>



<p id="separator-block_5fca744fd7e22" class="block-separator block-separator--5">传递给该方法的频率表是一个字典，其中每一项都有一个表示符号的字符串键和一个表示频率的整数值。这里有一个例子:</p>



<h3>构造函数调用一个名为get_probability_table()的方法。它接受频率表并返回存储在probability_table实例属性中的概率表。</h3>



<p>下面是get_probability_table方法的实现。它只是将每个符号的频率除以表中所有频率的总和。</p>



<pre class="hljs">getcontext().prec = <span class="hljs-number">40</span>

a = Decimal(<span class="hljs-string">'123456789.12345679104328155517578125'</span>)
b = a + <span class="hljs-number">1</span>
print(b) 
</pre>



<p>返回的概率表是一个类似于用于频率的字典。这是之前频率表的概率表。</p>



<p id="separator-block_5fca7458d7e23" class="block-separator block-separator--5"><strong>编码器</strong></p>



<h2 id="h-python-implementation">ArithmeticEncoding类有一个名为encode()的方法对消息进行编码。它接受两个参数:</h2>



<p>msg:要编码的消息。</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, frequency_table)</span>:</span>
    self.probability_table = self.get_probability_table(frequency_table)
</pre>



<p>概率表:概率表。</p>



<pre class="hljs">{<span class="hljs-string">"a"</span>: <span class="hljs-number">2</span>,
 <span class="hljs-string">"b"</span>: <span class="hljs-number">3</span>,
 <span class="hljs-string">"c"</span>: <span class="hljs-number">1</span>,
 <span class="hljs-string">"d"</span>: <span class="hljs-number">4</span>}
</pre>



<p>下面是encode()方法的实现。它有一个迭代次数等于消息长度的循环。</p>



<p>在每次迭代中，使用process_stage()方法在一个阶段中处理消息的一个符号。该方法简单地接受概率表和当前间隔，并返回当前阶段内每个符号的间隔的字典。</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_probability_table</span><span class="hljs-params">(self, frequency_table)</span>:</span>
    total_frequency = sum(list(frequency_table.values()))

    probability_table = {}
    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> frequency_table.items():
        probability_table[key] = value/total_frequency

    <span class="hljs-keyword">return</span> probability_table</pre>



<p>这是第一次迭代后返回的字典。这个字典被附加到一个名为encoder的列表中，该列表保存了所有阶段的间隔。</p>



<pre class="hljs">{<span class="hljs-string">'a'</span>: <span class="hljs-number">0.2</span>,
 <span class="hljs-string">'b'</span>: <span class="hljs-number">0.3</span>,
 <span class="hljs-string">'c'</span>: <span class="hljs-number">0.1</span>,
 <span class="hljs-string">'d'</span>: <span class="hljs-number">0.4</span>}
</pre>



<p id="separator-block_5fca7463d7e24" class="block-separator block-separator--5">根据消息中的下一个符号和process_stage方法返回的结果，确定新的间隔。</p>



<h3>处理完所有阶段后，调用get_encoded_value()方法。它返回对整个消息进行编码的值。该值是上一阶段间隔的平均值。</h3>



<p>在本例中，该值为0.3884。除了编码器列表之外，编码器还返回这个值。当消息是bdab时，下面是编码器列表。列表中的每一项都是代表一个阶段的字典。每个字典保存每个符号的音程。</p>



<ol><li><strong>解码器</strong></li><li>解码器是使用下面列出的decode()方法在ArithmeticEncoding类中实现的。它接受以下三个参数:</li></ol>



<p>encoded_msg:编码消息的值。</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span><span class="hljs-params">(self, msg, probability_table)</span>:</span>
    encoder = []

    stage_min = Decimal(<span class="hljs-number">0.0</span>)
    stage_max = Decimal(<span class="hljs-number">1.0</span>)

    <span class="hljs-keyword">for</span> msg_term_idx <span class="hljs-keyword">in</span> range(len(msg)):
        stage_probs = self.process_stage(probability_table, stage_min, stage_max)

        msg_term = msg[msg_term_idx]
        stage_min = stage_probs[msg_term][<span class="hljs-number">0</span>]
        stage_max = stage_probs[msg_term][<span class="hljs-number">1</span>]

        encoder.append(stage_probs)

    stage_probs = self.process_stage(probability_table, stage_min, stage_max)
    encoder.append(stage_probs)

    encoded_msg = self.get_encoded_value(encoder)

    <span class="hljs-keyword">return</span> encoder, encoded_msg</pre>



<p>msg_length:原始消息长度。</p>



<p>概率表:编码过程中使用的概率表。</p>



<pre class="hljs">{
    <span class="hljs-string">'a'</span>: [Decimal(<span class="hljs-string">'0.0'</span>), Decimal(<span class="hljs-string">'0.2'</span>)],
    <span class="hljs-string">'b'</span>: [Decimal(<span class="hljs-string">'0.2'</span>), Decimal(<span class="hljs-string">'0.5'</span>)],
    <span class="hljs-string">'c'</span>: [Decimal(<span class="hljs-string">'0.5'</span>), Decimal(<span class="hljs-string">'0.6'</span>)],
    <span class="hljs-string">'d'</span>: [Decimal(<span class="hljs-string">'0.6'</span>), Decimal(<span class="hljs-string">'1.0'</span>)]
}</pre>



<p>它的工作方式类似于encode()消息，因为它会遍历一些等于消息长度的迭代。</p>



<p>通过每次迭代，调用process_stage()方法来查找每个符号的间隔。对这些间隔进行检查，以找到限制消息编码值的间隔。</p>



<p>一旦定位到间隔，其对应的符号就是原始消息中的下一个。</p>



<pre class="hljs">[
 {<span class="hljs-string">'a'</span>: [Decimal(<span class="hljs-string">'0'</span>),
        Decimal(<span class="hljs-string">'0.2'</span>)],
  <span class="hljs-string">'b'</span>: [Decimal(<span class="hljs-string">'0.2'</span>),
        Decimal(<span class="hljs-string">'0.5'</span>)],
  <span class="hljs-string">'c'</span>: [Decimal(<span class="hljs-string">'0.5'</span>),
        Decimal(<span class="hljs-string">'0.6'</span>)],
  <span class="hljs-string">'d'</span>: [Decimal(<span class="hljs-string">'0.6'</span>),
        Decimal(<span class="hljs-string">'1.0'</span>)]},

 {<span class="hljs-string">'a'</span>: [Decimal(<span class="hljs-string">'0.2'</span>),
        Decimal(<span class="hljs-string">'0.26'</span>)],
  <span class="hljs-string">'b'</span>: [Decimal(<span class="hljs-string">'0.26'</span>),
        Decimal(<span class="hljs-string">'0.35'</span>)],
  <span class="hljs-string">'c'</span>: [Decimal(<span class="hljs-string">'0.35'</span>),
        Decimal(<span class="hljs-string">'0.38'</span>)],
  <span class="hljs-string">'d'</span>: [Decimal(<span class="hljs-string">'0.38'</span>),
        Decimal(<span class="hljs-string">'0.5'</span>)]},

 {<span class="hljs-string">'a'</span>: [Decimal(<span class="hljs-string">'0.38'</span>),
        Decimal(<span class="hljs-string">'0.404'</span>)],
  <span class="hljs-string">'b'</span>: [Decimal(<span class="hljs-string">'0.404'</span>),
        Decimal(<span class="hljs-string">'0.44'</span>)],
  <span class="hljs-string">'c'</span>: [Decimal(<span class="hljs-string">'0.44'</span>),
        Decimal(<span class="hljs-string">'0.452'</span>)],
  <span class="hljs-string">'d'</span>: [Decimal(<span class="hljs-string">'0.452'</span>),
        Decimal(<span class="hljs-string">'0.5'</span>)]},

 {<span class="hljs-string">'a'</span>: [Decimal(<span class="hljs-string">'0.38'</span>),
        Decimal(<span class="hljs-string">'0.3848'</span>)],
  <span class="hljs-string">'b'</span>: [Decimal(<span class="hljs-string">'0.3848'</span>),
        Decimal(<span class="hljs-string">'0.392'</span>)],
  <span class="hljs-string">'c'</span>: [Decimal(<span class="hljs-string">'0.392'</span>),
        Decimal(<span class="hljs-string">'0.3944'</span>)],
  <span class="hljs-string">'d'</span>: [Decimal(<span class="hljs-string">'0.3944'</span>),
        Decimal(<span class="hljs-string">'0.404'</span>)]},

 {<span class="hljs-string">'a'</span>: [Decimal(<span class="hljs-string">'0.3848'</span>),
        Decimal(<span class="hljs-string">'0.38624'</span>)],
  <span class="hljs-string">'b'</span>: [Decimal(<span class="hljs-string">'0.38624'</span>),
        Decimal(<span class="hljs-string">'0.3884'</span>)],
  <span class="hljs-string">'c'</span>: [Decimal(<span class="hljs-string">'0.3884'</span>),
        Decimal(<span class="hljs-string">'0.38912'</span>)],
  <span class="hljs-string">'d'</span>: [Decimal(<span class="hljs-string">'0.38912'</span>),
        Decimal(<span class="hljs-string">'0.392'</span>)]}
]</pre>



<p id="separator-block_5fca746ad7e25" class="block-separator block-separator--5">一旦找到等于消息长度的多个符号，解码过程结束。</p>



<h3><strong>完整代码</strong></h3>



<p>pyae.py模块的完整代码如下所示。要获得最新的代码，请查看这个GitHub项目。</p>



<ol><li> </li><li><strong>使用pyae的例子。算术编码类</strong></li><li>使用pyae。算术编码类，请按照下列步骤操作:</li></ol>



<p>导入pyae</p>



<p>实例化算术编码类</p>



<p>准备一条信息</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span><span class="hljs-params">(self, encoded_msg, msg_length, probability_table)</span>:</span>
    decoder = []
    decoded_msg = <span class="hljs-string">""</span>

    stage_min = Decimal(<span class="hljs-number">0.0</span>)
    stage_max = Decimal(<span class="hljs-number">1.0</span>)

    <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> range(msg_length):
        stage_probs = self.process_stage(probability_table, stage_min, stage_max)

        <span class="hljs-keyword">for</span> msg_term, value <span class="hljs-keyword">in</span> stage_probs.items():
            <span class="hljs-keyword">if</span> encoded_msg &gt;= value[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> encoded_msg &lt;= value[<span class="hljs-number">1</span>]:
                <span class="hljs-keyword">break</span>

        decoded_msg = decoded_msg + msg_term
        stage_min = stage_probs[msg_term][<span class="hljs-number">0</span>]
        stage_max = stage_probs[msg_term][<span class="hljs-number">1</span>]

        decoder.append(stage_probs)

    stage_probs = self.process_stage(probability_table, stage_min, stage_max)
    decoder.append(stage_probs)

    <span class="hljs-keyword">return</span> decoder, decoded_msg</pre>



<p>对信息进行编码</p>



<h3>破译信息</h3>



<p>下面是使用frequency_table变量中给出的频率表对消息bdab进行编码的示例代码。</p>



<pre class="hljs"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArithmeticEncoding</span>:</span>
    <span class="hljs-string">"""
    ArithmeticEncoding is a class for building arithmetic encoding.
    """</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, frequency_table)</span>:</span>
        self.probability_table = self.get_probability_table(frequency_table)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_probability_table</span><span class="hljs-params">(self, frequency_table)</span>:</span>
        <span class="hljs-string">"""
        Calculates the probability table out of the frequency table.
        """</span>
        total_frequency = sum(list(frequency_table.values()))

        probability_table = {}
        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> frequency_table.items():
            probability_table[key] = value/total_frequency

        <span class="hljs-keyword">return</span> probability_table

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_encoded_value</span><span class="hljs-params">(self, encoder)</span>:</span>
        <span class="hljs-string">"""
        After encoding the entire message, this method returns the single value that represents the entire message.
        """</span>
        last_stage = list(encoder[<span class="hljs-number">-1</span>].values())
        last_stage_values = []
        <span class="hljs-keyword">for</span> sublist <span class="hljs-keyword">in</span> last_stage:
            <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> sublist:
                last_stage_values.append(element)

        last_stage_min = min(last_stage_values)
        last_stage_max = max(last_stage_values)

        <span class="hljs-keyword">return</span> (last_stage_min + last_stage_max)/<span class="hljs-number">2</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_stage</span><span class="hljs-params">(self, probability_table, stage_min, stage_max)</span>:</span>
        <span class="hljs-string">"""
        Processing a stage in the encoding/decoding process.
        """</span>
        stage_probs = {}
        stage_domain = stage_max - stage_min
        <span class="hljs-keyword">for</span> term_idx <span class="hljs-keyword">in</span> range(len(probability_table.items())):
            term = list(probability_table.keys())[term_idx]
            term_prob = Decimal(probability_table[term])
            cum_prob = term_prob * stage_domain + stage_min
            stage_probs[term] = [stage_min, cum_prob]
            stage_min = cum_prob
        <span class="hljs-keyword">return</span> stage_probs

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span><span class="hljs-params">(self, msg, probability_table)</span>:</span>
        <span class="hljs-string">"""
        Encodes a message.
        """</span>

        encoder = []

        stage_min = Decimal(<span class="hljs-number">0.0</span>)
        stage_max = Decimal(<span class="hljs-number">1.0</span>)

        <span class="hljs-keyword">for</span> msg_term_idx <span class="hljs-keyword">in</span> range(len(msg)):
            stage_probs = self.process_stage(probability_table, stage_min, stage_max)

            msg_term = msg[msg_term_idx]
            stage_min = stage_probs[msg_term][<span class="hljs-number">0</span>]
            stage_max = stage_probs[msg_term][<span class="hljs-number">1</span>]

            encoder.append(stage_probs)

        stage_probs = self.process_stage(probability_table, stage_min, stage_max)
        encoder.append(stage_probs)

        encoded_msg = self.get_encoded_value(encoder)

        <span class="hljs-keyword">return</span> encoder, encoded_msg

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span><span class="hljs-params">(self, encoded_msg, msg_length, probability_table)</span>:</span>
        <span class="hljs-string">"""
        Decodes a message.
        """</span>

        decoder = []
        decoded_msg = <span class="hljs-string">""</span>

        stage_min = Decimal(<span class="hljs-number">0.0</span>)
        stage_max = Decimal(<span class="hljs-number">1.0</span>)

        <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> range(msg_length):
            stage_probs = self.process_stage(probability_table, stage_min, stage_max)

            <span class="hljs-keyword">for</span> msg_term, value <span class="hljs-keyword">in</span> stage_probs.items():
                <span class="hljs-keyword">if</span> encoded_msg &gt;= value[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> encoded_msg &lt;= value[<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">break</span>

            decoded_msg = decoded_msg + msg_term
            stage_min = stage_probs[msg_term][<span class="hljs-number">0</span>]
            stage_max = stage_probs[msg_term][<span class="hljs-number">1</span>]

            decoder.append(stage_probs)

        stage_probs = self.process_stage(probability_table, stage_min, stage_max)
        decoder.append(stage_probs)

        <span class="hljs-keyword">return</span> decoder, decoded_msg</pre>



<p id="separator-block_5fca7490d7e26" class="block-separator block-separator--5">以下是代码打印的消息。因为十进制模块中使用的精度足以对消息进行编码，所以消息被成功解码。</p>



<h3>深度学习的应用</h3>



<p>一个高度感兴趣的深度学习AE应用是图像和视频压缩。</p>



<ol><li>它与深度自动编码器一起使用，以非常小的每像素位数(bpp)实现高质量的图像压缩。</li><li>最近使用AE的论文之一是:程，，等“通过时空能量压缩学习图像和视频压缩”IEEE计算机视觉和模式识别会议论文集。2019.</li><li>下一张图摘自总结事物如何工作的论文。</li><li>分析转换块表示自动编码器的编码器。它的潜在向量被馈送到量化步骤。使用算术编码对量化的输出进行编码。编码量化向量的值被转换成二进制。</li><li>然后，使用算术编码对二进制串进行解码，以馈送到代表自动编码器解码器的合成变换块。</li></ol>



<p>结论</p>



<pre class="hljs"><span class="hljs-keyword">import</span> pyae

frequency_table = {<span class="hljs-string">"a"</span>: <span class="hljs-number">2</span>,
                   <span class="hljs-string">"b"</span>: <span class="hljs-number">3</span>,
                   <span class="hljs-string">"c"</span>: <span class="hljs-number">1</span>,
                   <span class="hljs-string">"d"</span>: <span class="hljs-number">4</span>}

AE = pyae.ArithmeticEncoding(frequency_table)

original_msg = <span class="hljs-string">"bdab"</span>
print(<span class="hljs-string">"Original Message: {msg}"</span>.format(msg=original_msg))

encoder, encoded_msg = AE.encode(msg=original_msg,
                                 probability_table=AE.probability_table)
print(<span class="hljs-string">"Encoded Message: {msg}"</span>.format(msg=encoded_msg))

decoder, decoded_msg = AE.decode(encoded_msg=encoded_msg,
                                 msg_length=len(original_msg),
                                 probability_table=AE.probability_table)
print(<span class="hljs-string">"Decoded Message: {msg}"</span>.format(msg=decoded_msg))

print(<span class="hljs-string">"Message Decoded Successfully? {result}"</span>.format(result=original_msg == decoded_msg))</pre>



<p>我对算术编码算法的介绍到此结束。AE将整个消息编码成一个浮点数。</p>



<pre class="hljs">Original Message: bdab
Encoded Message: <span class="hljs-number">0.3884</span>
Decoded Message: bdab
Message Decoded Successfully? <span class="hljs-keyword">True</span></pre>



<p id="separator-block_5fca7499d7e27" class="block-separator block-separator--5">我们基于两个例子讨论了AE的详细步骤，在这两个例子中，编码器和解码器是如何工作的是很清楚的。</p>



<h2 id="h-applications-in-deep-learning">我们还构建了这个算法的一个Python实现，可以在GitHub上找到。</h2>



<p>该实现只有一个名为pyae.py的模块，其中有一个名为ArithmeticEncoding的类来构建算法。</p>



<p>算术编码在深度学习中的一个很酷的应用是压缩高质量的图像，同时实现非常低的每像素位数(bpp)率。</p>



<p>在后面的教程中，我将提供更多关于算术编码的细节，比如对算术编码应用的深入讨论。该实现将扩展到处理各种类型的数据。此外，从编码过程返回的十进制值将被转换为二进制。</p>



<p>现在，感谢阅读！</p>







<p>The Analysis Transform block represents the encoder of the autoencoder. Its latent vector is fed to a quantization step. The output of the quantization is encoded using arithmetic encoding. The value that encodes the quantized vector is converted into binary. </p>



<p>The binary string is then decoded using the arithmetic encoding to be fed to the Synthesis Transform block which represents the decoder of the autoencoder.</p>



<p id="separator-block_5fca74a3d7e28" class="block-separator block-separator--5">
</p>



<h2 id="h-conclusion">Conclusion</h2>



<p>This concludes my introduction to the arithmetic encoding algorithm. AE encodes the entire message into a single floating-point number. </p>



<p>We went over the detailed steps of AE based on 2 examples, within which it is clear how the encoder and the decoder work. </p>



<p>We also built a <a href="https://web.archive.org/web/20221206010842/https://github.com/ahmedfgad/ArithmeticEncodingPython" target="_blank" rel="noreferrer noopener nofollow">Python implementation</a> of this algorithm which is <a href="https://web.archive.org/web/20221206010842/https://github.com/ahmedfgad/ArithmeticEncodingPython" target="_blank" rel="noreferrer noopener nofollow">available on GitHub</a>. </p>



<p>The implementation has just a single module named pyae.py, which has a class named ArithmeticEncoding that builds the algorithm.</p>



<p>One cool application of arithmetic encoding in deep learning is compressing images with high quality while achieving a very low bits per pixel (bpp) rate.</p>



<p>In later tutorials, I’ll provide more details about arithmetic encoding, like an in-depth discussion of the applications of arithmetic encoding. The implementation will be extended to work with various types of data. Also, the decimal value returned from the encoding process will be converted into binary.</p>



<p>For now, thanks for reading!</p>



<p id="separator-block_60379a06fab10" class="block-separator block-separator--10">
</p>


<p id="separator-block_60379a32fab11" class="block-separator block-separator--10">
</p>
        </div>
        
    </div>    
</body>
</html>