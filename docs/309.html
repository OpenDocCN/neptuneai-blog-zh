<html>
<head>
<title>How to Manage, Track, and Visualize Hyperparameters of Machine Learning Models? </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何管理、跟踪和可视化机器学习模型的超参数？</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/how-to-manage-track-visualize-hyperparameters#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/how-to-manage-track-visualize-hyperparameters#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p><strong>机器学习算法可通过称为超参数</strong>的多个量规进行调整。最近的深度学习模型可以通过数十个超参数进行调整，这些超参数与数据扩充参数和训练程序参数一起创建了非常复杂的空间。在强化学习领域，您还应该计算环境参数。</p>



<p>数据科学家要<strong>控制好</strong> <strong>超参数</strong> <strong>空间</strong>，才能<strong>使</strong> <strong>进步</strong>。</p>



<p>在这里，我们将向您展示<strong>最近的</strong> <strong>实践</strong>、<strong>技巧&amp;诀窍、示例、</strong>和<strong>工具</strong>，以最小的开销高效地管理、跟踪和可视化超参数。你会发现自己掌控了最复杂的深度学习实验！</p>







<h2 id="h-why-should-i-track-my-hyperparameters-a-k-a-why-is-that-important">为什么我应该跟踪我的超参数？也就是为什么这很重要？</h2>



<p>几乎每一个深度学习实验指南，像<a href="https://web.archive.org/web/20221206041922/https://www.deeplearningbook.org/contents/guidelines.html" target="_blank" rel="noreferrer noopener nofollow">这本深度学习书籍</a>，都建议你如何调整超参数，使模型按预期工作。在<strong>实验-分析-学习循环</strong>中，数据科学家必须控制正在进行的更改，以便循环的“学习”部分正常工作。</p>



<p>哦，忘了说<strong>随机种子也是一个超参数</strong>(特别是在RL领域:例如检查<a href="https://web.archive.org/web/20221206041922/https://www.reddit.com/r/MachineLearning/comments/76th74/d_why_random_seeds_sometimes_have_quite_large/" target="_blank" rel="noreferrer noopener nofollow">这个Reddit </a>)。</p>



<h2 id="h-what-is-the-current-practice-in-hyperparameter-management-and-tracking">超参数管理和跟踪的当前实践是什么？</h2>



<p>让我们逐一回顾一下管理超参数的常见做法。我们关注于如何构建、保存和传递超参数给你的ML脚本。</p>



<h3>Python词典</h3>



<p>很基础，很有用。只需在Python字典中收集超参数，如下例所示:</p>



<pre class="hljs">PARAMS = {<span class="hljs-string">'epoch_nr'</span>: <span class="hljs-number">5</span>,
          <span class="hljs-string">'batch_size'</span>: <span class="hljs-number">64</span>,
          <span class="hljs-string">'dense'</span>: <span class="hljs-number">256</span>,
          <span class="hljs-string">'optimizer'</span>: <span class="hljs-string">'sgd'</span>,
          <span class="hljs-string">'metrics'</span>: [<span class="hljs-string">'accuracy'</span>, <span class="hljs-string">'binary_accuracy'</span>],
          <span class="hljs-string">'activation'</span>: <span class="hljs-string">'elu'</span>}</pre>



<p>由于这种方法，您<strong>将所有超参数保存在一个Python对象</strong>中，并且您可以轻松地在您的训练脚本中使用它。为了确保你在机器学习项目中跟踪那些参数，建议只在<strong>版本控制文件中创建这个字典</strong>。</p>



<p>你可以点击查看整个例子<a href="https://web.archive.org/web/20221206041922/https://app.neptune.ai/common/colab-test-run/e/COL-219/source-code?path=source_code&amp;file=main.py&amp;attribute=files&amp;filePath=." target="_blank" rel="noreferrer noopener">。</a></p>



<p><strong>优点</strong></p>



<ol>
<li>简单明了，因为你已经知道这个工具。</li>



<li>用嵌套的字典很容易制作一个层次结构。</li>



<li>几乎没有代码开销。</li>



<li>易于将多个配置文件合并到一个字典中。</li>



<li>可以保存在pickle文件中以备将来使用。</li>
</ol>



<p><strong>缺点</strong></p>



<ol class="is-style-default">
<li>超参数是代码库的一部分，虽然它们应该是独立的——记住要区分逻辑和它的参数化。</li>



<li>将参数保存到磁盘并不明显。</li>



<li>您可能没有注意到您覆盖了一些值。然后，很难了解一个特定的设置是如何执行的，因为你可能会覆盖一些神奇的数字。</li>



<li>保存的pickle文件在代码之外是不可读的。</li>
</ol>



<section id="note-block_2ef7fcd09203d44f9ed851efe2f008b3" class="block-note c-box c-box--default c-box--dark c-box--no-hover c-box--standard ">

    

    <div class="block-note__content">
                    <div class="c-item c-item--wysiwyg_editor">

                <img alt="" class="c-item__arrow lazyload" src="../Images/9ca543bfe77006930be78dbdfc769078.png" data-src="https://web.archive.org/web/20221206041922/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg" data-original-src="https://web.archive.org/web/20221206041922/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg"/>

                <div class="c-item__content">

                                            <p>它是一个<a href="https://web.archive.org/web/20221206041922/https://pypi.org/project/attrdict/" target="_blank" rel="noopener"> Python库</a>，允许你以键和属性的形式访问字典元素<strong>。用属性语法真的很方便。</strong></p>
                                    </div>

            </div>
                    <div class="c-item c-item--text">

                <img alt="" class="c-item__arrow lazyload" src="../Images/9ca543bfe77006930be78dbdfc769078.png" data-src="https://web.archive.org/web/20221206041922/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg" data-original-src="https://web.archive.org/web/20221206041922/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg"/>

                <div class="c-item__content">

                                            <p>下面是一个嵌套字典的例子:</p>
                                    </div>

            </div>
                    <div class="c-item c-item--html_code">

                <img alt="" class="c-item__arrow lazyload" src="../Images/9ca543bfe77006930be78dbdfc769078.png" data-src="https://web.archive.org/web/20221206041922/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg" data-original-src="https://web.archive.org/web/20221206041922/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg"/>

                <div class="c-item__content">

                                            <pre class="hljs">config = {<span class="hljs-string">'neptune'</span>: {<span class="hljs-string">'project'</span>: <span class="hljs-string">'kamil/analysis'</span>,
                      <span class="hljs-string">'tags'</span>: [<span class="hljs-string">'xgb-tune'</span>]},
          <span class="hljs-string">'booster'</span>: {<span class="hljs-string">'max_depth'</span>: <span class="hljs-number">10</span>,
                      <span class="hljs-string">'eta'</span>: <span class="hljs-number">0.01</span>,
                      <span class="hljs-string">'gamma'</span>: <span class="hljs-number">0.001</span>,
                      <span class="hljs-string">'silent'</span>: <span class="hljs-number">1</span>,
                      <span class="hljs-string">'subsample'</span>: <span class="hljs-number">1</span>,
                      <span class="hljs-string">'lambda'</span>: <span class="hljs-number">1</span>,
                      <span class="hljs-string">'alpha'</span>: <span class="hljs-number">0.05</span>,
                      <span class="hljs-string">'objective'</span>: <span class="hljs-string">'reg:linear'</span>,
                      <span class="hljs-string">'verbosity'</span>: <span class="hljs-number">0</span>,
                      <span class="hljs-string">'eval_metric'</span>: <span class="hljs-string">'rmse'</span>,
                      },
          <span class="hljs-string">'num_round'</span>: <span class="hljs-number">20</span>,
          }
</pre>                                    </div>

            </div>
                    <div class="c-item c-item--wysiwyg_editor">

                <img alt="" class="c-item__arrow lazyload" src="../Images/9ca543bfe77006930be78dbdfc769078.png" data-src="https://web.archive.org/web/20221206041922/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg" data-original-src="https://web.archive.org/web/20221206041922/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg"/>

                <div class="c-item__content">

                                            <p>您可以像这样访问<code>eta</code>:</p>
                                    </div>

            </div>
                    
                    <div class="c-item c-item--text">

                <img alt="" class="c-item__arrow lazyload" src="../Images/9ca543bfe77006930be78dbdfc769078.png" data-src="https://web.archive.org/web/20221206041922/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg" data-original-src="https://web.archive.org/web/20221206041922/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg"/>

                <div class="c-item__content">

                                            <p>有了attrdict，您可以用更优雅的方式来完成:</p>
                                    </div>

            </div>
                    <div class="c-item c-item--html_code">

                <img alt="" class="c-item__arrow lazyload" src="../Images/9ca543bfe77006930be78dbdfc769078.png" data-src="https://web.archive.org/web/20221206041922/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg" data-original-src="https://web.archive.org/web/20221206041922/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg"/>

                <div class="c-item__content">

                                            <pre class="hljs">cfg = AttrDict(config)rncfg.booster.eta
</pre>                                    </div>

            </div>
            </div>


</section>



<p id="separator-block_aa04a3c49fab1d499633b48084a4d627" class="block-separator block-separator--5">配置文件</p>



<h3>它们是常规的文本文件，有一些预定义的结构和标准的库来解析它们，比如<a href="https://web.archive.org/web/20221206041922/https://docs.python.org/3.7/library/json.html" target="_blank" rel="noreferrer noopener nofollow"> JSON编码器和解码器</a>，或者<a href="https://web.archive.org/web/20221206041922/https://pyyaml.org/wiki/PyYAMLDocumentation" target="_blank" rel="noreferrer noopener nofollow"> PyYAML </a>。常见的标准是JSON、yaml或cfg文件。</h3>



<p>下面是一个yaml文件的例子，它为<a href="https://web.archive.org/web/20221206041922/https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html" target="_blank" rel="noreferrer noopener nofollow">随机森林</a>提供了多个超参数，以及更一般的信息，如项目和实验名称。</p>



<p>与基于字典的风格类似，您只需要对这个文件进行版本控制，以跟踪超参数。</p>



<pre class="hljs">project: ORGANIZATION/home-credit
name: home-credit-default-risk

parameters:

  n_cv_splits: <span class="hljs-number">5</span>
  validation_size: <span class="hljs-number">0.2</span>
  stratified_cv: <span class="hljs-keyword">True</span>
  shuffle: <span class="hljs-number">1</span>


  rf__n_estimators: <span class="hljs-number">2000</span>
  rf__criterion: gini
  rf__max_features: <span class="hljs-number">0.2</span>
  rf__max_depth: <span class="hljs-number">40</span>
  rf__min_samples_split: <span class="hljs-number">50</span>
  rf__min_samples_leaf: <span class="hljs-number">20</span>
  rf__max_leaf_nodes: <span class="hljs-number">60</span>
  rf__class_weight: balanced


  aggregation_method: rank_mean
</pre>



<p>您可以通过简单地像这样使用<code>yaml.load()</code>来<strong>读取yaml文件并访问它的元素</strong>:</p>



<p>由于刚刚介绍了<strong>attr direct</strong>，我们修改一下这个代码片段，用更优雅的方式<strong>访问</strong> <code>n_cv_splits</code> <strong>值</strong>:</p>



<pre class="hljs"><span class="hljs-keyword">import</span> yaml

<span class="hljs-keyword">with</span> open(config_path) <span class="hljs-keyword">as</span> f:
    config = yaml.load(f, Loader=yaml.BaseLoader)  

print(config[<span class="hljs-string">'parameters'</span>][<span class="hljs-string">'n_cv_splits'</span>])  
</pre>



<p>这里是一个用于存储特征选择、模型参数等的大型yaml文件的<a href="https://web.archive.org/web/20221206041922/https://ui.neptune.ai/o/neptune-ai/org/Home-Credit-Default-Risk/e/HC-11735/source-code?path=configs%2F&amp;file=neptune.yaml" target="_blank" rel="noreferrer noopener">示例</a>。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> yaml
<span class="hljs-keyword">from</span> attrdict <span class="hljs-keyword">import</span> AttrDict

<span class="hljs-keyword">with</span> open(config_path) <span class="hljs-keyword">as</span> f:
    config = yaml.load(f, Loader=yaml.BaseLoader)  
    cfg = AttrDict(config)

print(cfg.parameters.n_cv_splits)  
</pre>



<p><strong>优点</strong></p>



<p>一切都位于一个地方。</p>



<ol>
<li>易于重复使用保存的配置文件。</li>



<li>脚本逻辑及其参数化的良好分离。</li>



<li>增强了代码的可读性。</li>



<li><strong>缺点</strong></li>
</ol>



<p>将超参数放入配置文件需要一些编程知识。</p>



<ol>
<li>如果代码库变化很快(新特性、新模型，同时删除旧版本的代码)，维护正确的配置文件是额外的开销。</li>



<li>对于大型代码库，您可能会有几个配置文件，这会使事情变得更加复杂和繁琐。</li>



<li>YAML文件是在AWS和其他云平台中部署时编写配置的标准格式。因此，与YAML打交道是值得的，因为播下的种子将在部署中收获好处。</li>
</ol>



<p>抱怨吗</p>



<h3>在进行试验时，您通常会经历多次试验(或实验)，以便了解超参数和得分之间的关系，并获得性能最佳的模型(我们将模型性能良好意味着什么的讨论留到另一篇文章中)。</h3>



<p>在这种情况下，从<strong>命令</strong> <strong>行</strong>和<strong>直接在CLI </strong>中指定参数 <strong>值</strong>来<strong>开始新的实验</strong>就派上用场了。<a href="https://web.archive.org/web/20221206041922/https://docs.python.org/3/library/argparse.html" target="_blank" rel="noreferrer noopener nofollow"> Argparse </a>是一个Python模块，它使得编写<strong>用户友好的命令行界面</strong>变得容易。</p>







<p>我认为<strong>理解argparse </strong>的一个简单方法是<strong>简单地</strong> <strong>分析</strong>一个<strong>例子</strong>。下面是一个简单的Python程序，它接受三个可选的位置参数并打印它们。</p>



<p>如果你<strong>运行</strong>这个程序，<strong>没有任何参数，那么将使用默认值</strong>:</p>



<pre class="hljs"><span class="hljs-keyword">import</span> argparse

parser = argparse.ArgumentParser(description=<span class="hljs-string">'Process hyper-parameters'</span>)

parser.add_argument(<span class="hljs-string">'--lr'</span>,       type=float, default=<span class="hljs-number">0.001</span>, help=<span class="hljs-string">'learning rate'</span>)
parser.add_argument(<span class="hljs-string">'--dropout'</span>,  type=float, default=<span class="hljs-number">0.0</span>,   help=<span class="hljs-string">'dropout ratio'</span>)
parser.add_argument(<span class="hljs-string">'--data_dir'</span>, type=str,   default=<span class="hljs-string">'/neptune/is/the/best/data/'</span>, help=<span class="hljs-string">'data directory for training'</span>)

args = parser.parse_args()


print(args.lr)
print(args.dropout)
print(args.data_dir)

</pre>



<p>输出是:</p>



<pre class="hljs">python main.py
</pre>



<p>如果您<strong>指定参数</strong>，那么它们将被解析，以便您<strong>可以在您的训练脚本</strong>中使用它们:</p>



<pre class="hljs"><span class="hljs-number">0.001</span>
<span class="hljs-number">0.0</span>
/neptune/<span class="hljs-keyword">is</span>/the/best/data/

</pre>



<p>输出是:</p>



<pre class="hljs">python main.py --lr <span class="hljs-number">0.005</span> --dropout <span class="hljs-number">0.5</span>
</pre>



<p>关于跟踪的一个重要注意事项:注意<strong> argparse不保存或记录在命令行</strong>中传递的参数。用户必须<strong>自己保存参数值</strong>。</p>



<pre class="hljs"><span class="hljs-number">0.005</span>
<span class="hljs-number">0.5</span>
/neptune/<span class="hljs-keyword">is</span>/the/best/data/

</pre>



<p><strong>优点</strong></p>



<p>方便地开始新的实验。</p>



<ol>
<li>动态决定超参数的值。</li>



<li>易于向argparse添加新参数。</li>



<li><strong>缺点</strong></li>
</ol>



<p>需要额外的努力(虽然不是很大)来跟踪基于实验的长期项目中超参数的值。Argparse不在任何地方保存值。</p>



<ol class="is-style-default">
<li>与配置文件类似，如果您的项目增长迅速，您可能会发现很难维护CLI参数。</li>



<li>如果在代码的几个地方传递参数，如何有效地使用argparse就变得不那么明显了。如果从多个位置构建/合并参数，情况也类似。</li>



<li>水螅</li>
</ol>







<p id="separator-block_aa04a3c49fab1d499633b48084a4d627" class="block-separator block-separator--5"><a href="https://web.archive.org/web/20221206041922/https://hydra.cc/"> Hydra </a>是脸书AI的一个新项目，它简化了更复杂的机器学习实验的配置。</p>



<h3>其背后的关键理念是:</h3>



<p>动态地<strong>创建一个</strong>一个<strong>层次化的</strong> <strong>配置</strong> <strong>由</strong> <strong>组成</strong>，</p>



<p>需要时通过命令行覆盖它，</p>



<ul>
<li>通过CLI传递新参数(配置中没有)——它们将被自动处理</li>



<li>Hydra使您能够准备和覆盖复杂的配置设置(包括配置组和层次结构)，同时跟踪任何被覆盖的值。</li>



<li>与argparse类似，<strong>理解它的最佳方式(以及使用hydra有多简单)是分析一个示例</strong>。</li>
</ul>



<p>让我们从关于配置文件的部分考虑简化的配置<code>yaml</code>文件:</p>



<p>下面是<strong>极简风格的九头蛇例子</strong>:</p>



<p>当您运行它时，您应该会看到:</p>



<pre class="hljs">project: ORGANIZATION/home-credit
name: home-credit-default-risk

parameters:

  n_cv_splits: <span class="hljs-number">5</span>
  validation_size: <span class="hljs-number">0.2</span>
  stratified_cv: <span class="hljs-keyword">True</span>
  shuffle: <span class="hljs-number">1</span>


  rf__n_estimators: <span class="hljs-number">2000</span>
  rf__criterion: gini
  rf__max_depth: <span class="hljs-number">40</span>
  rf__class_weight: balanced
</pre>



<p>在hydra中<strong>方便的是，您可以从CLI </strong>覆盖配置中的任何值，如下所示:</p>



<pre class="hljs"><span class="hljs-keyword">import</span> hydra
<span class="hljs-keyword">from</span> omegaconf <span class="hljs-keyword">import</span> DictConfig

<span class="hljs-meta">@hydra.main(config_path='hydra-config.yaml')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span><span class="hljs-params">(cfg)</span>:</span>
    print(cfg.pretty())  
    print(cfg.parameters.rf__n_estimators)  
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    train()
</pre>



<p>因此，在配置中有了新的值:</p>



<pre class="hljs">name: home-credit-default-risk
parameters:
  n_cv_splits: <span class="hljs-number">5</span>
  rf__class_weight: balanced
  rf__criterion: gini
  rf__max_depth: <span class="hljs-number">40</span>
  rf__n_estimators: <span class="hljs-number">2000</span>
  shuffle: <span class="hljs-number">1</span>
  stratified_cv: true
  validation_size: <span class="hljs-number">0.2</span>
project: ORGANIZATION/home-credit

<span class="hljs-number">2000</span>
</pre>



<p>另一个提供良好灵活性的<strong>特性是一个选项，可以直接从命令行</strong>传递新的、以前看不到的参数。</p>



<pre class="hljs">python hydra-main.py parameters.n_cv_splits=<span class="hljs-number">12</span>   parameters.stratified_cv=<span class="hljs-keyword">False</span> name=entirely-new-name

</pre>



<p>要启用此功能，只需关闭hydra中的严格模式。</p>



<pre class="hljs">name: entirely-new-name
parameters:
  n_cv_splits: <span class="hljs-number">12</span>
  rf__class_weight: balanced
  rf__criterion: gini
  rf__max_depth: <span class="hljs-number">40</span>
  rf__n_estimators: <span class="hljs-number">2000</span>
  shuffle: <span class="hljs-number">1</span>
  stratified_cv: false
  validation_size: <span class="hljs-number">0.2</span>
project: ORGANIZATION/home-credit

<span class="hljs-number">2000</span>

</pre>



<p>在下面的命令中，我将<code>rf__max_features</code>添加到配置中，同时将<code>rf__n_estimators</code>更改为1500。<strong>注意config和前面的例子是一样的。在代码中，我们只关闭了严格模式</strong>:</p>



<p>输出相应改变:</p>



<pre class="hljs"><span class="hljs-meta">@hydra.main(config_path='config.yaml', strict=False)</span>
</pre>



<p>hydra项目正在积极开发中，所以请确保不时查看他们的<a href="https://web.archive.org/web/20221206041922/https://hydra.cc/docs/tutorials/intro">教程</a>以了解新特性。</p>



<pre class="hljs">python hydra-main.py parameters.rf__n_estimators=<span class="hljs-number">1500</span>   parameters.rf__max_features=<span class="hljs-number">0.2</span>
</pre>



<p><strong>优点</strong></p>



<pre class="hljs">name: home-credit-default-risk
parameters:
  n_cv_splits: <span class="hljs-number">5</span>
  rf__class_weight: balanced
  rf__criterion: gini
  rf__max_depth: <span class="hljs-number">40</span>
  rf__max_features: <span class="hljs-number">0.2</span>
  rf__n_estimators: <span class="hljs-number">1500</span>
  shuffle: <span class="hljs-number">1</span>
  stratified_cv: true
  validation_size: <span class="hljs-number">0.2</span>
project: ORGANIZATION/home-credit

<span class="hljs-number">1500</span>

</pre>



<p>可组合配置。</p>



<p>能够非常容易地覆盖值，并且仍然跟踪它们。</p>



<ol>
<li>将组织带入更大实验的配置组。</li>



<li><strong>缺点</strong></li>



<li>九头蛇在更大的实验中大放异彩，这些实验以多个超参数及其等级来衡量。对于较小的，其他方法将做得恰到好处。</li>
</ol>



<p>您需要小心避免重要参数值的意外覆盖。</p>



<ol>
<li>为了跨实验跟踪超参数，您需要手动保存配置对象(上面示例中的<code>cfg</code>)。</li>



<li>PyTorchLightning照明模块超参数</li>



<li><strong> <em>注意</em> </strong> : <em>这种方法只有在你选择PyTorchLightning作为框架的时候才有效</em></li>
</ol>



<h3>PyTorch Lightning有一种隐式的方法来跟踪检查站和YAML中的超参数(与我们上面讨论的相同)。这增强了可再现性，并使代码中的跟踪过程干净而高效。不需要在代码库中导入模块或加载任何文件。</h3>



<p>所有繁重的工作都由<strong> LightningModule </strong>完成，用户只需直接继承方法。让我们来看一个实际例子:</p>



<p>save_hyperparameters()方法将对象中存在的所有超参数保存到YAML文件中。前往<a href="https://web.archive.org/web/20221206041922/https://pytorch-lightning.readthedocs.io/en/latest/common/hyperparameters.html#lightningmodule-hyperparameters" target="_blank" rel="noreferrer noopener nofollow">文档</a>了解更多关于像模型检查点文件一样保存和加载超参数的信息。</p>



<p><strong>优点:</strong></p>



<pre class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LitMNIST</span><span class="hljs-params">(LightningModule)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, layer_1_dim=<span class="hljs-number">128</span>, learning_rate=<span class="hljs-number">1e-2</span>)</span>:</span>
        super().__init__()
        
        self.save_hyperparameters()

        
        self.save_hyperparameters(<span class="hljs-string">"layer_1_dim"</span>, <span class="hljs-string">"learning_rate"</span>)

        
        self.hparams.layer_1_dim</pre>



<p>没有任何模块或文件加载额外的依赖</p>



<p>快速有效的保存和加载功能</p>



<ol>
<li>本质上的隐含性保持了代码库的整洁和可解释性</li>



<li><strong>缺点:</strong></li>



<li>这些方法仅限于PyTorch Lightning模块</li>
</ol>



<p>不幸的是，它也受到YAML文件的困扰。</p>



<ol>
<li>它需要代码和编程知识来处理好事情</li>



<li>如果配置变化很快，维护配置文件是额外的负担。但是，这可以通过使用版本控制来解决。<ul>
<li>这种技术灵活性较差。例如，如果您想在不同的配置文件中保存不同的超参数，那么您必须返回来显式地创建它们。</li>



<li>Tensorflow 2张量板HParams</li>
</ul>
</li>



<li><strong> <em>注意</em> </strong> : <em>这种方法只有在使用Tensorflow作为框架选择的情况下才有效</em></li>
</ol>



<h3>对于超参数调优，最佳实践是将这些超参数放在一个地方，作为做出正确决策的结果。TensorBoard中的HParams仪表板提供了多种工具，可帮助确定最佳实验或最有希望的超参数集。</h3>



<p>使用HParams类记录超参数将让您在tensorboard中可视化它们以及大量其他方便的信息。使用TF summary writer以Tensoroard兼容格式记录和保存超参数后，您可以在不同的实验中再次导入和重复使用这些参数。让我们看一个在拟合模型时如何记录和利用它的例子。</p>



<p>您可以使用hp声明您想要的超参数。HParam方法，并使用tf.summary.create_file_writer保存，它会将它们保存为tensorboard可以读取的格式。</p>



<p>您可以在模型中直接使用上面在HParams中声明的超参数。前往<a href="https://web.archive.org/web/20221206041922/https://www.tensorflow.org/tensorboard/hyperparameter_tuning_with_hparams" target="_blank" rel="noreferrer noopener nofollow">文档</a>了解更多信息。</p>



<pre class="hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">from</span> tensorboard.plugins.hparams <span class="hljs-keyword">import</span> api <span class="hljs-keyword">as</span> hp

HP_NUM_UNITS = hp.HParam(<span class="hljs-string">'num_units'</span>, hp.Discrete([<span class="hljs-number">16</span>, <span class="hljs-number">32</span>]))
HP_DROPOUT = hp.HParam(<span class="hljs-string">'dropout'</span>, hp.RealInterval(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>))
HP_OPTIMIZER = hp.HParam(<span class="hljs-string">'optimizer'</span>, hp.Discrete([<span class="hljs-string">'adam'</span>, <span class="hljs-string">'sgd'</span>]))

METRIC_ACCURACY = <span class="hljs-string">'accuracy'</span>

<span class="hljs-keyword">with</span> tf.summary.create_file_writer(<span class="hljs-string">'logs/hparam_tuning'</span>).as_default():
  hp.hparams_config(
    hparams=[HP_NUM_UNITS, HP_DROPOUT, HP_OPTIMIZER],
    metrics=[hp.Metric(METRIC_ACCURACY, display_name=<span class="hljs-string">'Accuracy'</span>)],
  )</pre>



<p><strong>优点:</strong></p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train_test_model</span><span class="hljs-params">(hparams)</span>:</span>
  model = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(hparams[HP_NUM_UNITS], activation=tf.nn.relu),
    tf.keras.layers.Dropout(hparams[HP_DROPOUT]),
    tf.keras.layers.Dense(<span class="hljs-number">10</span>, activation=tf.nn.softmax),
  ])
  model.compile(
      optimizer=hparams[HP_OPTIMIZER],
      loss=<span class="hljs-string">'sparse_categorical_crossentropy'</span>,
      metrics=[<span class="hljs-string">'accuracy'</span>],
  )

  model.fit(x_train, y_train, epochs=<span class="hljs-number">1</span>) 
  _, accuracy = model.evaluate(x_test, y_test)
  <span class="hljs-keyword">return</span> accuracy</pre>



<p>没有任何模块或文件加载额外的依赖</p>



<p>快速简单的可视化过程</p>



<ol>
<li>本质上的隐含性保持了代码库的整洁和可解释性</li>



<li>目录结构将保持整洁有序</li>



<li><strong>缺点:</strong></li>



<li>这些方法只限于张量板模块</li>
</ol>



<p>它需要代码和编程知识来处理好事情</p>



<ol>
<li>如果配置变化很快，维护配置文件是额外的负担。但是，这可以通过使用版本控制来解决。</li>



<li>这种技术也提供了较少的灵活性。例如，如果您想在不同的配置文件中保存不同的超参数，那么您必须返回来显式地创建它们。</li>



<li>管理超参数的另一个步骤是在更广泛的实验管理环境中使用它们。下面是一个关于【Neptune如何处理ML实验的参数化的例子:</li>



<li>这样，每个实验都有自己的params设置保存到Neptune，以供进一步分析和跨实验比较。这种方法的主要优点是，您可以<strong>将参数与其他实验相关的数据/元数据相关联，如评估指标或结果模型。</strong></li>
</ol>







<p>前往文档了解如何无缝集成Neptune，而无需对代码做太多修改。</p>



<pre class="hljs">
PARAMS = {<span class="hljs-string">'batch_size'</span>: <span class="hljs-number">64</span>,
          <span class="hljs-string">'n_epochs'</span>: <span class="hljs-number">100</span>,
          <span class="hljs-string">'shuffle'</span>: <span class="hljs-keyword">True</span>,
          <span class="hljs-string">'activation'</span>: <span class="hljs-string">'elu'</span>,
          <span class="hljs-string">'dense_units'</span>: <span class="hljs-number">128</span>,
          <span class="hljs-string">'dropout'</span>: <span class="hljs-number">0.2</span>,
          <span class="hljs-string">'learning_rate'</span>: <span class="hljs-number">0.001</span>,
          <span class="hljs-string">'early_stopping'</span>: <span class="hljs-number">10</span>,
          <span class="hljs-string">'optimizer'</span>: <span class="hljs-string">'Adam'</span>,
          }


neptune.create_experiment(params=PARAMS)


</pre>



<p>实验跟踪工具——如Neptune——在多个不同位置显示参数，以便您可以:</p>



<p>突出显示所有不同的参数时，更详细地比较选定的实验(<a href="https://web.archive.org/web/20221206041922/https://app.neptune.ai/o/common/org/quickstarts/experiments?split=tbl&amp;dash=quick-check-7b6057af-8003-4748-982e-34a7b83207ed&amp;viewId=64a274e0-25bc-49e0-b1ca-f093fb2b8f7b" target="_blank" rel="noreferrer noopener nofollow">示例</a>)。</p>


<div class="wp-block-image">
<figure class="aligncenter size-large is-resized"><a href="https://web.archive.org/web/20221206041922/https://neptune.ai/how-to-track-hyperparameters/attachment/parameters-logged-in-neptune"><img decoding="async" loading="lazy" src="../Images/98075b085dd02505887eec452d4b16bd.png" alt="" class="wp-image-68121" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206041922im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Parameters-logged-in-Neptune.png?resize=840%2C329&amp;ssl=1"/></a><figcaption class="wp-element-caption"><em><em>Parameters’ values are displayed for each experiment, allowing you to visually inspect and analyze runs</em></em></figcaption></figure></div>

<div class="wp-block-image">
<figure class="aligncenter size-large"><a href="https://web.archive.org/web/20221206041922/https://neptune.ai/how-to-track-hyperparameters/attachment/parameters-compare-in-neptune"><img decoding="async" src="../Images/0f3aa573b1d2dc3d56eb4ba7dd519377.png" alt="Parameters compare in Neptune" class="wp-image-68122" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206041922im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Parameters-compare-in-Neptune.png?ssl=1"/></a><figcaption class="wp-element-caption"><em>You can also compare multiple runs</em></figcaption></figure></div>


<p>搜索具有当前参数特定值的实验(<a href="https://web.archive.org/web/20221206041922/https://ui.neptune.ai/o/USERNAME/org/example-project/experiments?viewId=09405070-efd2-43a3-997b-ec6f88c02e44" target="_blank" rel="noreferrer noopener nofollow">示例</a>，其中我们仅显示具有正“<em>时间序列_因子</em>”的实验)。</p>



<ul>
<li>如何可视化超参数？</li>



<li>如果你是一个繁重的实验者，你可能会遇到需要<a href="https://web.archive.org/web/20221206041922/https://docs.neptune.ai/you-should-know/comparing-runs" target="_blank" rel="noreferrer noopener">有效地比较数百次运行</a>和<strong>可视化超参数和分数</strong>之间的关系。</li>
</ul>







<h2 id="h-how-to-visualize-hyperparameters">平行坐标图</h2>



<p>一种方法是准备一个平行坐标图，如下图所示:</p>



<h3>每个垂直轴是一个参数，分数是最右边的(垂直)轴。这种可视化提供了对产生最佳分数的参数范围的即时洞察。原则上，它应该是交互式的，允许用户自由地探索数据，并执行他们自己的推理和解释。</h3>



<p>一个建造平行坐标罐的伟大工具:<a href="https://web.archive.org/web/20221206041922/https://facebookresearch.github.io/hiplot/index.html" target="_blank" rel="noreferrer noopener"> HiPlot </a>，由<a href="https://web.archive.org/web/20221206041922/https://ai.facebook.com/" target="_blank" rel="noreferrer noopener">脸书人工智能研究院</a> (FAIR)开发。仔细看看<a href="https://web.archive.org/web/20221206041922/https://docs.neptune.ai/you-should-know/comparing-runs#parallel-coordinates" target="_blank" rel="noreferrer noopener">如何在Neptune </a>中使用平行坐标比较运行。</p>


<div class="wp-block-image">
<figure class="aligncenter"><img decoding="async" src="../Images/1ef0cf45fd77437d539ff1e0005a0212.png" alt="" data-original-src="https://web.archive.org/web/20221206041922im_/https://lh6.googleusercontent.com/YfsLHXkJXLEe1BvvxVvT7P9aRo6lBKIbDa-79Ntl34odVtZP07oRyAr4yLgy3RcycfkqrNxr8nMuqlAq4K5NFr3nPUn3S913nbFgpYtW8Z5DiXh2Jy9AQW0dFEG03Hgfrun1Jicl"/><figcaption class="wp-element-caption"><em>Parallel coordinates plot build with HiPlot.</em></figcaption></figure></div>


<p>顺便说一下，如此大量的运行(如上所述)通常来自于<strong>超参数优化</strong>作业，简称hpo。Python的开源环境在这个问题上有很大的贡献。检查这两个流行的hpo库的比较:<a href="https://web.archive.org/web/20221206041922/https://neptune.ai/blog/optuna-vs-hyperopt"> optuna和hyperopt </a>。</p>



<p>sci kit-优化</p>



<p>scikit-optimize的创建者提出了另一种检查和理解<em> hpo </em>结果的方法。每个<em> hpo </em>作业都会生成诊断图表，显示超参数和分数之间的关系。</p>



<h3>这里有一个例子:</h3>



<p>奥普图纳</p>



<p>Optuna是一个自动化超参数搜索的<strong>超参数优化框架</strong>。它为给定的工作提供了自己的超参数可视化套件。</p>





<h3>让我们来研究optuna hpo作业的一个<a href="https://web.archive.org/web/20221206041922/https://app.neptune.ai/o/common/org/optuna-integration/e/NEP1-691/all?path=visualizations&amp;attribute=plot_contour" target="_blank" rel="noreferrer noopener">示例:</a></h3>



<p>与前面的例子类似，可视化的主要目标<strong>是帮助理解超参数如何与正在优化的分数</strong>相关。</p>



<p>如果这听起来与你有关，仔细看看文档中的<a href="https://web.archive.org/web/20221206041922/https://docs.neptune.ai/integrations-and-supported-tools/hyperparameter-optimization/optuna" target="_blank" rel="noreferrer noopener"> neptune-optuna集成。</a></p>


<div class="wp-block-image">
<figure class="aligncenter size-large"><img decoding="async" src="../Images/ca656e11bf0f5d6e0856966e400c6df1.png" alt="" class="wp-image-61083" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221206041922im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Optuna-Neptune-integration.png?ssl=1"/><figcaption class="wp-element-caption"><em>Optuna diagnostics chart</em></figcaption></figure></div>


<p>最后的想法</p>



<p>超参数是大图的中心部分，即<a href="/web/20221206041922/https://neptune.ai/blog/experiment-management" target="_blank" rel="noreferrer noopener">实验管理</a>。在这篇文章中，我们展示了超参数跟踪实践的最新状态。有了Neptune，你可以把它提升一个层次，让团队中的<strong>变得容易接近、可比和共享。</strong></p>



<h2 id="h-final-thoughts">Final thoughts</h2>



<p>Hyperparameters are the central piece of the larger picture, which is <a href="/web/20221206041922/https://neptune.ai/blog/experiment-management" target="_blank" rel="noreferrer noopener">experiment management</a>. In this post, we showed the recent state of the practice in hyperparameters tracking. With Neptune, you can bring it one level up, by making them <strong>easily accessible, comparable, and shareable in the team instantaneously</strong>.</p>
        </div>
        
    </div>    
</body>
</html>