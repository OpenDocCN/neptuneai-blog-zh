<html>
<head>
<title>The Best Vertex ML Metadata Alternatives </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>最佳顶点ML元数据替代方案</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/vertex-ml-metadata-alternatives#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/vertex-ml-metadata-alternatives#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p>去年，谷歌宣布了<a href="https://web.archive.org/web/20221201180901/https://cloud.google.com/vertex-ai" target="_blank" rel="noreferrer noopener nofollow"> Vertex AI </a>，这是一个新的托管机器学习平台，旨在让开发者更容易部署和维护人工智能模型。那么，Vertex AI有什么好处和坏处呢？在本文中，我们将讨论Vertex AI，并看看它的替代品，但首先，让我们看看为什么需要这样一个工具？</p>







<p>表征数据集、计算环境和模型的信息称为元数据。简单来说，这是一个一站式商店，提供您构建和部署机器学习模型所需的所有信息。这对<a href="/web/20221201180901/https://neptune.ai/blog/how-to-solve-reproducibility-in-ml" target="_blank" rel="noreferrer noopener"> ML再现性</a>至关重要；没有元数据存储，如果您不记录和保存信息，您将无法重新创建测试。ML元数据存储将帮助您:</p>



<ul><li><strong> <a href="/web/20221201180901/https://neptune.ai/experiment-tracking" target="_blank" rel="noreferrer noopener">跟踪所有实验</a> </strong>和模型元数据。</li><li>提供工具<strong>可视化和比较实验</strong>。</li><li><strong>记录所有可能相关的元数据</strong>。</li><li>获取有关代码、数据、参数和环境版本的信息。</li><li><strong>分析、监控并提醒</strong>您是否检测到模型输入/输出分布的任何意外变化。</li></ul>







<p><a href="/web/20221201180901/https://neptune.ai/blog/data-lineage-in-machine-learning">数据和工件谱系</a>、再现性和可比性都是通过收集关于每个ML管道运行的数据来辅助的。当项目从开发过渡到生产时，再现性确保了数据的一致性和错误的减少。它也有助于调查故障和异常。通常，ML元数据存储将记录以下元数据:</p>



<ul><li>使用的管道和组件的版本。</li><li>开始和结束日期，以及管道完成每个阶段所需的时间。</li><li>作为参数提供给管道的参数。</li><li>在模型评估过程中为训练集和测试集生成的模型评估度量。在模型验证过程中，这些指标允许您将新训练的模型的性能与先前模型的性能进行比较。</li><li>在模型评估过程中为训练集和测试集生成的模型评估度量。</li></ul>



<div class="wp-block-image"><figure class="aligncenter size-large"><img decoding="async" src="../Images/d98dd9437083df452523c00eef0581f9.png" alt="Basic Workflow of Metadata Store" class="wp-image-61572" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221201180901im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Basic-Workflow-of-Metadata-Store.png?ssl=1"/><figcaption><em>Basic workflow of Metadata Store | Image by author</em></figcaption></figure></div>



<h2 id="vertex-ai">顶点人工智能</h2>



<p>谷歌推出了<a href="https://web.archive.org/web/20221201180901/https://cloud.google.com/vertex-ai" target="_blank" rel="noreferrer noopener nofollow"> Vertex AI，</a>这是一个新的统一机器学习平台，使用谷歌的人工智能技术来帮助你更快地部署模型。<strong> Vertex AI将用于机器学习开发的谷歌云服务结合到单一的UI和API中。</strong> Vertex AI允许您使用AutoML或自定义代码轻松训练和比较模型，并且您的所有模型都保存在单个模型库中。</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img decoding="async" src="../Images/9e499e0035841b7652d7f9392d56e6ee.png" alt="Vertex AI Dashboard" class="wp-image-61573" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221201180901im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Vertex-AI-Dashboard.png?ssl=1"/><figcaption><em>Vertex AI Dashboard | Screenshot by Author </em></figcaption></figure></div>



<h3 id="features-of-vertex-ai">顶点人工智能的特点</h3>



<p>有了Vertex AI，作为最终用户，您现在拥有了一个单一的工作流，它包含了从实验到部署的整个开发生命周期。以下是vertex AI的一些功能:</p>



<ul><li>支持所有流行的开源框架。</li></ul>



<p>它通过定制的训练和预测容器支持几乎所有的ML框架。这允许您以同样的方式对待所有的模型，不管它们是定制的还是用AutoML创建的。</p>







<p>您可以获得针对视觉、视频等内容的预训练API，这不仅是为了简化流程，也是为了提高效率。您可以简单地将它们集成到您现有的应用程序中，或者使用它们创建一个新的应用程序。因此，您可能不需要寻找额外的AI API平台来完成您的任务。</p>



<ul><li><strong>数据到人工智能的无缝集成</strong></li></ul>



<p>BigQueryML被广泛用于开发和执行使用SQL查询的机器学习模型，这并不奇怪。您将能够访问它并将数据集导出到平台中，以便使用Vertex AI将其与流程连接起来。因此，您将拥有端到端的集成。</p>



<ul><li><strong>简化的机器学习过程</strong></li></ul>



<p>您将能够利用AutoML、Explainable、Edge Manager等工具来处理ML模型。把所有东西都放在一个地方应该会改变游戏规则。您还可以使用自定义代码进行训练，同时将所有内容保存在一个地方。</p>



<p><strong> Vertix AI提供的工具有:</strong></p>



<ul><li>模型监控</li><li>匹配引擎</li><li><strong> ML元数据</strong></li><li>张量板</li><li>管道和更多的东西。</li></ul>







<p>Vertex AI使用<a href="https://web.archive.org/web/20221201180901/https://www.tensorflow.org/tfx/guide/mlmd" target="_blank" rel="noreferrer noopener nofollow"> MLMD </a>原理来存储元数据。它将元数据呈现为一个可导航的图形，节点代表执行和工件，边连接它们(如下图所示)。执行和对象由上下文进一步连接，上下文由子图表示。顶点ML元数据将有助于运行分析、ML实验和ML工件的跟踪等。让我们看一下用来记录元数据的一些最重要的实体。</p>



<ul><li>史前古器物</li><li>实行</li><li>事件</li><li>内容</li></ul>



<div class="wp-block-image"><figure class="aligncenter size-large"><a href="https://web.archive.org/web/20221201180901/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Vertex-AI-example-lineage-graph.png?ssl=1"><img decoding="async" src="../Images/7302d9f8b33954dd950e1214053a754b.png" alt="Vertex AI: example lineage graph " class="wp-image-61575" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221201180901im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Vertex-AI-example-lineage-graph.png?ssl=1"/></a><figcaption><em>Vertex AI: example lineage graph | <a href="https://web.archive.org/web/20221201180901/https://codelabs.developers.google.com/vertex-mlmd-pipelines#5" target="_blank" rel="noreferrer noopener nofollow">Source</a></em></figcaption></figure></div>



<h3 id="limitations-of-vertex-ai">顶点人工智能的局限性</h3>



<p>Vertex AI提供了许多好的特性，但它仍然有一些缺点，这可能是许多人担心的原因:</p>







<p>顶点元数据基于ML元数据，而ML元数据没有客户端python SDK，而客户端python SDK是临时训练操作(例如在笔记本中)所必需的。通过使用临时操作，组织可以节省时间、金钱并减少IT工作量。它目前缺乏诸如自动化调试、模型注册、模型工件编译和Kubernetes支持等特性，这可能是一些用户的障碍。它也缺乏同步在线和离线功能的能力。</p>







<p>作为新用户，你将有几个月的免费等级，但之后，你将不得不按需付费。与其他解决方案相比，Vertax AI相对昂贵，随着客户使用更多服务，价格可能会大幅上涨。你必须为其他用于模型监控的谷歌云产品付费，比如BigQuery storage或者Batch Explain。Vertex ML元数据存储费用从每月10美元每吉字节(GiB)开始，如果您使用其他功能，费用可能会增加。你可以在这里找到完整的价格信息。</p>







<p>顶点人工智能元数据目前只能在生产管道中使用。它允许您将GPU加速器链接到现有的CPU实例，但是它还不支持A100实例类型。</p>



<ul><li><strong>文档&amp;开发者指南</strong></li></ul>



<p>尽管Vertex AI已经推出了一段时间，但很难在网上或开发者社区网站上找到解决方案。<strong> </strong>由于该产品不是为中小型企业设计的，团队需要可靠的文档和教程来开始。</p>







<p>无论您是有一个成长中的团队，打算扩展和升级现有的解决方案，还是想要向您的产品线添加额外的ML解决方案，元数据存储都是实现速度、自动化和智能洞察的理想方式。元数据在机器学习中非常重要，因为它可以帮助您:</p>



<ul><li>伪像跟踪</li><li>对模型审计试验的法律遵从性</li><li>热身训练</li><li>跟踪模型签署</li><li>从以前的错误中学习</li></ul>



<p>以下是您在选择Vertex ML元数据替代或任何元数据存储时应该考虑的事项。</p>



<p>1.<strong>跟踪能力</strong></p>



<p>您将跟踪超参数、模型、代码、资源、见解等等。元数据存储应该提供各种各样的跟踪功能，包括数据版本控制、跟踪数据和模型血统、源代码版本控制，甚至是测试和生产环境的版本控制。因此，请确保您选择的工具包含项目所需的所有追踪功能。</p>



<p>2.<strong>集成</strong></p>



<p>为了捕获在管道的每个阶段创建的生活元素，理想的元数据存储应该能够与所有主要或最重要的工具和框架集成。</p>



<p>3.<strong>轻松协作</strong></p>



<p>为了设计一个成功的ML解决方案，开发团队、运营团队，甚至商业团队都需要协作。元数据存储应该是可靠的，并允许团队成员之间的简单协作。对于团队在ML实验中的合作，你使用的工具应该提供这样的条款。</p>



<p>4.<strong>详细见解</strong></p>



<p>虽然元数据存储在不同阶段收集数据，但它也应该提供智能见解，从而加快测试并增强报告。理想的元数据存储平台应该能够为开发人员提供动态可视化，他们可以定制这些可视化来说明管道数据的独特重点领域。</p>



<p>5.<strong>可视化</strong></p>



<p>一个像样的视觉表现将使其更容易评估结果。它简化了复杂的概念，并允许您向利益相关者传达可视化的结果。它还可以帮助您执行错误分析，并确定需要改进的地方。</p>



<p>由于上面讨论的所有原因，Vertex AI可能并不完全适合所有人。因此，让我们来看看目前市场上一些具有吸引力功能的顶级解决方案:</p>











<p>Neptune是一个元数据存储库。它是一个连接<a href="/web/20221201180901/https://neptune.ai/blog/mlops" target="_blank" rel="noreferrer noopener"> MLOps </a>工作流的几个组件的工具，比如数据版本化、实验跟踪、模型注册和监控。它简化了模型开发过程中创建的所有信息的存储、管理、可视化和比较</p>



<p>Neptune提供了一个Python客户端库,让用户<a href="https://web.archive.org/web/20221201180901/https://docs.neptune.ai/you-should-know/what-can-you-log-and-display" target="_blank" rel="noreferrer noopener">在他们的ML实验中记录并跟踪任何元数据类型</a>,无论这些是在Python脚本、Jupyter笔记本、Amazon SageMaker笔记本还是Google Colab中运行的。</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><a href="https://web.archive.org/web/20221201180901/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Metadata-dashboard-experiments.png?ssl=1"><img decoding="async" src="../Images/746379c1f2153afe91b731293e51aa7a.png" alt="Metadata-dashboard-experiments" class="wp-image-51513" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221201180901im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Metadata-dashboard-experiments.png?ssl=1"/></a><figcaption><em>Example dashboard with logged metadata | </em><a href="https://web.archive.org/web/20221201180901/https://app.neptune.ai/o/common/org/project-cv/e/PROJCV-103/dashboard/variety-metadata-d78dd5d4-dc58-4488-baa0-0bbe1017ceec" target="_blank" rel="noreferrer noopener"><em>Source</em></a></figcaption></figure></div>



<h4 id="neptune-summary">海王星摘要</h4>



<p>Neptune增强了团队对机器学习项目的管理。它的<strong>易于使用的界面</strong>让您可以汇总跑步记录，保存自定义仪表板视图，并快速与您的团队分享。</p>



<ul><li><strong>记录并显示所有元数据类型</strong>，包括参数、模型权重和媒体文件。</li><li>用户界面易于使用，并为<strong>分组运行提供了多种选项。</strong></li><li><strong>比较见解</strong>和参数。</li><li><strong>自动记录</strong>代码、环境、参数、模型二进制文件等等。</li><li><strong>跟踪在脚本、笔记本和任何基础设施上执行的实验</strong>。</li><li>广泛的实验跟踪和<strong>可视化功能。</strong></li><li>您可以监控硬件，让您的实验自动运行。<strong>检查您的模型训练运行消耗的GPU/CPU </strong>和内存量。</li></ul>







<ul><li>Neptune提供了一个Python客户端库。</li><li>它提供了一个非常直观和灵活的用户界面，允许用户以他们选择的方式查看和排列数据。</li><li>Neptune保存了大部分元数据及其版本，使用户更容易重新创建模型。</li><li>它允许与超过25种不同的工具顺利集成。</li><li>性价比高。</li></ul>







<p>TensorFlow的ML元数据(MLMD)是TensorFlow Extended (TFX)的一部分，后者是一个用于部署机器学习解决方案的端到端框架。每次运行生产ML管道时，都会生成元数据，其中包含有关管道组件、它们的执行(例如，训练运行)以及所生成的工件(例如，训练模型)的信息。</p>



<p>MLMD建筑由三样东西组成，</p>



<ul><li><strong>驱动</strong>，为执行程序提供所需的元数据。</li><li><strong>执行器</strong>是组件功能编码的地方。</li><li>结果由<strong>发布者</strong>存储在元数据中。</li></ul>







<h4 id="mlmd-summary">MLMD摘要</h4>



<ul><li>跟踪管道中组件之间的元数据流动。</li><li><strong>支持多个存储</strong>后端。</li><li>您可以通过加载相同类型的两个工件来比较它们。</li><li>它存储关于管道组件血统的元数据</li><li>它列出了特定类型的所有工件。</li><li>存储有关管道执行的信息。</li><li>它有用于存储和检索元数据的API。</li><li>存储后端是可扩展和可插拔的。</li><li>它记录和查询工作流运行的上下文。</li></ul>



<p>这篇教程将帮助你更好地了解MLMD。</p>



<h4 id="advantages-over-vertex-ai">最大似然元数据(MLMD)与顶点最大似然元数据</h4>



<ul><li>Vertex ML元数据和MLMD都是以相同的方式构建的，尽管它们在API、工作流和其他方面存在一些差异。</li><li>顶点人工智能是一个企业级人工智能平台，而MLMD是一个用于记录和检索机器学习应用相关信息的库。</li><li>MLMD是一个强大的开源模型调试库。</li><li>与模型优先视图相比，它优先考虑管道视图。</li></ul>







<p>MLflow是一个开源的ML生命周期管理工具。它帮助数据科学家和ML工程师进行实验、部署和模型注册。它可以与各种ML库和工具一起使用。它也是一个开源的模型优先的机器学习元数据存储，您可以使用它来监控您的实验或为生产打包模型。</p>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img decoding="async" loading="lazy" src="../Images/6bd9fcca24e6517a8b412e4933f72339.png" alt="MLflow example view" class="wp-image-61577" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221201180901im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/MLflow-example-view.png?resize=840%2C413&amp;ssl=1"/><figcaption><em>MLflow example dashboard | <a href="https://web.archive.org/web/20221201180901/https://www.mlflow.org/docs/latest/tutorials-and-examples/tutorial.htmlhttps://www.mlflow.org/docs/latest/tutorials-and-examples/tutorial.html" target="_blank" rel="noreferrer noopener nofollow">Source</a></em></figcaption></figure></div>



<h4 id="mlflow-summary">MLFlow摘要</h4>



<ul><li>它可以与<strong>任何机器学习库</strong>、语言或任何现有代码一起工作。它在任何云中都以同样的方式运行。</li><li>它以标准化的格式打包了一个ML模型，可以被下游工具使用。</li><li>MLflow的四个主要组件是MLflow跟踪、MLflow项目、MLflow模型和MLflow注册表。</li><li>您可以使用MLflow tracking来<strong>存储和查询您的代码</strong>和数据实验。</li><li>MLFlow tracking让您<strong>记录工件、度量、参数、来源、时间等等。</strong></li><li>MLflow projects是一个数据科学包，其中包含可重用和可复制的代码。它还带有一个API和一个命令行工具，用于ML和数据科学任务。</li><li><strong>不同类型的ML模型</strong>可使用MLflow模型进行部署。每个模型都存储为包含任意数量文件的目录。</li></ul>



<h4 id="advantages-over-vertex-ai">ML流与顶点ML元数据</h4>



<ul><li>它是一个开源平台。</li><li>MLflow是高度可定制的。</li><li>提供实时实验跟踪。</li><li>MLflow可以与任何云服务提供商合作。</li></ul>











<p>Kubeflow是一款面向Kubernetes的机器学习工具，是开源的。Kubeflow将数据科学过程中的各个阶段转化为Kubernetes任务，为您的机器学习库、框架、管道和笔记本提供云原生接口。</p>



<p>默认情况下，Kubeflow包含一个元数据组件，用于存储和提供元数据。在管道运行期间，它会自动记录元数据。这使您可以跟踪管道版本、上次更新时间和元数据等信息，以便分析管道运行。</p>







<h4 id="kubeflow-summary">Kubeflow摘要</h4>



<ul><li>部署在各种基础设施上是可重复和可移植的。</li><li><strong>支持多种框架</strong>和平台。</li><li>特别是<a href="https://web.archive.org/web/20221201180901/https://www.kubeflow.org/docs/components/pipelines/overview/quickstart/" target="_blank" rel="noreferrer noopener nofollow"> kubeflow pipeline </a>自动记录关于运行的信息，包括工作流工件、执行和沿袭。</li><li>Kubernetes 用户会发现Kubeflow非常适合。</li><li>除了自动跟踪之外，您还可以手动写入元数据服务器以收集其他元数据。</li><li><strong>它是可扩展的</strong>，并提供了广泛的超参数调谐选项。</li></ul>



<p>从<a href="https://web.archive.org/web/20221201180901/https://www.kubeflow.org/docs/about/kubeflow/"> Kubeflow文档中了解更多信息。</a></p>







<h4 id="advantages-over-vertex-ai">Kubeflow与顶点ML元数据</h4>



<ul><li>它是一个开源平台。</li><li>即使是中小型企业也能从其可扩展性中受益。</li><li>对于管理和跟踪模型实验、任务和运行，它提供了一个优秀的用户界面。</li><li>Kubeflow允许用户快速连接到其他平台，如果需要，用户可以轻松地迁移到另一个平台。</li></ul>







<p>Valohai是一个自动提取数据和部署模型的MLOps平台。有了Valohai，你的团队在生产机器学习方面向前迈进了一大步。其端到端MLOps平台使团队能够快速、自信地创建和部署机器学习系统。</p>







<h4 id="valohai-summary">Valohai summary</h4>



<ul><li>您可以使用Valohai在任何<strong>云或本地系统</strong>上进行测试，并且您不必担心任何常规的DevOps任务。</li><li>你用Valohai做的一切都在平台上<strong>保存和版本化</strong>。</li><li>从模型到测量，一切都可以在你和你的团队之间轻松共享。</li><li>您可以<strong>跟踪您的执行情况</strong>主要KPI，并根据您的独特指标轻松安排它们。</li><li>从代码中以JSON形式发布的任何内容都有可能被捕获为Valohai元数据。</li><li>您可以<strong>将执行指标</strong>作为时间序列或散点图进行比较。</li></ul>



<p>你可以在Valohai网站上找到更多关于这些功能的信息。</p>



<h4 id="advantages-over-vertex-ai">瓦罗海vs顶点ML元数据</h4>



<ul><li>Valohai提供了一个名为<em> valohai-utils </em>的Python实用程序库来帮助处理日常的样板文件。</li><li>它确保过程是一致的，并且团队中的每个人都知道正在发生什么。</li><li>你可以用图表或表格的形式比较实验的结果。</li><li>兼容任何编程语言和ML框架。</li><li>您可以选择将元数据下载为CSV或JSON文件。</li></ul>







<p>Amazon SageMaker让数据科学家准备、构建、培训、调整、部署和管理所有的ML实验。它有一个用户友好的界面，使ML工程师和数据科学家的任务变得相当容易。如果您目前使用AWS，Sagemaker Studio是理想的选择，因为它为所有AWS产品提供了出色的集成支持。</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img decoding="async" src="../Images/fae0c6c379030450b959b6872ad1b497.png" alt="Amazon SageMaker UI" class="wp-image-61582" data-recalc-dims="1" data-original-src="https://web.archive.org/web/20221201180901im_/https://i0.wp.com/neptune.ai/wp-content/uploads/2022/10/Amazon-SageMaker-UI.jpg?ssl=1"/><figcaption><em>Amazon SageMaker Studio UI | <a href="https://web.archive.org/web/20221201180901/https://mkai.org/customize-amazon-sagemaker-studio-using-lifecycle-configurations/" target="_blank" rel="noreferrer noopener nofollow">Source </a></em></figcaption></figure></div>



<h4 id="sagemaker-studio-summary">pagemaker studio摘要</h4>



<ul><li>它可以与其他AWS工具无缝协作。</li><li>易于使用的界面。</li><li>您可以<strong>跟踪容器的输入和输出。</strong></li><li><strong>跟踪并可视化</strong>数千次实验。</li><li>Sagemaker包括一个与robomaker集成的<strong> python库</strong>，允许两个系统在整个训练过程中进行通信。</li><li>它带有用于训练和运行你的实验的内置算法。</li><li>SageMaker有一个<strong>内置调试器</strong>来帮助你发现和修复问题。</li></ul>



<h4 id="advantages-over-vertex-ai">亚马逊pagemaker vs vertex ml元数据</h4>



<ul><li>Sagemaker可以监控容器的输入和输出。</li><li>它具有可视化指标的能力。</li><li>它还允许您从较小的实例开始。</li><li>Sagemaker支持模型注册和模型工件重新编译。</li></ul>











<section id="large-table-block_61fd39a06cfbf" class="block-large-table c-table__outer-wrapper ">

    <table class="c-table">
                    <thead class="c-table__head">
                <tr>
                    <td class="c-item"/>

                                            <td class="c-item">
                            <p class="c-item__inner">海王星</p>
                        </td>
                                            <td class="c-item">
                            <p class="c-item__inner">ML元数据</p>
                        </td>
                                            <td class="c-item">
                            <p class="c-item__inner">MLflow</p>
                        </td>
                                            <td class="c-item">
                            <p class="c-item__inner">Kubeflow</p>
                        </td>
                                            <td class="c-item">
                            <p class="c-item__inner">瓦罗海</p>
                        </td>
                                            <td class="c-item">
                            <p class="c-item__inner">著名的专业排版软件</p>
                        </td>
                    
                </tr>
            </thead>
        

        <tbody class="c-table__body">

                            
                    <tr class="c-row">

                                                                                                                    
                                    <td class="c-ceil c-ceil--first">
                                        <p class="c-ceil__inner"><strong>定价</strong></p>
                                    </td>

                                                                    
                                    <td class="c-ceil"><div class="c-ceil__inner"> <p> <span data-sheets-value="{&quot;1&quot;:2,&quot;2&quot;:&quot;* Individual: Free (+ usage above free quota) n* Academia: Freen* Team: Paid&quot;}" data-sheets-userformat="{&quot;2&quot;:1049345,&quot;3&quot;:{&quot;1&quot;:0},&quot;11&quot;:4,&quot;12&quot;:0,&quot;23&quot;:1}" data-sheets-textstyleruns="{&quot;1&quot;:0}{&quot;1&quot;:72,&quot;2&quot;:{&quot;2&quot;:{&quot;1&quot;:2,&quot;2&quot;:1136076},&quot;9&quot;:1}}" data-sheets-hyperlinkruns="{&quot;1&quot;:72,&quot;2&quot;:&quot;https://neptune.ai/pricing&quot;}{&quot;1&quot;:76}">个人免费(+免费额度以上使用量)，a </span>学院:免费，团队:<a class="in-cell-link" href="https://web.archive.org/web/20221201180901/https://neptune.ai/pricing" target="_blank" rel="noopener">付费</a> </p> </div></td>

                                                                    
                                    <td class="c-ceil">
                                        <p class="c-ceil__inner"><strong>开源</strong></p>
                                    </td>

                                                                    
                                    <td class="c-ceil">
                                        <p class="c-ceil__inner"><strong>开源</strong></p>
                                    </td>

                                                                    
                                    <td class="c-ceil">
                                        <p class="c-ceil__inner"><strong>开源</strong></p>
                                    </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                                                                        
                    </tr>

                
                    <tr class="c-row">

                                                                                                                    
                                    <td class="c-ceil c-ceil--first">
                                        <p class="c-ceil__inner"><strong>特性</strong></p>
                                    </td>

                                                                    
                                    <td class="c-ceil"><div class="c-ceil__inner"> <ul> t <li> <span>灵活，与其他框架配合良好</span> </li> <p> t </p> <li> <span>直观的UI</span></li><p>t</p><li><span>易于与团队和利益相关者协作</span> </li> </ul> </div></td>

                                                                    
                                    <td class="c-ceil"><div class="c-ceil__inner"> <ul> t <li> <span>存储是可扩展和可插拔的</span> </li> <p> t </p> <li> <span>允许您存储广泛的元数据</span> </li> </ul> </div></td>

                                                                    
                                    <td class="c-ceil"><div class="c-ceil__inner"> <ul> t <li> <span>高度可定制</span> </li> <p> t </p> <li> <span>完美契合数据科学工作流程</span> </li> <p> t </p> <li> <span>可与任何机器学习库、语言或任何现有代码</span> </li> </ul> </div></td>

                                                                    
                                    <td class="c-ceil"><div class="c-ceil__inner"> <ul> t <li> <span>完美适合Kubernetes用户</span> </li> <p> t </p> <li> <span>高度可扩展</span> </li> <p> t </p> <li> <span>自动记录关于运行的信息，包括工作流工件</span> </li> </ul> </div></td>

                                                                    
                                    <td class="c-ceil"><div class="c-ceil__inner"> <ul> t <li> <span>易用协作特性</span> </li> <p> t </p> <li> <span>你用Valohai做的一切都保存在平台上并版本化</span> </li> </ul> </div></td>

                                                                    
                                    <td class="c-ceil"><div class="c-ceil__inner"> <ul> t <li> <span>与SageMaker平台</span> </li> <p> t </p> <li> <span>易于使用的界面</span> </li> </ul> </div></td>

                                                                                                                        
                    </tr>

                
                    <tr class="c-row">

                                                                                                                    
                                    <td class="c-ceil c-ceil--first">
                                        <p class="c-ceil__inner"><strong>主持</strong></p>
                                    </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                                                                        
                    </tr>

                
                    <tr class="c-row">

                                                                                                                    
                                    <td class="c-ceil c-ceil--first">
                                        <p class="c-ceil__inner"><strong>超参数跟踪</strong></p>
                                    </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                                                                        
                    </tr>

                
                    <tr class="c-row">

                                                                                                                    
                                    <td class="c-ceil c-ceil--first">
                                        <p class="c-ceil__inner"><strong>输入/输出工件</strong></p>
                                    </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                                                                        
                    </tr>

                
                    <tr class="c-row">

                                                                                                                    
                                    <td class="c-ceil c-ceil--first">
                                        <p class="c-ceil__inner"><strong>视觉对比</strong></p>
                                    </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                                                                        
                    </tr>

                
                    <tr class="c-row">

                                                                                                                    
                                    <td class="c-ceil c-ceil--first">
                                        <p class="c-ceil__inner"><strong>数据集版本化</strong></p>
                                    </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">
                                        <p class="c-ceil__inner">                                                                                                                                                                                                                                                                           </p>
                                    </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                    
                                    <td class="c-ceil">                                                                              </td>

                                                                                                                        
                    </tr>

                            
        </tbody>

    </table>

</section>



<p>让我们快速比较一下这些平台。</p>



<h2 id="final-thoughts">最后的想法</h2>



<p>元数据是任何端到端ML开发过程的重要部分，因为它不仅加快了过程，而且提高了最终管道的质量。</p>



<p>Vertex AI是ML专业人士中比较新的机器学习平台。它有很大的潜力，但也有一定的局限性，这就是为什么企业正在寻找更加开放和简单的集成解决方案。我们讨论了几个ML元数据存储，你可以根据你的机器学习需求选择一个。我希望你喜欢这篇文章。</p>



<p>快乐实验！</p>



<h3 id="references-and-recommending-reading">参考文献和推荐阅读:</h3>




        </div>
        
    </div>    
</body>
</html>