<html>
<head>
<title>Understanding LightGBM Parameters (and How to Tune Them) </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解LightGBM参数(以及如何调整它们)</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://neptune.ai/blog/lightgbm-parameters-guide#0001-01-01">https://web.archive.org/web/https://neptune.ai/blog/lightgbm-parameters-guide#0001-01-01</a></blockquote><div><div class="l-content content-wrapper js-content">
            
<p>我已经用了<a href="https://web.archive.org/web/20230127191010/https://github.com/microsoft/LightGBM/tree/master/python-package" target="_blank" rel="noreferrer noopener nofollow"> lightGBM </a>一段时间了。这是我解决大多数表格数据问题的常用算法。<a href="https://web.archive.org/web/20230127191010/https://lightgbm.readthedocs.io/en/latest/Features.html" target="_blank" rel="noreferrer noopener nofollow">的令人敬畏的特性</a>的列表很长，我建议你如果还没有看的话看一看。</p>



<p>但是我一直很想了解哪些参数对性能影响最大，以及我应该如何调优lightGBM参数以充分利用它。</p>



<p>我想我应该做一些研究，了解更多关于lightGBM的参数…并分享我的旅程。</p>



<p>具体来说，我:</p>







<p>在此过程中，我获得了更多关于lightGBM参数的知识。我希望读完这篇文章后，你能够回答以下问题:</p>



<ul>
<li>LightGBM中实现了哪些梯度提升方法，有什么不同？</li>



<li>一般来说，哪些参数是重要的？</li>



<li>需要调整哪些正则化参数？</li>



<li>如何在python中调优lightGBM参数？</li>
</ul>



<h2 id="h-gradient-boosting-methods">梯度推进方法</h2>



<p>使用LightGBM，您可以运行不同类型的梯度增强方法。您有:GBDT、达特和戈斯，它们可以用<code>boosting</code>参数来指定。</p>



<p>在接下来的部分中，我将解释和比较这些方法。</p>



<h3><strong> lgbm gbdt(梯度增强决策树)</strong></h3>



<p>这种方法是传统的梯度推进决策树，在这篇<a href="https://web.archive.org/web/20230127191010/https://statweb.stanford.edu/~jhf/ftp/trebst.pdf" target="_blank" rel="noreferrer noopener nofollow"> <strong>文章</strong> </a>中首次提出，并且是XGBoost和pGBRT等一些伟大库背后的算法。</p>



<p>如今，gbdt因其准确性、高效性和稳定性而被广泛使用。你可能知道gbdt是决策树的集合模型，但是它到底是什么意思呢？</p>







<p>让我给你一个要点。</p>



<p>它基于三个重要原则:</p>



<ul>
<li>弱学习者(决策树)</li>



<li>梯度优化</li>



<li>助推技术</li>
</ul>



<p>所以在gbdt方法中，我们有很多决策树(弱学习者)。这些树是按顺序建造的:</p>



<ul>
<li>第一棵树学习如何适应目标变量</li>



<li>第二棵树学习如何拟合第一棵树的预测和地面真实值之间的残差(差异)</li>



<li>第三棵树学习如何拟合第二棵树的残差，以此类推。</li>
</ul>



<p>所有这些树都是通过在整个系统中传播误差梯度来训练的。</p>



<p>gbdt的主要缺点是在每个树节点中寻找<a href="https://web.archive.org/web/20230127191010/https://papers.nips.cc/paper/6907-lightgbm-a-highly-efficient-gradient-boosting-decision-tree.pdf" target="_blank" rel="noreferrer noopener nofollow">最佳分裂点</a>是耗时且消耗内存的操作。其他boosting方法试图解决这个问题。</p>



<h3><strong>镖梯度增强</strong></h3>



<p>在这篇出色的<a href="https://web.archive.org/web/20230127191010/https://arxiv.org/abs/1505.01866" target="_blank" rel="noreferrer noopener nofollow">论文</a>中，您可以了解关于DART梯度提升的所有事情，DART梯度提升是一种使用神经网络中的标准下降来改善模型正则化并处理其他一些不太明显的问题的方法。</p>



<p>也就是说，gbdt遭受过度特殊化，这意味着在后面的迭代中添加的树往往只影响少数实例的预测，而对其余实例的贡献可以忽略不计。添加dropout会使树在以后的迭代中更难专注于这几个样本，从而提高性能。</p>



<h3><strong> lgbm goss(基于梯度的单侧采样)</strong></h3>



<p>事实上，将这种方法命名为lightgbm的最重要原因是使用了基于这篇<a href="https://web.archive.org/web/20230127191010/https://papers.nips.cc/paper/6907-lightgbm-a-highly-efficient-gradient-boosting-decision-tree.pdf">论文</a>的<a href="https://web.archive.org/web/20230127191010/https://papers.nips.cc/paper/6907-lightgbm-a-highly-efficient-gradient-boosting-decision-tree.pdf">Goss</a>方法。Goss是更新更轻的gbdt实现(因此是“轻”gbm)。</p>



<p>标准的gbdt是可靠的，但是在大型数据集上不够快。因此，goss提出了一种基于梯度的采样方法，以避免搜索整个搜索空间。我们知道，对于每个数据实例，当梯度较小时，这意味着不用担心数据训练良好，当梯度较大时，应该再次重新训练。所以我们这里有<strong>两边</strong>，有大梯度和小梯度的数据实例。因此，goss保留所有具有大梯度的数据，并对具有小梯度的数据进行随机采样(<strong>，这就是为什么它被称为单侧采样</strong>)。这使得搜索空间更小，goss可以更快地收敛。最后，为了获得更多关于戈斯的信息，你可以看看这篇<a href="https://web.archive.org/web/20230127191010/https://towardsdatascience.com/what-makes-lightgbm-lightning-fast-a27cf0d9785e" target="_blank" rel="noreferrer noopener nofollow">的博文</a>。</p>



<p>让我们将这些差异放在一个表格中:</p>



<div id="medium-table-block_1b8dd4d818e1589feff19c92ff466ef0" class="block-medium-table c-table__outer-wrapper ">

    <table class="c-table">
                    <thead class="c-table__head">
            <tr>
                                    <td class="c-item">
                        <p class="c-item__inner">方法</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">注意</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">需要改变这些参数</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">优势</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">不足之处</p>
                    </td>
                            </tr>
            </thead>
        
        <tbody class="c-table__body">

                    
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>是</p> </div>的默认增压类型</td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>因为gbdt是lgbm的默认参数，所以您不必为它更改其余参数的值(仍然必须进行调整！)</p> </div></td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>过度特殊化，耗时耗力</p> </div></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>试图解决gbdt </p> </div>中的过度专业化问题</td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> drop_seed:用于选择丢弃模式的随机种子sUniform_dro:如果要使用统一丢弃xgboost_dart_mode:如果要使用xgboost dart模式，请将其设置为true skip _ drop:在提升迭代期间跳过丢弃过程的概率max_dropdrop_rate:丢弃率:在丢弃过程中要丢弃的先前树的分数</p> </div></td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>戈斯通过分离那些梯度较大的实例为GBDT提供了一种新的采样方法</p> </div></td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> top_rate:大梯度数据保留率other_rate:小梯度数据保留率</p> </div></td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>数据集小时过拟合</p> </div></td>

                    
                </tr>

                    
        </tbody>
    </table>

</div>



<p id="separator-block_cac1b96869d6043c707dc9a6663808d2" class="block-separator block-separator--10"> </p>



<section id="note-block_1f6561bba129383405c9b7abe58c3f2a" class="block-note c-box c-box--default c-box--dark c-box--no-hover c-box--standard ">

    

    <div class="block-note__content">
                    <div class="c-item c-item--text">

                <img alt="" class="c-item__arrow lazyload" src="../Images/e26f9310772a1cfa52ddfe91020e2852.png" data-src="https://web.archive.org/web/20230127191010/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg" data-original-src="https://web.archive.org/web/20230127191010/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg"/>

                <div class="c-item__content">

                                            <p>如果你设置提升为RF，那么lightgbm算法表现为随机森林，而不是提升的树！根据文档，要使用RF，必须使用小于1的bagging_fraction和feature_fraction。</p>
                                    </div>

            </div>
            </div>


</section>



<h2 id="h-regularization">正规化</h2>



<p>在这一节中，我将介绍lightgbm的一些重要的正则化参数。显然，这些是您需要调整以防止过度拟合的参数。</p>



<p>您应该知道，对于小数据集(&lt; 10000条记录)，lightGBM可能不是最佳选择。调优lightgbm参数可能对您没有帮助。</p>



<p>此外，lightgbm使用<a href="https://web.archive.org/web/20230127191010/https://lightgbm.readthedocs.io/en/latest/Features.html#leaf-wise-best-first-tree-growth" target="_blank" rel="noreferrer noopener nofollow">逐叶</a>树生长算法，而eXGBoost使用深度树生长算法。逐叶方法允许树更快地收敛，但是过度拟合的机会增加了。</p>



<p>也许这个来自PyData会议的<a href="https://web.archive.org/web/20230127191010/https://youtu.be/5CWwwtEM2TA" target="_blank" rel="noreferrer noopener nofollow">演讲给了你更多关于Xgboost和Lightgbm的见解。值得一看！</a></p>



<figure class="wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><p class="wp-block-embed__wrapper"><iframe loading="lazy" title="Can one do better than XGBoost? - Mateusz Susik" src="https://web.archive.org/web/20230127191010if_/https://www.youtube.com/embed/5CWwwtEM2TA?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">视频</iframe></p></figure>



<section id="note-block_1e84c0a12bb322e33826a2a48f371c1c" class="block-note c-box c-box--default c-box--dark c-box--no-hover c-box--standard ">

    

    <div class="block-note__content">
                    <div class="c-item c-item--text">

                <img alt="" class="c-item__arrow lazyload" src="../Images/e26f9310772a1cfa52ddfe91020e2852.png" data-src="https://web.archive.org/web/20230127191010/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg" data-original-src="https://web.archive.org/web/20230127191010/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg"/>

                <div class="c-item__content">

                                            <p>如果有人问你LightGBM和XGBoost的主要区别是什么？你可以很容易地说，它们的区别在于它们是如何实现的。</p>
                                    </div>

            </div>
            </div>


</section>



<p>根据<a href="https://web.archive.org/web/20230127191010/https://lightgbm.readthedocs.io/en/latest/Parameters-Tuning.html#deal-with-over-fitting" target="_blank" rel="noreferrer noopener nofollow"> lightGBM文档</a>，当面临过拟合时，您可能希望进行以下参数调整:</p>



<ul>
<li>使用小max_bin</li>



<li>使用小数量的叶子</li>



<li>使用叶中最小数据和叶中最小和</li>



<li>通过设置bagging_fraction和bagging_freq来使用bagging</li>



<li>通过设置feature_fraction使用特征子采样</li>



<li>使用更大的训练数据</li>



<li>尝试lambda_l1、lambda_l2和min_gain_to_split进行正则化</li>



<li>尝试max_depth以避免树越长越深</li>
</ul>



<p>在接下来的几节中，我将更详细地解释这些参数。</p>



<h3><strong>λ_ L1</strong></h3>



<p>Lambda_l1(和lambda_l2)控制到l1/l2，并与min_gain_to_split一起用于对抗<strong>过拟合</strong>。我强烈建议您使用参数调整(在后面的小节中探讨)来找出这些参数的最佳值。</p>



<h3><strong>叶子数量</strong></h3>



<p>当然<strong> num_leaves </strong>是控制模型的<strong>复杂度</strong>的最重要参数之一。使用它，您可以设置每个弱学习者拥有的最大叶片数。较大的num_leaves增加了训练集的准确性，也增加了因过度训练而受伤的机会。根据文档，一个简单的方法是<strong> num_leaves = 2^(max_depth) </strong>然而，考虑到在lightgbm中，逐叶树比逐层树更深，你需要小心过度拟合！<strong>因此，有必要将</strong> <strong> num_leaves </strong> <strong>与</strong> <strong> max_depth </strong> <strong>一起调。</strong></p>







<h3><strong>子样本</strong></h3>



<p>使用<a href="https://web.archive.org/web/20230127191010/https://lightgbm.readthedocs.io/en/latest/Parameters.html#learning-control-parameters" target="_blank" rel="noreferrer noopener nofollow">子样本</a>(或bagging_fraction)，您可以指定每个树构建迭代中使用的行的百分比。这意味着将随机选择一些行来适应每个学习者(树)。这不仅提高了泛化能力，还提高了训练速度。</p>





<p>我建议对基线模型使用较小的子样本值，然后在完成其他实验时增加这个值(不同的特征选择，不同的树结构)。</p>



<h3><strong>特征_分数</strong></h3>



<p><a href="https://web.archive.org/web/20230127191010/https://lightgbm.readthedocs.io/en/latest/Parameters.html#learning-control-parameters" target="_blank" rel="noreferrer noopener nofollow"> Feature fraction </a>或sub_feature处理列采样，LightGBM将在每次迭代(树)中随机选择一个特征子集。例如，如果将其设置为0.6，LightGBM将在训练每棵树之前选择60%的特征。</p>



<p>该功能有两种用法:</p>



<ul>
<li>可以用来加速训练</li>



<li>可以用来处理过度拟合</li>
</ul>





<h3><strong>最大深度</strong></h3>



<p>该参数控制每个训练树的最大深度，并将影响:</p>



<ul>
<li>num_leaves参数的最佳值</li>



<li>模型性能</li>



<li>训练时间</li>
</ul>



<p>请注意，如果您使用较大的值<strong> max_depth </strong>，您的模型将很可能<strong>过度适合</strong>列车组。</p>



<h3><strong> max_bin </strong></h3>



<p>宁滨是一种在离散视图(直方图)中表示数据的技术。Lightgbm使用基于直方图的算法来寻找最佳分割点，同时创建弱学习器。因此，每个连续的数字特征(例如，视频的观看次数)应该被分成离散的箱。</p>





<p>还有，在这个<a href="https://web.archive.org/web/20230127191010/https://github.com/szilard/GBM-perf" target="_blank" rel="noreferrer noopener nofollow"> GitHub r </a> epo里，你可以找到一些全面的实验，完整的解释了改变max_bin对CPU和GPU的影响。</p>





<p>如果将max_bin定义为255，这意味着每个特性最多可以有255个唯一值。那么小的max_bin导致更快的速度，大的值提高精度。</p>



<h2 id="h-training-parameters">训练参数</h2>



<p>训练时间！当您希望使用lightgbm训练模型时，训练lightgbm模型时可能出现的一些典型问题是:</p>



<ul>
<li>培训是一个耗时的过程</li>



<li>处理计算复杂性(CPU/GPU RAM限制)</li>



<li>处理分类特征</li>



<li>拥有不平衡的数据集</li>



<li>对定制指标的需求</li>



<li>分类或回归问题需要进行的调整</li>
</ul>



<p/>



<p>在本节中，我们将尝试详细解释这些要点。</p>



<h3><strong>迭代次数</strong></h3>



<p>Num_iterations指定提升迭代的次数(要构建的树)。构建的树越多，模型就越精确，代价是:</p>



<ul>
<li>更长的训练时间</li>



<li>过度拟合的可能性更高</li>
</ul>



<p>从较低数量的树开始构建基线，稍后当您想要从模型中挤出最后的%时，增加基线。</p>



<p>建议使用较小的<strong>学习速率</strong>和较大的<strong>次数迭代</strong>。此外，如果你的训练没有学到任何有用的东西，你应该使用early_stopping_rounds来停止你的训练。</p>



<h3><strong>提前_停止_回合</strong></h3>



<p>如果验证指标在最后一轮提前停止后没有改善，该参数将停止<strong>训练</strong>。这应该与迭代次数的<strong>成对定义。如果你设置的太大，你会增加<strong>过度拟合</strong>的机会(但是你的模型可以更好)。</strong></p>



<p>经验法则是在num_iterations的10%时使用它。</p>



<h3><strong>light GBM category _ feature</strong></h3>



<p>使用lightgbm的一个优点是它可以很好地处理分类特征。是的，这个算法非常强大，但是你必须小心使用它的参数。lightgbm使用一种特殊的<a href="https://web.archive.org/web/20230127191010/https://lightgbm.readthedocs.io/en/latest/Features.html#optimal-split-for-categorical-features" target="_blank" rel="noreferrer noopener nofollow"><strong/></a>整数编码方法(由<a href="https://web.archive.org/web/20230127191010/http://www.csiss.org/SPACE/workshops/2004/SAC/files/fisher.pdf" target="_blank" rel="noreferrer noopener nofollow"> <strong>费希尔</strong> </a>提出)来处理分类特征</p>



<p>实验表明，该方法比常用的<strong>一键编码</strong>具有更好的性能。</p>



<p>它的缺省值是“auto ”,这意味着:让lightgbm决定哪个意味着lightgbm将推断哪些特征是分类的。</p>



<p>它并不总是工作得很好(一些实验显示了为什么这里的<a href="https://web.archive.org/web/20230127191010/https://www.kaggle.com/mlisovyi/beware-of-categorical-features-in-lgbm" target="_blank" rel="noreferrer noopener nofollow">和这里的</a>和<a href="https://web.archive.org/web/20230127191010/https://www.kaggle.com/c/home-credit-default-risk/discussion/58950" target="_blank" rel="noreferrer noopener nofollow">和</a>)我强烈建议你简单地用这段代码手动设置<a href="https://web.archive.org/web/20230127191010/https://www.kaggle.com/mlisovyi/beware-of-categorical-features-in-lgbm#339301" target="_blank" rel="noreferrer noopener nofollow">分类特征</a></p>



<p><strong>cat _ col = dataset _ name . select _ dtypes(' object '). columns . to list()</strong></p>



<p>但是幕后发生了什么，lightgbm如何处理分类特性？</p>



<p>根据lightgbm的<a href="https://web.archive.org/web/20230127191010/https://lightgbm.readthedocs.io/en/latest/Features.html#optimal-split-for-categorical-features" target="_blank" rel="noreferrer noopener nofollow"> <strong>文档</strong> </a>，我们知道树学习者不能很好地使用一种热编码方法，因为他们通过树深入生长。在所提出的替代方法中，树学习器被最佳地构造。例如，对于具有k个不同类别的一个特征，存在2^(k-1)-1个可能的分区，并且使用<a href="https://web.archive.org/web/20230127191010/http://www.csiss.org/SPACE/workshops/2004/SAC/files/fisher.pdf" target="_blank" rel="noreferrer noopener nofollow"> fisher </a>方法，该方法可以通过在分类特征中的值的排序直方图上找到最佳分割方式来改进为<strong> k * log(k) </strong>。</p>



<h3><strong>light GBM is _ unbalance vs scale _ pos _ weight</strong></h3>



<p>在<strong>二元分类问题</strong>中你可能面临的一个问题就是如何处理<strong>不平衡</strong>数据集。显然，您需要平衡正/负样本，但是在lightgbm中您如何做到这一点呢？</p>



<p>lightgbm中有两个参数可以让你处理这个问题<strong> is_unbalance和scale_pos_weight </strong>，但是它们之间有什么区别，如何使用？</p>



<ul>
<li>当您设置Is _ un lace:True时，算法将尝试自动平衡受支配标签的权重(使用训练集中的正/负分数)</li>



<li>如果您想要在不平衡数据集的情况下更改<strong> scale_pos_weight </strong>(默认为1，这意味着假设正负标签相等)，您可以使用以下公式(基于lightgbm存储库上的这个<a href="https://web.archive.org/web/20230127191010/https://github.com/microsoft/LightGBM/issues/1299" target="_blank" rel="noreferrer noopener nofollow">问题</a>)来正确设置它</li>
</ul>



<p><strong>样本位置权重=阴性样本数/阳性样本数</strong></p>



<h3><strong> lgbm feval </strong></h3>



<p>有时你想要定义一个定制的评估函数来测量你的模型的性能，你需要创建一个<code>feval</code>函数。</p>



<p><strong> Feval函数</strong>应该接受两个参数:</p>







<p>并返回</p>



<ul>
<li>评估名称</li>



<li>评估结果</li>



<li>越高越好吗</li>
</ul>



<p>让我们一步一步地创建一个定制的度量函数。</p>



<p>定义一个单独的python函数</p>



<p>使用此函数作为参数:</p>



<pre class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">feval_func</span><span class="hljs-params">(preds, train_data)</span>:</span>
   
    <span class="hljs-keyword">return</span> (<span class="hljs-string">'feval_func_name'</span>, eval_result, <span class="hljs-keyword">False</span>)</pre>



<p>要使用feval函数而不是公制，您应该设置公制参数“无”。</p>



<pre class="hljs">print(<span class="hljs-string">'Start training...'</span>)
lgb_train = lgb.train(...,
                      metric=<span class="hljs-keyword">None</span>,
                      feval=feval_func)</pre>



<section id="note-block_76ba6ef5a68bf84f5392bcb4aff73bd3" class="block-note c-box c-box--default c-box--dark c-box--no-hover c-box--standard ">

    

    <div class="block-note__content">
                    <div class="c-item c-item--text">

                <img alt="" class="c-item__arrow lazyload" src="../Images/e26f9310772a1cfa52ddfe91020e2852.png" data-src="https://web.archive.org/web/20230127191010/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg" data-original-src="https://web.archive.org/web/20230127191010/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg"/>

                <div class="c-item__content">

                                            <p><strong>分类参数与回归参数</strong></p>
                                    </div>

            </div>
            </div>


</section>



<h3>我之前提到的大多数事情对于分类和回归都是正确的，但是有些事情需要调整。</h3>



<p>具体来说，您应该:</p>



<p>参数的名称</p>



<div id="medium-table-block_f77cff6a5292fda3d360b1ced11fb198" class="block-medium-table c-table__outer-wrapper ">

    <table class="c-table">
                    <thead class="c-table__head">
            <tr>
                                    <td class="c-item">
                        <p class="c-item__inner">分类说明</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">回归注释</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">                                                      </p>
                    </td>
                            </tr>
            </thead>
        
        <tbody class="c-table__body">

                    
                <tr class="c-row">

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>设置为二进制或多类</p> </div></td>

                    
                        <td class="c-ceil">将其设置为二进制或多类</td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> Binary_logloss或AUC等。</p>T3】</div></td>

                    
                        <td class="c-ceil">Binary_logloss或AUC或etc。</td>

                    
                        <td class="c-ceil">RMSE或平均绝对误差和或等。</td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>仅用于二进制和多类应用</p> </div></td>

                    
                        <td class="c-ceil">仅用于二进制和多类应用</td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>仅在多类分类应用中使用</p> </div></td>

                    
                        <td class="c-ceil">仅用于多类分类应用</td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p>用于拟合sqrt(标签)代替原始值用于大范围标签</p> </div></td>

                    
                        <td class="c-ceil">用于拟合sqrt(标签),而不是大范围标签的原始值</td>

                    
                </tr>

                    
        </tbody>
    </table>

</div>



<h2 id="h-the-most-important-lightgbm-parameters">在前面的章节中，我们已经回顾并了解了一些关于lightgbm参数的知识，但是如果不提到Laurae的令人难以置信的基准测试，任何一篇关于boosted trees的文章都是不完整的🙂</h2>



<p>您可以了解lightGBM和XGBoost的许多问题的最佳缺省参数。</p>



<p>你可以<a href="https://web.archive.org/web/20230127191010/https://sites.google.com/view/lauraepp/parameters" target="_blank" rel="noreferrer noopener nofollow">点击这里</a>查看，但最重要的几点是:</p>



<p>参数名称</p>



<div id="medium-table-block_5aca5e642bef876dec28d45972fdc9d0" class="block-medium-table c-table__outer-wrapper ">

    <table class="c-table">
                    <thead class="c-table__head">
            <tr>
                                    <td class="c-item">
                        <p class="c-item__inner">默认值</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">范围</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">参数类型</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">别名</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">约束或注释</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">用于</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">                                                      </p>
                    </td>
                            </tr>
            </thead>
        
        <tbody class="c-table__body">

                    
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span>当你改变它时会影响其他参数</span> </p> </div></td>

                    
                        <td class="c-ceil"><span>当你改变它时会影响其他参数</span></td>

                    
                        <td class="c-ceil"><span>指定ML模型的类型</span></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span>空表示将使用指定目标对应的度量</span> </p> </div></td>

                    
                        <td class="c-ceil"><span>空表示将使用与指定目标相对应的指标</span></td>

                    
                        <td class="c-ceil"><span>指定指标，支持多个指标</span></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span>如果设置为RF，那将是一个装袋方式</span> </p> </div></td>

                    
                        <td class="c-ceil"><span>如果设置为RF，这将是一种打包方法</span></td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span> 0.0 &lt;套袋_分数&lt;= 1.0</span></p>T5】</div></td>

                    
                        <td class="c-ceil"><span> 0.0 &lt;套袋_分数&lt; = 1.0 </span></td>

                    
                        <td class="c-ceil"><span>随机选择部分数据，无需重采样</span></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span>要启用bagging，bagging_fraction也要设置成小于1.0的值</span> </p> </div></td>

                    
                        <td class="c-ceil"><span>为了启用bagging，bagging_fraction也应设置为小于1.0的值</span></td>

                    
                        <td class="c-ceil"><span> 0表示禁用装袋；k表示每k次迭代进行打包</span></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span>一棵树的最大叶子数</span> </p> </div></td>

                    
                        <td class="c-ceil"><span>一棵树的最大叶子数</span></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span> 0.0 &lt;特征_分数&lt;= 1.0</span></p>T5】</div></td>

                    
                        <td class="c-ceil"><span> 0.0 &lt;特征_分数&lt; = 1.0 </span></td>

                    
                        <td class="c-ceil"><span>如果设置为0.8，LightGBM将选择80%的功能</span></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span>通常越大越好，但是过拟合速度会增加</span> </p> </div></td>

                    
                        <td class="c-ceil"><span>通常越大越好，但是过度拟合速度会增加</span></td>

                    
                        <td class="c-ceil"><span>限制树模型的最大深度</span></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span>助推迭代次数</span> </p> </div></td>

                    
                        <td class="c-ceil"><span>升压迭代次数</span></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span>学习率&gt;0.0典型值:0.05</span></p>T5】</div></td>

                    
                        <td class="c-ceil"><span>学习率&gt;0.0典型值:0.05 </span></td>

                    
                        <td class="c-ceil"><span>在dart中，它也影响掉落树木的归一化权重</span></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span>如果最后一次验证没有改善，将停止训练_停止</span></p><p><span>_回合</span> </p> </div></td>

                    
                        <td class="c-ceil"><span>如果验证在最近一次提前停止中没有改善，将停止培训</span></td>

                    
                        <td class="c-ceil"><span>模型性能、迭代次数、训练时间</span></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span>指定某一列的编号指标</span> </p> </div></td>

                    
                        <td class="c-ceil"><span>为列索引指定一个数字</span></td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span>处理分类特征</span></p>T5】</div></td>

                    
                        <td class="c-ceil"><span>处理分类特征</span></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span> 0表示禁用装袋；k表示每k次迭代进行打包</span> </p> </div></td>

                    
                        <td class="c-ceil"><span> 0表示禁用装袋；k表示每k次迭代进行打包</span></td>

                    
                        <td class="c-ceil"><span>为了启用bagging，bagging_fraction也应设置为小于1.0的值</span></td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span> &lt; 0:致命，= 0:错误(警告)，= 1:信息，&gt; 1:调试</span> </p> </div></td>

                    
                        <td class="c-ceil"><span> &lt; 0:致命，= 0:错误(警告)，= 1:信息，&gt; 1:调试</span></td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil"><div class="c-ceil__inner"> <p> <span>可以用来处理过拟合</span> </p> </div></td>

                    
                        <td class="c-ceil"><span>可用于处理过拟合</span></td>

                    
                </tr>

                    
        </tbody>
    </table>

</div>



<p id="separator-block_ed52f065f06031405ec5ea0122a24038" class="block-separator block-separator--10">你不应该认为任何参数值是理所当然的，并根据你的问题来调整它。也就是说，这些参数是您的超参数调整算法的一个很好的起点</p>



<section id="note-block_0bf1858f9b48d29437e2fc12c46b5193" class="block-note c-box c-box--default c-box--dark c-box--no-hover c-box--standard ">

    

    <div class="block-note__content">
                    <div class="c-item c-item--text">

                <img alt="" class="c-item__arrow lazyload" src="../Images/e26f9310772a1cfa52ddfe91020e2852.png" data-src="https://web.archive.org/web/20230127191010/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg" data-original-src="https://web.archive.org/web/20230127191010/https://neptune.ai/wp-content/themes/neptune/img/blocks/note/list-arrow.svg"/>

                <div class="c-item__content">

                                            <p> </p>
                                    </div>

            </div>
            </div>


</section>



<p id="separator-block_d50f21e98209731da43a5d9dae309273" class="block-separator block-separator--5">python中的Lightgbm参数调优示例(lightgbm调优)</p>







<h2 id="h-lightgbm-parameter-tuning-example-in-python-lightgbm-tuning">最后，在解释完所有重要参数之后，是时候进行一些实验了！</h2>



<p>我就用一个流行的Kaggle比赛:<a href="https://web.archive.org/web/20230127191010/https://www.kaggle.com/c/santander-customer-transaction-prediction/data" target="_blank" rel="noreferrer noopener nofollow">桑坦德客户交易预测</a>。</p>



<p>我将使用这篇文章解释如何在任何脚本上运行Python中的超参数调优。</p>



<p>值得一读！</p>



<p>在我们开始之前，一个重要的问题！我们应该调整哪些参数？</p>



<p>注意您想要解决的问题，例如，Santander数据集<strong>高度不平衡</strong>，在您的调优中应该考虑到这一点！<a href="https://web.archive.org/web/20230127191010/https://github.com/Laurae2" target="_blank" rel="noreferrer noopener nofollow"> Laurae2 </a>，lightgbm的贡献者之一<a href="https://web.archive.org/web/20230127191010/https://github.com/microsoft/LightGBM/issues/695#issuecomment-315591634" target="_blank" rel="noreferrer noopener nofollow">在这里</a>很好的解释了这一点。</p>



<ul>
<li>有些参数是相互依赖的，必须一起调整或逐个调整。例如，min_data_in_leaf取决于训练样本的数量和num _ leaf。</li>



<li>注意:最好为超参数创建两个字典，一个包含您不想优化的参数和值，另一个包含您想要优化的参数和值范围。</li>
</ul>



<p>通过这样做，您可以将基线值从搜索空间中分离出来！</p>



<pre class="hljs">SEARCH_PARAMS = {<span class="hljs-string">'learning_rate'</span>: <span class="hljs-number">0.4</span>,
                 <span class="hljs-string">'max_depth'</span>: <span class="hljs-number">15</span>,
                 <span class="hljs-string">'num_leaves'</span>: <span class="hljs-number">20</span>,
                 <span class="hljs-string">'feature_fraction'</span>: <span class="hljs-number">0.8</span>,
                 <span class="hljs-string">'subsample'</span>: <span class="hljs-number">0.2</span>}

FIXED_PARAMS={<span class="hljs-string">'objective'</span>: <span class="hljs-string">'binary'</span>,
              <span class="hljs-string">'metric'</span>: <span class="hljs-string">'auc'</span>,
              <span class="hljs-string">'is_unbalance'</span>:<span class="hljs-keyword">True</span>,
              <span class="hljs-string">'boosting'</span>:<span class="hljs-string">'gbdt'</span>,
              <span class="hljs-string">'num_boost_round'</span>:<span class="hljs-number">300</span>,
              <span class="hljs-string">'early_stopping_rounds'</span>:<span class="hljs-number">30</span>}</pre>



<p>现在，我们要做的是。</p>



<p>首先，我们在<a href="https://web.archive.org/web/20230127191010/https://app.neptune.ai/mjbahmani/LightGBM-hyperparameters/notebooks?notebookId=Some-experiments-based-on-lightgbm-1-dc193057-c63d-41a3-9144-eb1759e5b8f9" target="_blank" rel="noreferrer noopener nofollow"> <strong>笔记本</strong> </a>中生成代码。它是公开的，你可以<strong>下载。</strong></p>



<ol>
<li>第二，我们在<a href="/web/20230127191010/https://neptune.ai/" target="_blank" rel="noreferrer noopener"> <strong> neptune.ai </strong> </a>中跟踪每个实验的结果。你可以<a href="https://web.archive.org/web/20230127191010/https://app.neptune.ai/mjbahmani/LightGBM-hyperparameters/experiments?split=tbl&amp;dash=charts&amp;viewId=standard-view" target="_blank" rel="noreferrer noopener nofollow">在应用</a>中看到这个例子，因为它是我作为公共项目创建的。</li>
</ol>



<ol start="2">
<li>查看文档，了解更多关于使用<a href="https://web.archive.org/web/20230127191010/https://docs.neptune.ai/integrations/lightgbm/" target="_blank" rel="noopener"> Neptune-LightGBM集成</a>跟踪模型构建元数据的信息。</li>
</ol>



<section id="blog-intext-cta-block_20aae2ee53fff026cc8575f66f093833" class="block-blog-intext-cta  c-box c-box--default c-box--dark c-box--no-hover c-box--standard ">

            
    
            <p><strong>结果分析</strong></p>
    
    </section>



<h3>如果您已经检查了前面的部分，您会注意到我已经在数据集上做了超过14个不同的实验。在这里，我解释如何一步一步地调整超参数的值。</h3>



<p><em>注:最新的代码示例请参考<a href="https://web.archive.org/web/20230127191010/https://docs.neptune.ai/integrations/lightgbm/" target="_blank" rel="noreferrer noopener"> Neptune-LightGBM集成文档</a>。</em></p>



<p>创建基准培训代码:</p>



<p> </p>



<div class="block-code-snippet  l-padding__top--0 l-padding__bottom--0 block-code-snippet--regular language-py line-numbers">
    <pre><code>from sklearn.metrics import roc_auc_score, roc_curve
from sklearn.model_selection import train_test_split
import neptunecontrib.monitoring.skopt as sk_utils
import lightgbm as lgb
import pandas as pd
import neptune
import skopt
import sys
import os

SEARCH_PARAMS = {'learning_rate': 0.4,
                'max_depth': 15,
                'num_leaves': 32,
                'feature_fraction': 0.8,
                'subsample': 0.2}

FIXED_PARAMS={'objective': 'binary',
             'metric': 'auc',
             'is_unbalance':True,
             'bagging_freq':5,
             'boosting':'dart',
             'num_boost_round':300,
             'early_stopping_rounds':30}

def train_evaluate(search_params):
   # you can download the dataset from this link(https://www.kaggle.com/c/santander-customer-transaction-prediction/data)
   # import Dataset to play with it
   data= pd.read_csv("sample_train.csv")
   X = data.drop(['ID_code', 'target'], axis=1)
   y = data['target']
   X_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=0.2, random_state=1234)
   train_data = lgb.Dataset(X_train, label=y_train)
   valid_data = lgb.Dataset(X_valid, label=y_valid, reference=train_data)

   params = {'metric':FIXED_PARAMS['metric'],
             'objective':FIXED_PARAMS['objective'],
             **search_params}

   model = lgb.train(params, train_data,
                     valid_sets=[valid_data],
                     num_boost_round=FIXED_PARAMS['num_boost_round'],
                     early_stopping_rounds=FIXED_PARAMS['early_stopping_rounds'],
                     valid_names=['valid'])
   score = model.best_score['valid']['auc']
   return score</code></pre>
</div>





<p id="separator-block_a999e8cc14f1fa8f8be908d6509b244c" class="block-separator block-separator--10">使用您选择的超参数优化库(例如scikit-optimize):</p>



<p> </p>



<div class="block-code-snippet  l-padding__top--0 l-padding__bottom--0 block-code-snippet--regular language-py line-numbers">
    <pre><code>neptune.init('mjbahmani/LightGBM-hyperparameters')
neptune.create_experiment('lgb-tuning_final', upload_source_files=['*.*'],
                              tags=['lgb-tuning', 'dart'],params=SEARCH_PARAMS)

SPACE = [
   skopt.space.Real(0.01, 0.5, name='learning_rate', prior='log-uniform'),
   skopt.space.Integer(1, 30, name='max_depth'),
   skopt.space.Integer(10, 200, name='num_leaves'),
   skopt.space.Real(0.1, 1.0, name='feature_fraction', prior='uniform'),
   skopt.space.Real(0.1, 1.0, name='subsample', prior='uniform')
]
@skopt.utils.use_named_args(SPACE)
def objective(**params):
   return -1.0 * train_evaluate(params)

monitor = sk_utils.NeptuneMonitor()
results = skopt.forest_minimize(objective, SPACE,
                                n_calls=100, n_random_starts=10,
                                callback=[monitor])
sk_utils.log_results(results)

neptune.stop()</code></pre>
</div>





<p id="separator-block_a999e8cc14f1fa8f8be908d6509b244c" class="block-separator block-separator--10">尝试不同类型的配置，并在Neptune应用程序中跟踪您的结果。</p>



<p>最后，在下表中，您可以看到参数发生了什么变化。</p>





<p>超参数</p>



<div id="medium-table-block_8e6fd5836b989d7db09539114644f616" class="block-medium-table c-table__outer-wrapper ">

    <table class="c-table">
                    <thead class="c-table__head">
            <tr>
                                    <td class="c-item">
                        <p class="c-item__inner">调谐前</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">调谐后</p>
                    </td>
                                    <td class="c-item">
                        <p class="c-item__inner">                                                      </p>
                    </td>
                            </tr>
            </thead>
        
        <tbody class="c-table__body">

                    
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                </tr>

            
                <tr class="c-row">

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">                                                      </td>

                    
                        <td class="c-ceil">最后的想法</td>

                    
                </tr>

                    
        </tbody>
    </table>

</div>



<h2 id="h-final-thoughts">长话短说，你学到了:</h2>



<p>什么是主要的lightgbm参数</p>



<ul>
<li>如何使用feval函数创建定制指标</li>



<li>主要参数有哪些好的默认值</li>



<li>查看了如何调整lightgbm参数以提高模型性能的示例</li>



<li>和其他一些东西🙂更多详细信息，请参考参考资料。</li>
</ul>



<p>资源</p>



<h3><a href="https://web.archive.org/web/20230127191010/https://sites.google.com/view/lauraepp/parameters" target="_blank" rel="noreferrer noopener nofollow"> Laurae广泛的指南，具有良好的默认设置等</a></h3>



<ol>
<li><a href="https://web.archive.org/web/20230127191010/https://github.com/microsoft/LightGBM/tree/master/python-package" target="_blank" rel="noreferrer noopener nofollow">https://github . com/Microsoft/light GBM/tree/master/python-package</a></li>



<li><a href="https://web.archive.org/web/20230127191010/https://lightgbm.readthedocs.io/en/latest/index.html" target="_blank" rel="noreferrer noopener nofollow">https://lightgbm.readthedocs.io/en/latest/index.html</a></li>



<li><a href="https://web.archive.org/web/20230127191010/https://papers.nips.cc/paper/6907-lightgbm-a-highly-efficient-gradient-boosting-decision-tree.pdf" target="_blank" rel="noreferrer noopener nofollow">https://papers . nips . cc/paper/6907-light GBM-a-high-efficient-gradient-boosting-decision-tree . pdf</a></li>



<li><a href="https://web.archive.org/web/20230127191010/https://statweb.stanford.edu/~jhf/ftp/trebst.pdf" target="_blank" rel="noreferrer noopener nofollow">https://statweb.stanford.edu/~jhf/ftp/trebst.pdf</a></li>



<li><a href="https://web.archive.org/web/20230127191010/https://statweb.stanford.edu/~jhf/ftp/trebst.pdf" target="_blank" rel="noreferrer noopener nofollow">https://statweb.stanford.edu/~jhf/ftp/trebst.pdf</a></li>
</ol>
        </div>
        
    </div>    
</body>
</html>